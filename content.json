{"meta":{"title":"apexsoft 기술블로그","subtitle":"모두가 master가 되는 날 까지","description":null,"author":"HyoSook Kim","url":"http://apexsoft.github.io"},"pages":[],"posts":[{"title":"EventBus","slug":"이벤트 ","date":"2018-02-27T04:49:25.010Z","updated":"2018-02-27T04:49:25.010Z","comments":true,"path":"2018/02/27/이벤트 /","link":"","permalink":"http://apexsoft.github.io/2018/02/27/이벤트 /","excerpt":"","text":"이벤트비 부모자식이벤트 버스 생성1var EventBus = new Vue() 이벤트 발행1EventBus.$emit('message', 'hello world'); 인벤트 구독 bus 인스턴스에 바인딩 이벤트를 수신하는 쪽은 미리 이벤트 헨들러를 등록 해두어야 한다. vue 인스턴스 생명 주기 created 이벤트 훅을 통해서 ,$on메서드를 사용해 이벤트 수신 정보 등록 123EventBus.$on('message', function(text) &#123; console.log(text);&#125;); this 현재 인스턴스 바인딩 123EventBus.$on('isAdmin', text =&gt; &#123; this.isAdmin = text; &#125;); 이벤트 리스너 제거 모두제거 1EventBus.$off(); 1EventBus.$off(['message']); 부모 자식 통신부모 컴포넌트가 자식컴포넌트의 이벤트를 청취 @이벤트 리스너 부모 컴포넌트는 자식컴포넌트가 사용되는 템플릿에서 ,자식 컴포넌트에 발생한 이벤트를 직접 청취 할수 있다. update이벤트가 발생할때 , componentEvent 메서드가 실행된다 1&lt;apex-page @update=\"componentEvent($event)\":per-page=\"perPage\"&gt;&lt;/apex-page&gt; 자식 (apex-page) 123456props: &#123; perPage: &#123; type: Number, default: () =&gt; 10 &#125; &#125; 123 methods: &#123; this.$emit('update', res.data); &#125; 부모 123456componentEvent($event) &#123; this.projectResults = $event.content; this.totalItems = $event.totalElements; this.searchData = $event.searchData; this.perPage = $event.size; &#125;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"}]},{"title":"영속성 컨텍스트","slug":"영속성 컨텍스트 트랜잭션","date":"2018-02-27T04:49:25.010Z","updated":"2018-02-27T04:49:25.010Z","comments":true,"path":"2018/02/27/영속성 컨텍스트 트랜잭션/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/영속성 컨텍스트 트랜잭션/","excerpt":"","text":"영속성 컨텍스트 엔티티를 영구 저장하는 환경 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다 엔티티의 생명주기 비영속 (영속성 컨텍스트와 전혀 관계가 없는 상태) 영속 (영속성 컨텍스트에 저장된 상태) 준영속 (저장되었다가 분리) 삭제 영속성 컨텍스트 특징 영속성 컨텍스트 엔티티 = 식별자 값 (@id) 로 매핑 동일성 보장 변경 감지 변경 감지 스냅샷 : jpa는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장해둔다 플러시 시점에 스탭샷과 엔티티를 비교해서 변경된 엔티티를 찾는다 트랜잭션 커밋 = 엔티티 매니저 플러시가 호출 스냅샷으로 변경된 엔티티 찾는다 변경된 엔티티가 있으면 수정 쿼리를 생성해서 , 쓰기 지연 sql 저장소에 보낸다 쓰기 지연 저장소의 sql을 데이터 베이스에 보낸다 데이터베이스의 트랜잭션을 커밋한다 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다. 트랜잭션 범위의 영속성 컨텍스트스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 사용한다 트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 같다 트랜잭션을 시작할 때 영속성 컨텍스를 생성하고 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다 ​ 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다 123456789@Transactionalpublic class ProjectService &#123;public void delete(int projectCode) &#123; Project project = projectRepository.findOne(projectCode); project.setProjectFlag(\"0\"); &#125;&#125; @Transactional 선언해서 , 메소드를 호출할 때 트랜잭션을 먼저 시작한다 project는 영속 상태 projectRepository.findOne(projectCode) 통해 조회한 project엔티티는 트랜잭션 범위 안에 있으므로 ,영속성 컨텍스트의 관리를 받는다 project는 영속 상태로 변경 감지가 가능한다 @Transactional 선언한 메소드가 정상 종료 되면 트랜잭션 커밋 = 영속성 컨텍스트 종료 = 엔티티 매니저 플러시가 호출 스냅샷으로 변경된 엔티티 찾는다 변경된 엔티티가 있으면 수정 쿼리를 생성해서 , 쓰기 지연 sql 저장소에 보낸다 쓰기 지연 저장소의 sql을 데이터 베이스에 보낸다 데이터베이스의 트랜잭션을 커밋한다 ​ ​ ​","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"JPA기본키설정","slug":"기본키설정","date":"2018-02-27T04:49:25.010Z","updated":"2018-02-27T04:49:25.010Z","comments":true,"path":"2018/02/27/기본키설정/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/기본키설정/","excerpt":"","text":"@Entity테이블과 매핑할 클래스는 필수로 붙혀야 함 클래스에 @Entity 를 붙여주면 JPA가 Entity로서 관리 한다는 것을 의미한다. 속성 name다른 Entity와 충돌이 우려될 경우 이름을 바꿔준다. 기본적으로는 Class명을 따른다. 주의사항 기본 생성자 필수 final, enum, interface, inner 클래스 사용 못함 저장 필드에 final 사용 못함 @Table엔티티와 매핑할 테이블을 지정 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용. name : 매핑할 테이블 이름 속성 name매핑할 table 이름, 기본은 Entity 이름을 사용한다. catalogcatalog 기능이 있는 DB에서 catalog를 매핑 schemaschema 기능이 있는 DB에서 schema를 매핑 uniqueConstraintsDDL 생성 시에 유니크 제약조건을 만든다. @Id기본키 직접 할당 자동 생성(Auto_Increment) 123@GeneratedValueprivate String userId; ​ @EmbeddedId2개이상의 기본키 조합 1234567891011121314@Entity@Getter@Setter@Table(name = \"COMM_CODE\")@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"commCodeId\")public class CommCode extends BaseEntity implements Serializable &#123; @EmbeddedId private CommCodeId commCodeId; @Column(name = \"CODE_VAL\") private String codeVal;&#125; 1234567@Embeddablepublic class CommCodeId implements Serializable &#123; private String codeGrp; private String code;&#125; @Column객체 필드를 테이블 컬럼에 매핑 name : 필드와 매핑할 테이블의 컬럼 이름. 기본값이 필드 이름 123456@Column(name = \"cart_id\")private Long id;private String name;&gt;&gt;&gt; 매핑 정보가 없는 필드 &gt;&gt; 자동으로 매핑 columnDefinition : 데이터베이스 컬럼 정보를 직접 설정. nullable : null 값 허용 여부 false일 경우, not null 제약조건이 됨. 기본값이 true update 여부 설정 1234@CreatedDate@Column(name = &quot;created_at&quot;, updatable = false)@JsonIgnoreprivate LocalDateTime createdDateTime; @Transient필드는 매핑 하지 않는다. 데이터베이스에 저장하지 않고 , 조회하지도 않는다 객체에 임시로 어떤 값을 보관하고 싶을때 사용한다","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"web 서버","slug":"web 서버","date":"2018-02-27T04:49:24.995Z","updated":"2018-02-27T04:49:24.995Z","comments":true,"path":"2018/02/27/web 서버/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/web 서버/","excerpt":"","text":"web 서버 웹 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고, HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램 초기 웹은 정보교환이 목적이었기 때문에 전송할 데이터가 정적인 데이터뿐이었다. (html, img, xml…) 따라서 그에 맞는 기능에 충실하였고, 지금도 정적인 데이터를 전송하는데는 웹서버가 안정적이다 웹서버의 표준으로 불리는 것이 있다. 바로 ‘Apache’이다. 시간이 흐르면서 웹을 사용하는 용도는 변화했습니다. 데이터를 주고 받으면서 화면이 동적으로 움직여야 했습니다. 입력된 값에 따라 출력된 결과가 나타나는 것이죠. 그런 요구에 따라 나타난게 Web Application Server입니다. 핵심정리 : apache = 웹서버 Web Application 서버 WAS 동적인 변화를 위해 만들어진 서버입니다. 웹서버는 정적인 데이터를 처리했다면, WAS는 동적인 데이터를 담당하겠죠. 사용자의 요청으로 데이터의 조작이 가능하고 그에 따라 화면의 동적으로 변하는 것을 가능하게 도와주는 서버입니다. 동적인 데이터 뿐만 아니라 정적 데이터도 처리가 가능하다는 것입니다. 그러나 큰 프로젝트나 많은 사용자를 가진 웹서비스는 흔히 웹서버와 WAS를 함께 사용합니다. 그 이유는 각각의 역할을 구분하여 더 효율적인 일을 하기 위해서이죠. 위에서도 밝혔듯이 웹서버는 정적인 데이터를 WAS에 비해 더 안정적이고 빠르게 다룰 수 있습니다. 그런 이유로 apache 와 WAS를 연동하여 사용하는 경우가 대부분입니다 ​ 핵심정리 : Web Application Server (웹서버 + 웹 컨테이너) = tomcat(WAS) Web서버와 Web Container의 역할을 둘다 감당하고 있는 것을 볼 수 있습니다. tomcat만으로도 웹서비스를 할 수 있습니다. 그러나 웹서버 apache와 함께 연동해서 역할을 구분해주면 더욱 강력하게 사용할 수 있습니다. ​ Web Container 웹컨테이너는 자바언어에서 사용하는 개념입니다. 서블릿(Servlet) &amp; JSP를 구동하기위해 필요한 것이 웹컨테이너이죠. (서블릿에 대한 더 자세한 설명) 서블릿은 자바로 작성되어 있기 때문에 따로 이를 구동시켜줄 프로그램이 필요합니다. 그것이 바로 웹컨테이너라 이해하며 되겠습니다. ​ Web 서버, WAS의 차이웹서버는 정적인 데이터 (html, img, xml…) 를 처리합니다. 웹서버를 통하면 WAS 보다 빠르고 안정적입니다. WAS는 동적인 데이터를 처리하는 서버이고 데이터베이스에 연결되어 데이터를 주고받아 웹어프리케이션을 운영합니다. IOC 제어의 역전 객체 생성을 직접 하지 않고 WAS(Web Application Service / 톰캣) 또는 프레임워크(스프링)가 생성해주는 객체를 가져다 사용 하는 것 WAS는 대부분 서블릿 객체를 자동으로 생성 Spring은 설정파일에 만든 Bean을 자동으로 생성 Ioc를 이용하게 되면 생성과 소멸을 WAS나 프레임워크가 담당하게 되어 싱글톤을 만드는 코드나 메모리 정리 등의 코드를 우리가 하지 않도 되기 때문에 관리가 편하다 @Component @Contoller, @Service, @Repository의 상위 개념으로 자동으로 Bean을 등록하고 싶은 곳에 사용된다. 객체를 등록하고 싶은 클래스 위에 썾면 Bean으로 등록 해달라는 표시 빈으로 등록할 Class에 선언하는 annotation @Configuration의 @ComponentScan에 의해서 scan되고 빈으로 등록 됨 Stereotype annotation &gt; @Component를 용도에 따라 미리 정형화 해놓은 타입 stereotype들은 내부적으로 @Component를 가지고 있음 @Repository - DAO 또는 레포지토리 클래스에 사용 &gt;예외를 모두 DataAccessException으로 변환 처리 @Service - 서비스 계층의 클래스에 사용 @Controller - 프레젠테이션 계층의 MVC 컨트롤러에 사용 presentation layer의 controller에 적용 spring web servlet에 의해 웹 요청을 처리하는 controller bean 선정 객체풀 부팅과 동시에 자신이 가져야할 객체를 생성(스프링빈)한다. 객체를 쌓아두었다가 필요할 때 주입. 쌓아둔 모양이 콩처럼 겼다고 해서 beans. DI (의존성 주입) Dependence Injection 원하는 부품 목록을 작성하면, Spring이 조립해준다. 필요한 객체는 스프링을 통해서 주입받는 구조. xml이나 어노테이션(@)를 통하여 객체 간 의존 관계를 설정. 객체 자체를 직접 생성 또는 검색 할 필요가 없다 @Autowired● 컨테이너에 들어있는 빈 객체 중에서 타입이 일치하는 빈 객체를 주입시킴 ● 타입이 일치하는 빈 객체가 없으면 ? ! ? ! ? → 에러 !! 해당 빈 객체 자체가 등록이 안되고, 그러면 컨테이너 자체가 빌드가 안됨 → 에러는 안띄우고 그냥 주입없이 가고 싶으면 .. ? required값을 false로 지정 : @Autowired(required = false) 컨테이너가 생성안돼서 생기는 BeanCreateException 에서 생성은 되지만 넣을게 없는 NullPointerException ​ ​ ​ ​ spring boot최소한의 노력으로 spring 기반의 프로젝트를 시작 할 수 있도록 도와주는 기술사용 이유 단독으로 상용제품 수준의 스프링 기반 애플리케이션 자바 기반에서는 WAS (웹 컨테이너 / 웹 서버 역활 )가 없이는 웹 애플리케이션이 구동하지 않았습니다. 하지만, Spring Boot를 사용하면 이런 복잡한 WAS 설치나 배포 없이 stand-alone 으로 웹 프로젝트를 생성하고 java –jar 명령어를 통해 tomcat이나 jetty를 내장한 상태로 웹 애플리케이션을 실행할 수 있습니다 최소한의 설정으로 spring 플랫폼과 서드파티 라이브러리 사용 구성시 설정을 위한 xml 코드를 생성하거나 요구하지 않음 Java-based configuration 메인 클래스에 @Configuration 과 main method를 두자 @ImportResource xml 설정을 import @EnableAutoConfiguration classpath 의 jar dependencies를 참고해서 자동으로 설정을 해준다. 현재 자동 설정된 내용을 알고 싶으면 스프링부트를 –debug 모드로 시작하면 콘솔 로그를 통해 확인 가능 하다 Classpath의 내용에 기반해서 알아서 설정 작업들을 해준다. 즉, classpath에 tomcat-embed-core.jar 가 존재 하면 톰캣 서버가 세팅되고, spring-webmvc.jar가 존재하면 자동으로 web.xml을 생성해 DispatcherServlet을 등록해준다. = @RestController = @Controller + @ResponseBody 별도의 @RequestMapping된 메소드들 마다 일일이 @ResponseBody를 붙이지 않아도 된다. ​ ymlyml 설정하기yml12345678910111213141516---spring.profiles: awsfile.rootDir: gradnetpay: lgdacom: /opt/lgdacom casnoteurl: https://casnote.gradnet.co.kr/yonsei/casnote/notice---spring.profiles: rdsspring.datasource: type: org.apache.tomcat.jdbc.pool.DataSource driver-class-name: com.mysql.jdbc.Driver---spring.profiles: prodpay.platform: serviceaws.s3.bucketName: apexsoft.service.gradnet.upload — 구분 된다 사용 vm argument 에 정보를 넣는다 1234-Dspring.profiles.active=aws,rds,prod$ java -jar -Dspring.profiles.active=aws,rds,prod -Dfile.encoding=UTF-8 -jar build/libs/gradnet-0.0.1-SNAPSHOT.jar","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://apexsoft.github.io/tags/web/"},{"name":"server","slug":"server","permalink":"http://apexsoft.github.io/tags/server/"}]},{"title":"vue.js 기본","slug":"vue 정리","date":"2018-02-27T04:49:24.995Z","updated":"2018-02-27T04:49:24.995Z","comments":true,"path":"2018/02/27/vue 정리/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/vue 정리/","excerpt":"","text":"JSBin 브라우저에서 JavaScript, CSS, HTML 코드를 작성 하여 실시간으로 결과를 확인 할 수 있는 서비스 https://jsbin.com/fivomus/edit?html,output MVVM ( Model-View-ViewModel ) 웹페이지는 돔(사람들이 눈으로 보는 페이지 ) 과 자바스크립트의 연합으로 만들어지게 되는데 돔이 View 역할을 하고, 자바스크립트가 Model 역할을 한다. ​ 뷰모델이 없는 아키텍처에서는 getElementById 같은 돔 API를 직접 이용해서 모델과 뷰를 연결해야 한다. 자바스크립트에서 컨트롤러 혹은 프리젠터 역할까지 하면서 코드양이 증가하는 단점이 생기기게 되는데 제이쿼리를 이용해 돔에 데이터 뿌려주는 코드들이 대부분 그랬다. view와 model 그 사이에서 View와는 바인딩이나 커멘드로 연결하고 Model과는 Data를 주고 받는 역할을 담당 뷰모델이 대신 수행해 주는 것이 MVVM 모델이다. 뷰모델에 자바스크립트 객체와 돔을 연결해 주면 뷰모델은 이 둘간의 동기화를 자동으로 처리한다. 이것이 뷰js가 하는 역할이다. MVC 패턴에서 컨트롤러 역할처럼 데이터를 관리하고 액션을 처리한다. 뷰모델 View Model MVVM 모델의 VM을 뷰js가 담당한다. MVC 패턴에서 컨트롤러 역할처럼 데이터를 관리하고 액션을 처리한다. Vue 생성자 함수의 인스턴스를 생성하면서 뷰 모델을 다루게 된다. 아래 예제와 같이 인스턴스를 생성할 때 뷰와 데이터를 연결하기 위한 옵션을 설정할 수 있다. 뷰 관련 옵션 : el, template 데이터 관련 옵션 : data, methods, computed 컴포넌트 관련 옵션 : components 생명 주기 훅 : created, mounted, updated, destroyed 데이터 관련 옵션computed( 선언적 의존 관계) computed 라는 의미는 진짜 말그대로 “계산된” 으로 해석이 됩니다. 선언적으로 의존 관계를 만들었다는 것입니다. 기본적으로 getter만 가지고 있지만, 필요한 경우 setter를 제공할 수 있습니다. 기본 (getter 사용)vue.js123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) computed (계산된) setter computed는 기본적으로 getter만 가지고 있지만 필요한 경우 setter를 제공함 vue.js1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 처음 fullname이 시작될 떄는 get부분의 코드가 작동된다는 뜻이며, fullname이란 값이 변한다면 set에 있는 함수가 작동된다는 것이다. 사용 html123456789&lt;div id=\"product-list-bottom\"&gt; &lt;div v-if=\"noMoreItems\"&gt;No more items&lt;/div&gt; &lt;/div&gt;computed: &#123; noMoreItems: function() &#123; return this.items.length == this.results.length &amp;&amp; this.results.length &gt; 0 &#125; &#125; ​ 감시자(watch) 대부분은 computed가 더 적합하지만 일부는 watch 가 필요한 경우가 있음 데이터 변경에 대한 응답으로 비동기식 또는 시간이 많이 소요되는 조작을 수행할 때 사용 우리나라말로 해석하면 감시자와 같습니다. 값의 변화를 주시하는 역할 우리가 알고있는 input text 에 이벤트로 onkeyup 을 넣으면 값이 들어오는걸 주시하고 있죠. onfocus 도 포커싱이 들어오면 바로 반응을 합니다. 이렇든 개발자들에게 감시자라는 단어는 매우 친숙하게 다가옵니다. ​ 우선 이 기능은 미리 data 안에 선언해주어야 합니다. 우리가 전역변수를 만들듯이 data , state , props 개념으로 사용되죠. n또한 v-model 과 함께 사용됩니다. 우리가 배운 v-model 은 양방향 바인딩이라고해서 클라이언트 측에서 데이터를 보내면 Script 단에 바로 받아 데이터를 수정해버립니다 v-model로 양방향 바인딩을 합니다. 즉 always 에 변화가 있을때 watch가 그걸 알아 차리고 그에 맞게 선언된 always 에 function 을 작동시킵니다. vue.js123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model='always'/&gt; &lt;div&gt;&#123;&#123;ing&#125;&#125;&lt;/div&gt;&lt;/div&gt;var demo = new Vue(&#123; el : \"#app\", data : &#123; always : '', ing : \"입력을 기다리는 중입니다.\" &#125;, watch : &#123; always : function(hook)&#123; console.log(hook) this.ing = \"입력중......\" this.fail(this.always); &#125; &#125;, methods : &#123; fail : function(text)&#123; if(text.length &lt; 5)&#123; this.ing = '5글자 이상이어야 합니다.'; &#125; &#125; &#125;&#125;) 계산된 캐싱(Computed Caching) vs 메소드(Methods) 둘다 vue.js 안에서 함수를 정의하는 부분 ​ 둘의 차이점은 데이터가 변동되지 않는다고 가정했을때에 드러난다. computed 데이터 변동이 없는 상태에서 computed는 이전의 계산된 값을 캐시해 두었다가 함수 호출시 다시 쓰게 된다. 종속성 중 일부가 변경된 경우에만 다시 계산 methods 사용될 때마다 함수의 계산을 다시 하게 된다. 종속성에 따라 캐시된다 만약 데이터가 자주 변동되지 않는다면, 비용적인 면에서는 computed가 좋다고 할 수 있고, 데이터가 수시로 업데이트 된다면 계속해서 캐시를 저장하는 computed보다는 methods가 더 좋을 수 있다. 그래서인지 html 상에서 computed는 마치 변수처럼 쓰이고, methods는 함수처럼 쓰인다. 예를들어 똑같은 parse라는 함수가 있다면 computed는 parse를 그대로 쓰고 methods는 parse()라고 쓰게 된다. 계산된 속성(Computed) vs 감시된 속성(Watched)html1&lt;div id=\"demo\"&gt; &#123;&#123; fullName &#125;&#125; &lt;/div&gt; vue.js12345678910111213141516var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 위의 코드를 보면 firstName 과 lastName 의 코드가 중복되므로 효율적이지 못함이때는 computed를 이용한다면 아래와 같이 한줄로 작성 가능해짐 vue.js123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) Template사용하기 편하고 반복적으로 사용할 수 있는 플랫폼 Component템플릿은 뭔가 추상적인 개념이라고 한다면 컴포넌트는 이를 구현할 기술이라고 생각해보죠. 독립적인 JS 하나당 component 하나를 만들어서 기능을 줘서 반복사용을 통해 활용성을 높이고 유지보수도 간편하게 할 수 있습니다. text 나 값은 props 나 data로 바꾸면 되니까요. 컴포넌트는 Vue의 가장 강력한 기능 중 하나입니다. 기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 캡슐화하는 데 도움이 됩니다. 상위 수준에서 컴포넌트는 Vue의 컴파일러에 의해 동작이 추가된 사용자 지정 엘리먼트입니다. 경우에 따라 특별한 is 속성으로 확장 된 원시 HTML 엘리먼트로 나타날 수도 있습니다. 새 vue 인스턴스 만들기 (root 인스턴스 생성) vue.js1234// 루트 인스턴스 생성new Vue(&#123; el: '#example'&#125;) ​ 전역 컴포넌트 등록 vue.js1234// 등록Vue.component('my-component', &#123; template: '&lt;div&gt;사용자 정의 컴포넌트 입니다!&lt;/div&gt;'&#125;) 컴포넌트는 인스턴스의 템플릿에서 커스텀 엘리먼트,&lt;my-component&gt;&lt;/my-component&gt;로 사용할 수 있습니다. 루트 Vue 인스턴스를 인스턴스화하기 전에 컴포넌트가 등록되어 있는지 확인하십시오. html123&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 모든 컴포넌트를 전역으로 등록 할 필요는 없습니다. 컴포넌트를 components 인스턴스 옵션으로 등록함으로써 다른 인스턴스/컴포넌트의 범위에서만 사용할 수있는 컴포넌트를 만들 수 있습니다: vue.js12345678910var Child = &#123; template: '&lt;div&gt;사용자 정의 컴포넌트 입니다!&lt;/div&gt;'&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 는 상위 템플릿에서만 사용할 수 있습니다. 'my-component': Child &#125;&#125;) data 는 반드시 함수여야합니다. Vue 생성자에 사용할 수 있는 대부분의 옵션은 컴포넌트에서 사용할 수 있습니다. 한가지 특별한 경우가 있습니다. data 는 함수여야 합니다. 컴포넌트 작성컴포넌트는 부모-자식 관계에서 가장 일반적으로 함께 사용하기 위한 것입니다. 컴포넌트 A는 자체 템플릿에서 컴포넌트 B를 사용할 수 있습니다. 그들은 필연적으로 서로 의사 소통이 필요합니다. 부모는 자식에게 데이터를 전달해야 할 수도 있으며, 자식은 자신에게 일어난 일을 부모에게 알릴 필요가 있습니다. 그러나 부모와 자식이 명확하게 정의된 인터페이스를 통해 가능한한 분리된 상태로 유지하는 것도 매우 중요합니다. 이렇게하면 각 컴포넌트의 코드를 상대적으로 격리 할 수 있도록 작성하고 추론할 수 있으므로 유지 관리가 쉽고 잠재적으로 쉽게 재사용 할 수 있습니다. Vue.js에서 부모-자식 컴포넌트 관계는 props는 아래로, events 위로 라고 요약 할 수 있습니다. 부모는 props를 통해 자식에게 데이터를 전달하고 자식은 events를 통해 부모에게 메시지를 보냅니다 v-bind를 사용하여 부모의 데이터에 props를 동적으로 바인딩 할 수 있음데이터가 상위에서 업데이트 될 때마다 하위 데이터로도 전달된다. html12345&lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt; 위와같이 코드를 작성하면 입력창에 입력하면 아랫줄에 같은 내용이 실시간으로 바인딩된다. 디렉티브 (Directive) 엘리먼트에게 이러이러하게 작동해라! 하고 지시를 해주는 지시문 vue 엘리먼트에서 사용디는 특별한 속성 디렉티브는 Vue 의 기능들을 사용하기 위해서 사용하는, HTML 태그 안에 들어가는 하나의 속성 v-text 이런 식으로 v- prefix 를 지니고 있습니다. ​ HTML 태그 안의 내용을 Vue 인스턴스 안의 데이터값으로 설정 할수 있음 머스태쉬 태그나, 디렉티브를 사용 할 때, 그 내부의 값을 꼭 데이터 명으로 해야 하는건 아니다. 자바스크립트 표현식을 사용 할 수도 있습니다. html12&gt; &lt;h1&gt;&#123;&#123; Date() &#125;&#125;&lt;/h1&gt;&gt; ​ 머스태쉬 태그 내부의 값으로 데이터 명 , 자바스크립트 표현식 을 사용 할수 있다. html12/* Date 함수 사용 */&lt;h1&gt; &#123;&#123; Date() &#125;&#125; &lt;/h1&gt; 123456789101112131415161718/* 자바스크립트 표현식 3항 연산자 사용 */ &lt;div id=\"app\"&gt; &lt;img :src=\"smile ? feelsgood : feelsbad\"/&gt; &lt;img v-bind:src=\"smile ? feelsgood : feelsbad\"&gt;&lt;/img&gt; &lt;/div&gt;var app = new Vue(&#123; data: &#123; smile: true, feelsgood: 'https://imgh.us/feelsgood_1.jpg', feelsbad: 'http://imgh.us/feelsbad.jpg' &#125; &#125;); vue.js123456789101112131415161718192021 /* 함수 사용 */ &lt;div id=\"app\"&gt; &lt;h1&gt; &#123;&#123; myfunction() &#125;&#125; &lt;/h1&gt; &lt;/div&gt; var app = new Vue(&#123; el: '#app', data : &#123; funvalue : '함수 값' &#125;, methods: &#123; myfunction: function() &#123; // 인스턴스 내부의 데이터모델에 접근 할 땐, // this 를 사용한다. return this.funvalue &#125; &#125;&#125;); ​ ​ 1. v-text 디렉티브(결과 머스태쉬 태그 와 같다) v-text 라는 디렉티브를 사용 vue.js123&lt;h1&gt; &#123;&#123;number&#125;&#125;&lt;/h1&gt; ||&lt;h1 v-text=\"number\"&gt; &lt;/h1&gt; vue 엘리먼트의 name 변수로 설정 되게 한다 ​ 2. v-html 디렉티브“여기서 렌더링 할 건 html 형식이야” 라는걸 지정하기 위해서 v-html 이라는 디렉티브를 사용합니다. ​ html/vue.js1234567891011 &lt;div id=\"app\"&gt; &lt;h1 v-html=\"nameItaly\"&gt;&lt;/h1&gt; &lt;/div&gt; var app = new Vue(&#123; el: '#app', data: &#123; nameItaly:'&lt;i&gt;기울어짐&lt;/i&gt;' &#125;&#125;); ​ 3. v-show 디렉티브해당 엘리먼트가 보여질지, 보여지지 않을지 true / false 값으로 지정 할 수 있습니다. html/vue.js12345678910 &lt;h1 v-show=\"show\" v-html=\"nameItaly\"&gt;&lt;/h1&gt; var app = new Vue(&#123; el: '#app', data: &#123; nameItaly:'&lt;i&gt;기울어짐&lt;/i&gt;', show:false &#125;&#125;); ​ 4. v-if 디렉티브 변수명 대신에 조건문을 씁니다 (변수명을 입력해도 작동하긴 합니다) 5. v-else 디렉티브v-if 디렉티브를 사용 했을때 그 아래에 v-else 디렉티브를 사용하는 엘리먼트를 넣어주면, 윗부분의 조건문이 만족하지 않을때 보여진답니다. v-if 바로 아래에 v-else 디렉티브를 사용했죠? 이 디렉티브의 값은 따로 설정해주지 않아도 됩니다. 6. v-else-if 디렉티브v-else-if 는 첫번째 조건문의 값이 참이 아닐 때, 다른 조건문을 체크하여 다른 결과물을 보여줄 수 있게 해줍니다. v-else-if 는, 언제나 v-if 디렉티브를 사용하는 엘리먼트의 다음위치에 있어야 합니다. 만약에 v-else 디렉티브가 사용되는 경우엔 그 사이에 위치해있어야 하구요, 이 디렉티브를 여러번 사용해도 됩니다. html12345&lt;div id=\"app\"&gt; &lt;h1 v-if=\"value &gt; 5\"&gt;value 가 5보다 크군요&lt;/h1&gt; &lt;h1 v-else-if=\"value === 5\"&gt;값이 5네요&lt;/h1&gt; &lt;h1 v-else&gt;value 가 5보다 작아요&lt;/h1&gt; &lt;/div&gt; ​ 7. v-pre 디렉티브특정 엘리먼트를 무시하는데에 사용 됩니다. 이걸 사용하므로서, Vue 시스템에서 해당 엘리먼트는 지시문이 없다는걸 인식하게 되어 그 엘리먼트 내부의 자식엘리먼트들을 신경쓰지 않고 그냥 건너뜁니다. html1&lt;h1 v-pre&gt; &#123;&#123; 이건 그대로 렌더링해줘요 &#125;&#125; &lt;/h1&gt; ​ 9. v-once 디렉티브컴포넌트를 초기에 딱 한번만 렌더링합니다. 초기 값은 그대로 고정이 되어있고 현재 값은 그때 그떄 업데이트 되죠? ​ html123&lt;h2 v-once&gt; value초기 값 보여준다 : &#123;&#123; value &#125;&#125;&lt;/h2&gt;&lt;h2&gt;value 현재 값 보여준다: &#123;&#123; value &#125;&#125;&lt;/h2&gt; ​ v-for 디렉티브 HTML 에서 for-loop 을 구현하기 위하여 사용됩니다. 즉, 비슷한 내용을 반복적으로 보여줄 때 사용 html1v-for \"(arr , index ) in arrs\" &#123;&#123; arr.value&#125;&#125; item in items 의 형식으로 작성합니다. items 는 Vue 엘리먼트의 데이터 안에 들어있는 배열 이름 ​ item 은 렌더링 하게 될 때, 각 원소를 가르키는 별침(alias) ​ 123456789101112131415161718 &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in todos &quot;&gt; &#123;&#123; item .text &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; todos: [ &#123; text: &apos;Vue.js 튜토리얼 작성하기&apos; &#125;, &#123; text: &apos;Webpack2 알아보기&apos; &#125;, &#123; text: &apos;사이드 프로젝트 진행하기&apos; &#125; ] &#125; &#125;); index 값 받아오기렌더링을 할 때, 각 원소들을 순서번호(index) 를 가져오려면, 디렉티브 값에 (todo, index) in todos 형식으로 작성을 하면 됩니다. ​ 1234567&lt;div class=\"product\" v-for=\"(item, index) in items\"&gt; &lt;img v-bind:src=\"item.productImage\"&gt; &lt;span v-on:click=\"onDetail(index)\"&gt; &#123;&#123; item.productName &#125;&#125; &lt;/span&gt; &lt;/div&gt; html/vue.js1234567891011121314151617181920 &lt;div id='test'&gt; &lt;div v-for=\"(item,index) in arr\"&gt; index :&#123;&#123;index&#125;&#125;/ value : &lt;button @click=\"fncClick1(index)\"&gt;&#123;&#123;item&#125;&#125;&lt;/button&gt; &lt;/div&gt; new Vue(&#123; el : '#test', data :&#123; arr:['a','b'] &#125;, methods:&#123; fncClick1 : function(index)&#123; return alert (this.arr[index]) &#125; &#125;&#125;) ​ ​ v-bind 디렉티브 , : HTML 태그의 속성 값을 데이터값을 사용해야 한다면 어떻게 해야할까요? ​ HTML 엘리먼트에서 src 값을 Vue 엘리먼트의 데이터 중 image 로 설정하고 싶다 &lt;img v-bind:src=&quot;image&quot;/&gt; 와 같은 형식으로 하면 됩니다. v-bind: 뒤에 속성의 이름 / 편의를 위해서, v-bind 를 생략 할 수 있습니다. 그냥 콜론 뒤에 속성의 이름만 넣어주면 돼요. ​ html/vue.js1234567891011121314&lt;div id=\"app\"&gt; &lt;img v-bind:src=\"addr\"/&gt; &lt;img :src=\"addr\"/&gt; &lt;/div&gt; var app = new Vue(&#123; el: '#app', data: &#123; addr: 'https://imgh.us/feelsgood_1.jpg' &#125; &#125;); ​ v-model , 양 방향 데이터 바인딩(폼 관련 태크만 사용가능 ) 뷰 ⇄ 데이터 형태로 바인딩하여 데이터가 양 방향 으로 흐르게 해주는 것 입니다. 데이터에 있는 값이 뷰에 나타나고, 이 뷰의 값이 바뀌면 데이터의 값도 바뀌는것이죠. v-model 을 설정 함으로서 , 이 input 엘리먼트의 값이 업데이트 되면 자동으로 바뀐다 이렇게 폼에 관련된 태그에만 사용 될 수 있습니다: &lt;input&gt; &lt;select&gt; &lt;textarea&gt; ​ html/vue.js123456789101112131415161718 &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123; feels &#125;&#125;&lt;/h1&gt; &lt;h3&gt;&lt;input type=\"text\" v-model=\"feels\"/&gt;개구리&lt;/h3&gt; &lt;img v-bind:src=\"feels=='웃어요' ? feelsgood : feelsbad\"/&gt; &lt;/div&gt; // 새로운 뷰를 정의합니다var app = new Vue(&#123; el: '#app', // 어떤 엘리먼트에 적용을 할 지 정합니다 // data 는 해당 뷰에서 사용할 정보를 지닙니다 data: &#123; feels:'울어요', feelsgood: 'https://imgh.us/feelsgood_1.jpg', feelsbad: 'http://imgh.us/feelsbad.jpg' &#125; &#125;); https://kr.vuejs.org/v2/guide/forms.html v- on 디렉티브 ,이벤트 핸들링 @ v-on 디렉티브를 사용하여 DOM 이벤트를 듣고 트리거 될 때 JavaScript를 실행할 수 있습니다. 메소드(함수) 자바스트립트 표현식 … ​ 많은 이벤트 핸들러의 로직은 더 복잡할 것이므로, JavaScript를 v-on 속성 값으로 보관하는 것은 간단하지 않습니다. 이 때문에 v-on이 호출하고자 하는 메소드의 이름을 받는 이유입니다. ​ 메소드를 준비할때는, 우리가 뷰 인스턴스에서 사용 할 데이터들을 data 안에 넣은 것 처럼, 함수들을 만들어서 뷰 인스턴스의 methods 안에 넣으면 됩니다. ​ v-on: 이벤트이름 = “메소드이름” v-on: 을 @ 로 대체 가능 ​ html/vue.js1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;h1&gt;카운터: &#123;&#123; number &#125;&#125;&lt;/h1&gt; &lt;button v-on:click=\"increment\"&gt;증가&lt;/button&gt; &lt;button @click=\"decrement\"&gt;감소&lt;/button&gt;&lt;/div&gt;var app = new Vue(&#123; el: '#app', data: &#123; number: 0 &#125;, // app 뷰 인스턴스를 위한 메소드들 methods: &#123; increment: function() &#123; // 인스턴스 내부의 데이터모델에 접근 할 땐, // this 를 사용한다 this.number++; &#125;, decrement: function() &#123; this.number--; &#125; &#125;&#125;); html/vue.js1234567891011&lt;div id=\"example-1\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;Add 1&lt;/button&gt; &lt;p&gt;위 버튼을 클릭한 횟수는 &#123;&#123; counter &#125;&#125; 번 입니다.&lt;/p&gt;&lt;/div&gt;var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0 &#125;&#125;) 메소드 이름을 직접 바인딩 하는 대신 인라인 JavaScript 구문에 메소드를 사용할 수도 있습니다. validation http://fronteer.kr/bbs/view/338 https://m.dotdev.co/form-validation-using-vue-js-2-35abd6b18c5d https://monterail.github.io/vuelidate/#sub-basic-form https://www.npmjs.com/package/vue-form-validator https://blog.midkemia.fr/form-validation-with-vue-js/ 프리마커 FreeMarker 템플릿은 JSP + EL + JSTL 조합과 상당히 유사하면서 훨씬 간결한 느낌을 준다. ​ #list형식 : &lt;#list 배열객체 as 로컬엘리어스명&gt;&lt;/#list&gt; 123&lt;#list LIST as item&gt;번호 : $&#123;item_index+1&#125; | 이름 : $&#123;item.name&#125; | 아이디 : $&#123;item.id&#125;&lt;/#list&gt; ${list?size}&lt;!-- 리스트 사이즈 구하기 --&gt; &lt;`#assign i = list?size&gt;` ${list[i].amount} &lt;!-- 리스트의 순번에 해당 값 구하기 --&gt; ​ #if형식 : &lt;#if 조건식&gt;&lt;/#if&gt; string 비교1&lt;#if ENTITY.usergrade == &quot;A&quot; &gt;......&lt;/#if&gt; number 비교1&lt;#if ENTITY.userclass?number == 3&gt;.....&lt;/#if&gt; boolean 비교1&lt;#if ENTITY.isAuth()&gt;.....&lt;/#if&gt; #breakLoop문을 중단하고 다음 스크립트로 넘어가려고 할때 사용되는 지시자이다. 형식 : &lt;#break&gt; 루프문을 실행하는 중 5번째에서 escape 하는 예123&lt;#list LIST as item&gt;&lt;#if item_index &amp;gt; 3&gt;&lt;#break&gt;&lt;/#if&gt;&lt;/#list&gt; #assign프리마커내에서 사용자 정의 로컬변수가 필요할 때 사용하는 지시자이다. 형식 : &lt;#assign 로컬변수명 = 초기화값&gt; &lt;#assign CHECK = item_index&gt;&lt;#assign cnt = 0&gt; &lt;#if cnt != 0&gt; &lt;/#if&gt; &lt;#assign cnt = cnt + 1&gt; 6. [OSF: x…y]문자열의 일정 범위를 자를때 사용하는 함수 ${item.name[OSF:1..5]}​ ?has_content리스트형 오브젝트가 null이 아니고 최소 1개 이상의 컨텐츠를 가지고 있는지 체크하는 함수로써 exists와 &amp; size&gt;0 두가지 체크를 동시에 해주는 함수이다. 형식 : 리스트오브젝트?has_content &lt;#if LIST?has_content&gt;.....&lt;/#if&gt;​ ?existsNULL체크 함수. if_exists는 &lt;#if 지시자 없이도 사용할 수 있게 해주는 표현식이다. 오브젝트?exists &lt;#if ENTITY.username?exists&gt;${ENTITY.username?substring(0, 5)}&lt;/#if&gt;&lt;#if LIST?exists &amp;&amp; LIST?size &amp;gt; 0&gt;.....&lt;/#if&gt;${ENTITY.username?if_exists}​ ?defaultNULL값을 대체해주는 함수 오브젝트?default(디폴트값) ${item.userclass?default(&quot;99&quot;)}${item.age?default(20)}​ ?string문자열로 형변환하는 함수 오브젝트?string &lt;#if item.age?string == &quot;29&quot;&gt;.....&lt;/#if&gt;${item.regdate?string(&quot;yyyy/MM/dd HH:mm&quot;)}숫자를 통화표시로 나타내는 예12&lt;#assign MONEY = 1234567&gt;$&#123;MONEY?string(&quot;,##0&quot;)&#125; ?number숫자로 형변환하는 함수 오브젝트?number &lt;#if item.userclass?number &amp;gt; 3&gt;.....&lt;/#if&gt;${LIST_POINTS[OSF:item.gid?number].entityname?default(&quot;&quot;)}​ ?js_string문자열을 자바스크립트에 유효하도록 필터링해주는 함수.문자열내에 싱글쿼테이션(‘)등이 포함되어 스크립트에 오류가 나는것을 방지하기 위하여 사용되는 함수이다.화면상에는 HTML 태그로 취급된다. 오브젝트?js_string #### 1문자열 &lt;img src=&apos;/image/enterprise.gif&apos;&gt;을 js_string으로 처리했을때 소스보기를 하면 &lt;img src=\\&apos;/image/enterprise.gif\\&apos;&gt;으로 출력된다. &lt;a href=&quot;javascript:getName(&#39;${item.homeurl?js_string}&#39;);&quot;&gt;​ ?html문자열을 HTML Symbolic Entity로 필터링해주는 함수. 문자열내의 HTML태그등을 깨뜨려 화면상으로 출력되도록 할때 사용하는 함수이다. 화면상에 HTML태그가 아닌 일반 문자열로 취급된다. (예를 들어 html태그를 보여주고 싶은 경우) 오브젝트?html #### 12문자열 &lt;img src=&apos;/image/enterprise.gif&apos;&gt;을 html로 처리하면 화면상에 &lt;img src=&apos;/image/enterprise.gif&apos;&gt; 로 출력되고 소스보기를 하면 &amp;lt;img src=&apos;/image/enterprise.gif&apos;&amp;gt;로 출력된다. ​ ?index_of특정 문자(열)가 시작되는 위치를 정수형으로 반환한다. 오브젝트?index_of(특정문자) &quot;abcde&quot;?index_of(&quot;c&quot;) 는 2를 반환한다.?replace문자열의 일부를 주어진 문자로 대체하는 함수 오브젝트?replace(찾을문자열, 대체할문자열) ${item.content?replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;)}​ item_has_next리스트 객체의 다음 컨텐츠가 존재하는지(EOF) 체크하는 함수 리스트엘리어스이름_has_next 이름과 이름사이에 , 를 찍어주되 마지막은 찍지 않는 경우의 예123&lt;#list LIST as item&gt;$&#123;item.name?default(&quot;&quot;)&#125;&lt;#if item_has_next&gt;,&lt;/#if&gt;&lt;/#list&gt;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"vue.js 파일업로드","slug":"v-model file","date":"2018-02-27T04:49:24.995Z","updated":"2018-02-27T04:49:24.995Z","comments":true,"path":"2018/02/27/v-model file/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/v-model file/","excerpt":"","text":"input file v-modelv-model 예상됨: 컴포넌트 폼 인풋 엘리먼트 또는 출력 값에 따라 다릅니다. 제한사항: &lt;input&gt; &lt;select&gt; &lt;textarea&gt; components 수식어: .lazy - input대신 change 이벤트를 듣습니다. .number - 문자열을 숫자로 변경합니다. .trim - 입력에 대한 trim 을 합니다. file 기존 v-model 사용 불가 방법 ftl html123456789101112131415161718&lt;template&gt; &lt;label class=\"file-select\"&gt; &lt;div class=\"select-button\"&gt; &lt;span v-if=\"value\"&gt;Selected File name : &#123;&#123;value.name&#125;&#125; size: &#123;&#123;value.size&#125;&#125; type: &#123;&#123;value.type&#125;&#125; relativePath : &#123;&#123; value.webkitRelativePath &#125;&#125; &lt;/span&gt; &lt;span v-else&gt;Select File&lt;/span&gt; &lt;/div&gt; &lt;input type=\"file\" @change=\"fileUpload($event)\"&gt; &lt;/label&gt;&lt;/template&gt; ​ vue js vue.js123456789101112131415161718192021data: &#123; value: File &#125;, fileUpload(e) &#123; const config = &#123; headers: &#123; 'Content-Type': 'multipart/form-data' &#125; &#125;; this.value=e.target.files[0]; var data = new FormData(); data.append('uploadFile', this.value); data.append('projectCode', projectCode); alert(projectCode); axios.put( '/api/v1/files/' + projectCode,data,config) .then(res =&gt; &#123; /*this.projectResults = res.data;*/ &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); &#125; ​ @Controller 해당 클래스가 Controller임을 나타내기 위한 어노테이션 @RequestMapping 요청에 대해 어떤 Controller, 어떤 메소드가 처리할지를 맵핑하기 위한 어노테이션 @RequestParam Controller 메소드의 파라미터와 웹요청 파라미터와 맵핑하기 위한 어노테이션 @ModelAttribute Controller 메소드의 파라미터나 리턴값을 Model 객체와 바인딩하기 위한 어노테이션 @SessionAttributes Model 객체를 세션에 저장하고 사용하기 위한 어노테이션 @RequestPart Multipart 요청의 경우, 웹요청 파라미터와 맵핑가능한 어노테이션(egov 3.0, Spring 3.1.x부터 추가) @CommandMap Controller메소드의 파라미터를 Map형태로 받을 때 웹요청 파라미터와 맵핑하기 위한 어노테이션(egov 3.0부터 추가) @ControllerAdvice Controller를 보조하는 어노테이션으로 Controller에서 쓰이는 공통기능들을 모듈화하여 전역으로 쓰기 위한 어노테이션(egov 3.0, Spring 3.2.X부터 추가","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"file","slug":"file","permalink":"http://apexsoft.github.io/tags/file/"}]},{"title":"query mehtod","slug":"query mehtod만들기","date":"2018-02-27T04:49:24.995Z","updated":"2018-02-27T04:49:24.995Z","comments":true,"path":"2018/02/27/query mehtod만들기/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/query mehtod만들기/","excerpt":"","text":"Repository 제공 기능 method 이름 기능 save() 레코드 저장 (insert, update) findOne() primary key로 레코드 한건 찾기 findAll() 전체 레코드 불러오기. 정렬(sort), 페이징(pageable) 가능 count() 레코드 갯수 delete() 레코드 삭제 query mehtod 이름 생성 전략 아래 이름으로 시작하는 메서드는 query method 임을 스프링에게 알린다. mthod 이름 설명 findBy로 시작 쿼리를 요청하는 메서임을 알림 countBy로 시작 쿼리 결과 레코드 수 요청하는 메서드 임을 알림 필드 쿼리 표현식** 위의 findBy… 에 이어 아래와 같이 해당 repository 도메인의 필드이름을 입력하면 검색 쿼리를 실행한 결과를 전달한다. SQL의 where 절을 메서드이름을 통해서 전달한다고 보면 된다. 메서드의 반환형이 도메인 객체이면 하나의 결과만 전달하고 반환형이 List 이면 쿼리에 해당하는 모든 객체를 전달한다. query method에 포함할 수 있는 키워드 메서드이름 키워드 샘플 설명 And findByEmailAndUserId(String email, String userId) 여러필드를 and 로 검색 Or findByEmailOrUserId(String email, String userId) 여러필드를 or 로 검색 Between findByCreatedAtBetween(Date fromDate, Date toDate) 필드의 두 값 사이에 있는 항목 검색 LessThan findByAgeGraterThanEqual(int age) 작은 항목 검색 GreaterThanEqual findByAgeGraterThanEqual(int age) 크거나 같은 항목 검색 Like findByNameLike(String name) like 검색 IsNull findByJobIsNull() null 인 항목 검색 In findByJob(String … jobs) 여러 값중에 하나인 항목 검색 OrderBy findByEmailOrderByNameAsc(String email) 검색 결과를 정렬하여 전달 생각할 수 있는 거의 모든 연산자가 가능하다. 예를들어 List findFirst10ByNameAndAgeGreaterThanEqualOrderByBirthday(String name, int age); 페이징spring data jpa의 web 프로젝트 지원 query method의 입력 변수로 Pageable을 추가하면 Page 타입을 반환형으로 사용할 수 있다. Pageable 객체를 통해 페이징과 정렬을 위한 파라미터를 전달한다. 아래와 같이 controller에서 부터 Pageable을 전달받는다. query parameter 명 설명 page 몇번째 페이지 인지를 전달 size 한 페이지에 몇개의 항목을 보여줄것인지 전달 sort 정렬정보를 전달. 정렬정보는 필드이름,정렬방향 의 포맷으로 전달한다. 여러 필드로 순차적으로 정렬도 가능하다.예: sort=createdAt,desc&amp;sort=userId,asc 아래는 위 controller를 통해 http 요청으로 페이징과 정렬된 데이터를 전달 받는 URI 샘플 GET /users?page=1&amp;size=10&amp;sort=createdAt,desc&amp;sort=userId,asc 위와 같이 웹 페이지 개발에 필수적인 정렬과 페이징정보를 접속 url에서 부터 Repository 객체가지 바로 전달이 가능하다. 123PageRequest pageRequest = new PageRequest(page, 10); Page&lt;Project&gt; result = projectRepository.findAll(pageRequest);","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"lombok","slug":"lombok","date":"2018-02-27T04:49:24.979Z","updated":"2018-02-27T04:49:24.979Z","comments":true,"path":"2018/02/27/lombok/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/lombok/","excerpt":"","text":"@Builder 필수 인자들을 생성자(또는 정적 팩터리 메서드)에 전달하여 빌더 객체를 만들고, 선택적 인자들을 추가한 뒤, 마지막에 build()를 호출하여 Immutable 객체를 만드는 방법. Class에 대한 복잡한 Builder API들을 자동으로 생성해 준다. Class 뿐만 아니라, 생성자, 메서드에도 사용할 수 있다. 추가적으로 @Singular Annotation도 제공한다. @Singular는 @ Builder Annotation을 사용한 Class/Method/Constructor에서 Collection 객체에만 사용할 수 있다. Collection 변수에 @Singular을 설정하면 setter 함수 대신 두 종류의 Adder 함수와 Clear함수를 생성해 준다. 빌더 패턴을 적용한 객체 생성 메소드/클래스를 만들어준다. builderClassName 파라미터로 nested 빌더 클래스의 이름을 (클래스명Builder가 기본), builderMethodName으로 빌더 클래스를 반환하는 static 메소드의 이름을 (builder()가 기본), buildMethodName으로 객체를 반환하는 빌드 메소드의 이름 (build()가 기본)을 설정할 수 있다. 필드에 **@Builder.Default** 어노테이션을 붙여 기본 값을 설정할 수 있고, @Singular 어노테이션을 붙여 빈 collection을 자동으로 만들 수 있다. @Singluar 어노테이션은 파라미터로 builder에서 값을 추가할 때 사용되는 메소드의 이름을 입력받는다. 또, @Singular 어노테이션으로 만들어진 collection은 수정할 수 없다. 데이터 일관성, 객체불변성 등을 만족시킨다. 또한 코드 가독성 역시 올라간다. ​ java12345678@Builder@ToStringpublic static class LombokClass &#123; private String name; private int value; @Builder.Default private int value2 = 999; // 기본 값 설정 @Singular(\"addVal\") private List&lt;Integer&gt; values;&#125; java12345678910111213val lombokClass = LombokClass.builder() .name(\"Hello\") .value(500) .addVal(100) .addVal(200) .addVal(300) .build();System.out.println(lombokClass); // LombokClass(name=Hello, value=500, value2=999, values=[100, 200, 300])val val0 = lombokClass.values.get(0);System.out.println(val0); // 100 자바 빈즈 패턴자바빈즈 패턴은 코드량이 늘어나는 단점이 존재한다. 하지만 그것보다 더욱 문제가 되는 것은 객체 일관성이 깨진다. 객체 일관성이 깨진다는 것이란, 한번 객체를 생성할때, 그 객체가 변할 여지가 존재한다는 뜻이다. 즉, set메서드는 언제 어디서든 사용 할 수 있다는 장점이 있지만, 객체의 불변성이 깨진다. 스레드 작업에 큰 단점이 될 수 있을 뿐더러, 컴파일러 오류는 아니지만, 우리가 원하지 않는 결과물이 만들어 질 수 있는것이다. 점층적 생성자패턴과 자바빈즈 패턴의 장점을 섞은것이 빌더패턴이다. 정보들은 자바 빈즈 패턴처럼 받되, 데이터 일관성을 위해 정보들을 다 받은후에 객체생성을 해준다. java1234PersonInfo personInfo = new PersonInfo( );personInfo.setName(\"Mommoo\"); // 이름을 넣는 메서드personInfo.setAge(12); // 나이를 넣는 메서드personInfo.setPhonNumber(119); // 전화번호를 넣는 메서드 사용 에러console12345678org.springframework.web.util.NestedServletException:Request processing failed; nested exception is org.springframework.orm.jpa.JpaSystemException:No default constructor for entity: : kr.co.apexsoft.GCSVC.domain.FileUpLoad;nested exception is org.hibernate.InstantiationException:No default constructor for entity: :kr.co.apexsoft.GCSVC.domain.FileUpLoad 해결java12@AllArgsConstructor@RequiredArgsConstructor XXXXArgsConstructor위의 어노테이션은 생성자를 생성해주는 어노테이션이다. 첫 번째는 디폴트 생성자를 생성해주는 @NoArgsConstructor 두 번째는 모든 필드의 생성자를 생성해주는 @AllArgsConstructor 마지막으로 필수 생성자를 생성해주는 @RequiredArgsConstructor 가 있다. 속성 staticName : 위에서 @Data 어노테이션의 staticConstructor 와 동일하다. static한 생성자를 만들어 준다. access : 접근제한을 할 수 있다. PUBLIC, MODULE, PROTECTED, PACKAGE, PRIVATE 등으로 설정가능 하다. onConstructor : 생성자에 어노테이션을 작성할 수 있다.공통적인 속성으로는 위와 같이 3가지가 존재한다. java12345@RequiredArgsConstructor(staticName = \"of\", onConstructor = @__(@Inject))public class ConstructorObject &#123; private final Long id; private final String name;&#125; 만약 위와 같은 어노테이션을 작성할 경우에는 다음과 같은 코드가 나올 것이라고 예상해본다. java12345678910111213class ConstructorObjectNot &#123; private final Long id; private final String name; @Inject private ConstructorObjectNot(Long id, String name) &#123; this.id = id; this.name = name; &#125; public static ConstructorObjectNot of(Long id, String name) &#123; return new ConstructorObjectNot(id, name); &#125;&#125; staticName가 존재해 access는 별루 의미가 없어 사용하지 않았다. @Datalombok을 사용한다면 제일 많이 사용하는 어노테이션이다. 이 어노테이션은 다재다능한 기능이다. 사용하는 사람은 알겠지만 getter, setter, toString, hasCode, equals, constructor 등 많은 부분을 자동으로 생성해준다.각각 부분적으로는 밑에서 설명하도록 하겠다.@Data 어노테이션에는 속성이 한개 있는데 staticConstructor 라는 속성이다. 말그대로 static한 생성자? 를 만들어 주는 것이다. java12345@Data(staticConstructor = \"of\")public class DataObject &#123; private final Long id; private String name;&#125; 위와 같이 선언한다면 다음과 같이 사용가능하다. 1DataObject dataObject = DataObject.of(1L); id 경우에는 final이라 필수 생성자에 포함되어 있다. 만일 위와 같이 사용한다면 new로 생성할 수 없다. 1DataObject dataObject2 = new DataObject(); // compile error 위와 같이 new 를 이용해 생성할 시에는 컴파일 에러가 발생한다. 위의 여러 메서드를 제외하고 한개의 메서드가 더 생성이 되는데 그 메서드는 canEqual이라는 메서드이다. 해당 메서드의 역할은 instanceof로 타입정도만 체크 한다. 하지만 메서드의 접근제한자는 protected 이다. 필자도 사용할 일이 없었다. @Getter와 @Setter어노테이션 이름 그대로 getter와 setter를 생성해준다. 클래스 레벨에도 사용가능하며 필드 레벨에도 사용가능하다.공통 속성으로는 value, onMethod 속성이 존재한다. value의 경우에는 접근 제한을 할 수 있으며 onMethod 메서드의 어노테이션을 작성할 수 있다. java12345public class GetSetObject &#123; @Getter(value = AccessLevel.PACKAGE, onMethod = @__(&#123;@NonNull, @Id&#125;)) private Long id;&#125; 만약 위와 같은 코드를 작성하였을 경우에는 다음과 같은 코드가 작성 될 것이다. java123456789class GetSetObjectOnMethod &#123; private Long id; @Id @NonNull Long getId() &#123; return id; &#125;&#125; 물론 @Setter 어노테이션에도 onMethod를 사용할 수 있다. java1@Setter(onMethod = @__(&#123;@NotNull&#125;)) 그리고 @Getter, @Setter 각각이 다른 속성들을 한개씩 가지고 있는데. @Getter인 경우에는 lazy 속성이고 @Setter의 경우에는 onParam 이라는 속성이다.@Getter 의 lazy 속성은 속성명 그대로 필드의 값은 지연시킨다는 것이다. java123456@Getter(value = AccessLevel.PUBLIC, lazy = true)private final String name = expensive();private String expensive() &#123; return \"wonwoo\";&#125; lazy가 true일때는 무조건 final 필드어야만 한다. lazy 속성이 false 일 경우에는 객체를 생성할 때 expensive() 메서드를 호출하지만 속성이 true일 경우에는 getName() 메서드를 호출할 때 expensive() 메서드를 호출 한다. 다음은 @Setter의 onParam 속성이다. 이 속성은 파라미터의 어노테이션을 작성할 수 있는 속성이다. java12@Setter(onParam = @__(@NotNull))private Long id; 만약 다음과 같은 코드가 있을 경우에는 아래와 같은 코드가 작성될 것이라고 판단된다. java1234567class GetSetObjectOnParam &#123; private Long id; public void setId(@NotNull Long id) &#123; this.id = id; &#125;&#125; 아주 간단한 코드이다. (물론 만든 사람은 아니겠지만..) IDEA에서는 onParam과 onMethod에 @Column 어노테이션의 속성을 넣으면 잘 동작하지 않는다. onParam 은 파라미터에 적용되니 @Column 자체가 들어 갈 수 없으니 그렇다 쳐도 onMethod는 왜안되는지.. 플러그인 문제인듯 싶다. @EqualsAndHashCode 와 @ToString@EqualsAndHashCode 어노테이션은 이름 그대로 hashcode와 equals를 생성해주는 어노테이션이고, @ToString도 마찬가지로 toString() 메서드를 생성해주는 어노테이션이다.공통 속성으로는 4가지 있는데 exclude, of, callSuper, doNotUseGetters가 존재 한다. exclude는 제외시킬 변수명을 작성하면 되고 of는 포함시킬 변수명을 작성하면 된다. callSuper 속성은 상위 클래스의 호출 여부를 묻는 속성이다. 마지막으로 doNotUseGetters의 속성은 getter 사용여부 인듯 하나 제대로 동작하지는 모르겠다. java123456@EqualsAndHashCode(of = \"id\")@ToString(exclude = \"name\")public class HashCodeAndEqualsObject &#123; private Long id; private String name;&#125; 만일 위와 같이 작성하였다면 hasCode, equals, toString 모두 id만 존재하게 된다.각각의 속성으로는 @EqualsAndHashCode 는 onParam, @ToString 는 includeFieldNames 속성이 존재한다. onParam 은 equals에 작성되며 위의 onParam 속성과 동일하므로 생략한다. includeFieldNames는 toString의 필드 명을 출력할지 하지 않을지의 여부이다. 만일 위의 코드로 includeFieldNames을 false로 한다면 다음과 같이 출력 된다. 1HashCodeAndEqualsObject(null) 참고로 canEqual 메서드도 @EqualsAndHashCode 메서드에 포함되어 있다. @val 와 @var스칼라, 코틀린 이외에 다른 언어들의 키워드와 동일하게 타입추론을 한다. java12345678910public class ValAndVarTests &#123; @Test public void valVarTest() &#123; val arrVal = Arrays.asList(1, 2, 3, 4, 5); arrVal = new ArrayList&lt;&gt;(); // compile error var arrVar = Arrays.asList(1, 2, 3, 4, 5); arrVar = new ArrayList&lt;&gt;(); &#125;&#125; val 경우에는 final 키워드가 생성된다. 그래서 다시 어사인을 할 경우에 컴파일 에러가 발생한다. 마찬가지로 var는 final이 존재 하지 않으므로 다시 어사인이 가능하다. 위의 코드를 다시 만들어 보면 다음과 같을 것으로 예상된다. java12345final List&lt;Integer&gt; arrVal1 = Arrays.asList(1, 2, 3, 4, 5);arrVal1 = new ArrayList&lt;&gt;();List&lt;Integer&gt; arrVar1 = Arrays.asList(1, 2, 3, 4, 5);arrVar1 = new ArrayList&lt;&gt;(); 위와 동일한 바이트코드가 나올 것으로 예상해본다. @UtilityClass유틸리티 클래스에 적용하면 되는 어노테이션이다. 만약 이 어노테이션을 작성하면 기본생성자가 private 생성되며 만약 리플렉션 혹은 내부에서 생성자를 호출할 경우에는 UnsupportedOperationException이 발생한다. java123456@UtilityClasspublic class UtilityClassObject &#123; public static String name() &#123; return \"wonwoo;\"; &#125;&#125; 만약 위의 코드를 다시 작성해보면 다음과 같다. 12345678class UtilityClassObjectNot &#123; private UtilityClassObjectNot() &#123; throw new UnsupportedOperationException(\"This is a utility class and cannot be instantiated\"); &#125; public static String name() &#123; return \"wonwoo;\"; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"}]},{"title":"mixin","slug":"mixin","date":"2018-02-27T04:49:24.979Z","updated":"2018-02-27T04:49:24.979Z","comments":true,"path":"2018/02/27/mixin/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/mixin/","excerpt":"","text":"MixIn vue 구성요소에 재사용 가능한 기능을 넣는 방법 재사용 가능한 기능은 기존 기능과 병합 캡슐화 및 공통된 기능을 분리시켜 코드 재사용성을 높혀준다. 오버라이딩 기능도 사용할 수 있어 커스텀 및 확장에 용이하다. ​ 얼핏 보면 extends와 유사하게 보일 수가 있다. extends: 유사한 기능의 컴포넌트들을 추상화 하여 상위 컴포넌트를 만들고 차이가 있는 기능들을 하위 컴포넌트에 구현한다. mixins: 서로 다른 기능의 컴포넌트에 동일한 기능을 배포하는 방법으로 예를 들면 로깅 기능을 aspect 단위로 추가하는 것을 들 수 있다. 선언 및 사용1.vue.js123456789101112var mixin1 = &#123;...&#125;var mixin2 =&#123; ...&#125;new Vue(&#123; el: '#app', mixins: [mixin1,mixin2]&#125;) 2. 전역 MixIn 생성되는 모든 vue 에 영향을 주기때문에 사용자 지정 옵션을 줘서 사용한다 사용자 지정 옵션 vue.js123456789101112131415Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.mixInOption1 if (myOption) &#123; console.log(\"전역mixIn실행:\"+myOption) &#125; &#125;&#125;)new Vue(&#123; el: '#app', mixInOption1: 'hello!'&#125;)//Console Logs&gt; 전역mixIn실행 hello! vue 인스턴스 , key :mixInOption1 value: &#39;hello!&#39; Global mixin , this.$options. key 조건 으로 특징 mixin객체 안에 created(), methods, data,mounted… 구성 옵션 포함 가능 vue.js12345678910111213var mixin = &#123; data: &#123; name: '이름' &#125;, created: function () &#123; console.log('mixin hook called') &#125;, methods: &#123; mixinFnc() &#123; console.log('html 직접접근 '+this.name); &#125; &#125;&#125; html에서 직접 접근 가능 vue.js1234567891011&lt;div id=\"app\"&gt; &lt;button @click.prevent=\"mixinFnc\"&gt;click&lt;/button&gt;&lt;/div&gt;var mixin = &#123; methods: &#123; mixinFnc() &#123; console.log('mixinFnc 함수'); &#125; &#125;&#125; vue 컴포넌트 안에서 mixin안 data 도 접근 가능 ex) this.name veu.js123456789101112131415var mixin = &#123; data: &#123; name: '이름' &#125;&#125;new Vue(&#123; el: '#app', mixins: [mixin,mixin2], created: function () &#123; console.log('component hook called:' +this.name) &#125;&#125;)//Console Logs&gt; component hook called: 이름 중첩 옵션이 포함되어 있으면 mixin 먼저 호출된 이후, vue 컴포넌트 호출 vue.js1234567891011121314151617const myMixin = &#123; created()&#123; console.log(\"mixin hook called) &#125;&#125;new Vue(&#123; el: '#root', mixins:[myMixin], created()&#123; console.log(\"component hook called\") &#125;&#125;)//Console Logs&gt; mixin hook called&gt; component hook called 하지만, methods, components, directives와 같은 객체값 요구하는 옵션에 충돌하는 키가 있을 경우 (같은 메소드명) 컴포넌트 옵션만 호출됨. vue.js1234567891011121314151617181920const myMixin = &#123;methods:&#123; name()&#123; console.log(\"myMixin\") &#125; &#125;&#125;new Vue(&#123; el:\"#root\", mixins:[myMixin], methods:&#123; name()&#123; console.log(\"Christian John\") &#125; &#125;&#125;)//Console Logs&gt; Christian John Global function 사용하고 싶은경우1. .js파일을 만든다 mixin12345678910111213var mixin = &#123; data: &#123; name: '이름' &#125;, created: function () &#123; console.log('mixin hook called') &#125;, methods: &#123; mixinFnc() &#123; console.log('html 직접접근 '+this.name); &#125; &#125;&#125; 사용을 원하는 곳에서 .js파일을 넣고 , mixIn 선언 한다 vue.js1234new Vue(&#123; el:\"#root\", mixins:[myMixin]&#125;) 2. 전역 MixIn","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"Transaction","slug":"@Transactional","date":"2018-02-27T04:49:24.963Z","updated":"2018-02-27T04:49:24.963Z","comments":true,"path":"2018/02/27/@Transactional/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/@Transactional/","excerpt":"","text":"@Transactional 정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크가 끊기거나 서버에 장애가 생겨서 작업을 완료할 수 없다면, 그 때까지 변경된 사용자의 레벨은 그대로 둘까요? 아니면 모두 초기상태로 되돌려 놓아야 할까요? 이 문제에 대한 답은,‘작업 중간에 문제가 발생해서 작업이 중단된다면,그 때까지 진행된 변경 작업도 모두 취소시켜야 한다.’이다. 트랜잭션(Transaction) 더 이상 나눌 수 없는 단위 작업을 말한다.(= 원자성) 따라서 중간에 예외가 발생해서 작업을 완료할 수 없다면, 아예 작업이 시작되지 않은 것처럼 초기 상태로 되돌려놓아야 한다. 이것이 바로 트랜잭션이다 DB의 트랜잭션 DB 는 그 자체로 완벽한 트랜잭션을 지원한다. 하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있다. ❑ 트랜잭션 롤백(Transaction rollback) 여러 개의 SQL이 하나의 트랜잭션이 된 경우에, 중간 작업에서 문제가 생겼을 때 그 전까지 완료한 작업들까지도 모두 취소시키는 것. ❑ 트랜잭션 커밋(Transaction commit) 여러 개의 SQL이 하나의 트랜잭션이 된 경우에, 모든 SQL 수행 작업이 다 성공적으로 마무리됐다고 DB에 알려줘서 작업을 확정시키는 것. ❑ 트랜잭션의 경계설정(Transaction demarcation) 트랜잭션의 시작 지점과 종료 지점을 정해주는 것. 종료 시점은 commit 또는 roll back을 하는 시점이 된다. 트랜잭션의 경계는 하나의 connection이 만들어지고 닫히는 범위 안에 존재한다. ❑ 로컬 트랜잭션(Local transaction) 하나의 DB 커넥션 안에서 만들어지는 트랜잭션. 적용 범위 인터페이스를 구현한 클래스로 선언된 빈은 인터페이스 메소드에 한해서 트랜잭션이 적용됨 인터페이스에 붙은 @Transactional 선언은 인터페이스 내의 모든 메소드에 적용됨 동시에 메소드 레벨에도 @Transactional을 지정할 수 있다. 메소드 선언 &gt; 인터페이스 선언 클래스의 @Transactional &gt; 인터페이스의 @Transactional ​ 적용 우선 순위 @Transactional을 적용하는 우선순위는클래스의 메소드 &gt; 클래스&gt; 인터페이스의 메소드 &gt; 인터페이스 메소드에 @Transactional이 있으면 클래스 레벨의 @Transactional 선언보다 우선해서 적용된다. 클래스에 @Transactional 을 부여했을 때 트랜잭션이 적용되는 메소드는 프록시 방식과 인터페이스의 여부에 따라서 조금 달라진다. 클래스의 @Transactional 은 인터페이스의 @Transactional 선언보다 우선한다. @Transactional(readOnly = true) 트랜잭션이 읽기 전용이다. 내부에서 write가 일어나면 exception이 발생한다. (내부적으로는 DB를 바라볼 때 Slave DB를 바라본다.) @Transactional(readOnly = false) 트랜잭션이 읽기/쓰기가 모두 가능하다. 내부적으로는 DB를 바라볼 때 Master DB를 바라본다. ​ 따라서 코딩할 때, 전체 클래스를 readOnly = true 로 잡아두고 write가 필요한 매서드 안에서만 readOnly = false 를 줘야한다.","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"컴포넌트와 플러그인","slug":"Component&plugin","date":"2018-02-27T04:40:53.284Z","updated":"2018-02-27T05:15:40.112Z","comments":true,"path":"2018/02/27/Component&plugin/","link":"","permalink":"http://apexsoft.github.io/2018/02/27/Component&plugin/","excerpt":"","text":"Component 기본 html 엘리먼트를 확장하여 재사용 가능한 코드 단위로 묶음 컴포넌트를 지역/전역적으로 사용할 수 있는 소스코드가 들어있음 일반적인 외부 컴포넌트들이 사용가능한 소스코드를 제공하는 것으로 보임 외부 컴포넌트의 경우, webpack을 사용해 bundle하여 js파일만 제공하는 컴포넌트가 많음 외부 컴포넌트 사용방법 npm install 및 cdn import (npm install인 경우) javascript1import apexCalendar from 'vue-apex-calendar' 지역 javascript123new Vue(&#123; components: &#123;'apex-calendar': apexCalendar&#125;&#125;) 전역 javascript1Vue.component('apex-calendar', apexCalendar) Plugin 일반적으로 여러 컴포넌트들을 묶어서 기능을 만든 경우, 하나의 플러그인 형태로 배포 배포하는 쪽 (install할 때) 에서 지역/전역 선택하여 배포 전역 배포 및 사용 install javascript123456function install(Vue)&#123; Vue.component(\"vuetable\", Vuetable); Vue.component(\"vuetable-pagination\", VueTablePagination); Vue.component(\"vuetable-pagination-dropdown\", VueTablePaginationDropDown); Vue.component(\"vuetable-pagination-info\", VueTablePaginationInfo);&#125; 사용 javascript1Vue.use(SurveyEditor); html1&lt;draggable-canvas slot=\"viewport\"&gt;&lt;/draggable-canvas&gt; Vue.use() 하면, 범위 안에서 컴포넌트를 전역으로 사용할 수 있다. 지역 배포 및 사용 install (survey 플러그인에서 발췌) javascript12345678910111213141516import SurveyEditor from './components/SurveyEditor';import DraggableCanvas from './components/questionEditor/DraggableCanvas';import Toolbox from './components/Toolbox';import EditDialog from './components/dialog/EditDialog';function install(Vue, options) &#123;&#125;export &#123; SurveyEditor, DraggableCanvas, Toolbox, EditDialog, install,&#125;;export default SurveyEditor; https://kr.vuejs.org/v2/guide/plugins.html 참고 사용 사용을 원하는 컴포넌트를, 지역으로 선언하여 사용한다. javascript12345678Vue.use(SurveyEditor);new Vue(&#123; el: '#app', components: &#123; canvas: SurveyEditor.DraggableCanvas, &#125;&#125;) html1&lt;canvas slot=\"viewport\"&gt;&lt;/canvas&gt; 결론일반적으로 단일 컴포넌트인 경우, 컴포넌트로 사용하고, 여러컴포넌트들을 모아서 기능을 만든 경우는 플러그인 형태로 배포하여 사용한다.","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"},{"name":"plugin","slug":"plugin","permalink":"http://apexsoft.github.io/tags/plugin/"}]},{"title":"vue slider 컴포넌트","slug":"slider component","date":"2018-02-23T07:47:32.323Z","updated":"2018-02-27T05:12:08.799Z","comments":true,"path":"2018/02/23/slider component/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/slider component/","excerpt":"","text":"slidervue-slider-component https://github.com/NightCatSama/vue-slider-component 직접수행해본 예제 https://jsbin.com/patusomaqi/2/edit?html,js,output","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"Spring security config 예제","slug":"간결한 spring security configure","date":"2018-02-23T06:58:20.621Z","updated":"2018-02-27T04:49:24.995Z","comments":true,"path":"2018/02/23/간결한 spring security configure/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/간결한 spring security configure/","excerpt":"","text":"간결한 spring security configure123456789101112131415161718192021222324@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .antMatcher(\"/unreal/**\") .csrf()// .disable() .ignoringAntMatchers(\"/unreal/**\") .and() .formLogin() .loginProcessingUrl(\"/unreal/auth/login\") .usernameParameter(\"username\") .passwordParameter(\"password\") .successHandler(loginSuccessHandler()) .failureHandler(loginFailureHandler()) .and() .logout() .logoutRequestMatcher(new AntPathRequestMatcher(\"/unreal/logout\")) .logoutSuccessHandler(logoutSuccessHandler()) .and() .authorizeRequests() .antMatchers(\"/user/**\").hasRole(\"USER\") .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .anyRequest().permitAll();&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://apexsoft.github.io/tags/springboot/"},{"name":"Security","slug":"Security","permalink":"http://apexsoft.github.io/tags/Security/"}]},{"title":"다국어처리","slug":"다국어 처리 적용하는 방법","date":"2018-02-23T06:58:20.621Z","updated":"2018-02-27T04:49:25.010Z","comments":true,"path":"2018/02/23/다국어 처리 적용하는 방법/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/다국어 처리 적용하는 방법/","excerpt":"","text":"다국어 처리 적용하는 방법en.js : 영문 번역본 파일ko.js : 한글 번역본 파일 파일위치 : resource/static/js/lang json 형태로 키값을 만들어주어야 함 영문과 한글 번역본의 키값은 동일해야 함 123456789&gt; var ko = &#123;&gt; message: &#123;&gt; hello: “안녕”&gt; &#125;,&gt; userid:&#123;&gt; required :\"필수입력\"&gt; &#125;&gt; &#125;;&gt; Freemarker 문구가 들어가는 부분에 ‘키값’ 맞춰서 작성 123456789&lt;body&gt; &lt;div id=’app’&gt; &#123;&#123; $t(“message.hello”) &#125;&#125; &lt;input name=\"userId\" v-bind:placeholder=$t(\"userid.required\") v-model=\"userId\"&gt; &lt;/div&gt;&lt;/body&gt; Javascript el: &#39;#app&#39; 아랫줄에 i18n: apex_lang 삽입 12345678910111213new Vue(&#123; el: '#app', i18n: apex_lang, data: &#123; userId: '', password: '' &#125;, methods: &#123; onSignIn: function() &#123; alert(apex_lang.t(‘message.hello’)); &#125; &#125;&#125;);","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"i18n","slug":"i18n","permalink":"http://apexsoft.github.io/tags/i18n/"}]},{"title":"vueRouter","slug":"라우터정리","date":"2018-02-23T06:58:20.621Z","updated":"2018-02-27T04:49:25.010Z","comments":true,"path":"2018/02/23/라우터정리/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/라우터정리/","excerpt":"","text":"VueRouter 불러오기1234567891011import Vue from 'vue'# 이곳에 VueRouter를 불러옵니다.import VueRouter from 'vue-router'import Home from './components/Home' #사용할 컴포넌트 import Login from './components/Login' #사용할 컴포넌트 # Vue에 VueRouter를 연결합니다.Vue.use(VueRouter) 라우트 정의12345# 라우트 정의const routes = [ &#123; path: '/', name: 'home-page',component: Home &#125;, &#123; path: '/login', name: 'Login-page', component: Login &#125;] 라우터 인스턴스 생성12345#라우터 인스턴스 생성const router = new VueRouter(&#123; mode: 'history', // history 모드를 사용하면 주소창에 hash가 없어집니다. routes // routes: routes 의 약어&#125;) history mode를 사용하면 URI가 localhost/#/login에서 localhost/login으로 변경됩니다. 모르겠음아마도 …. 해당 router.js파일에 const들은 export 하는듯 ….. 12345export &#123; routes,&#125;;export default router; Vue 인스턴스에 라우터 마운트하기12345678import router, &#123; routes &#125; from './router';new Vue(&#123; store, router, #이 부분을 추가합니다. el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;&#125;).$mount('#app') #이 부분도요 App 컴포넌트에 라우트 컴포넌트 불러오기12345&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; App.vue 컴포넌트에&lt;router-view&gt;&lt;/router-view&gt;를 추가합니다. 이제 라우팅을 통해 연결한 컴포넌트가 router-view 영역에 렌더링 됩니다. 이제 빌드해보면 에러가 납니다. main.js에 불러왔던 컴포넌트를 App.vue 컴포넌트에도 불러와야 합니다. 12345678910111213141516171819202122&lt;script&gt;import Home from './components/Home' // 추가해주세요.import Login from './components/Login' // 추가해주세요.export default &#123; name: 'app', components: &#123; Home, // 추가해주세요. Login // 추가해주세요. &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;ul class=\"navigation\"&gt; &lt;li&gt;&lt;router-link v-bind:to=\"&#123; name: 'home-page' &#125;\"&gt;Home&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link v-bind:to=\"&#123; name: 'Login-page-page' &#125;\"&gt;Counter&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"JPA 개념","slug":"JPA 큼직한 개념","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.979Z","comments":true,"path":"2018/02/23/JPA 큼직한 개념/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/JPA 큼직한 개념/","excerpt":"","text":"HibernateEJB 엔티티빈 기술을 대체 오픈소스 ORM 프레임워크 JPA (Java Persistence API)EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술표준 (JPA를 하이버네이트로 구현) 자바애플리케이션과 JDBC 사이에서 동작 테이블을 객체 지향적으로 만들어서 사용 (상속이 가능함) 제공하는 기능 (대분류) 엔티티와 테이블을 매핑하는 설계 부분 매핑한 엔티티를 실제 사용하는 부분 장점 생산성 향상 : SQL 작성하고, JDBC api 사용하는 반복적인 일들을 대신 처리해줌. ​ 나아가서 DDL 문을 자동으로 생성해주는 기능도 있음. 유지보수 궁금증Q. 매우 복잡한 SQL은 어떻게 하나요? A.통계와 같은 복잡한 쿼리는 SQL 작성이 더 쉬울수도. 마이바티스나 다른 SQL 매퍼 형태의 프레임워크를 혼용할 수도 있음. Q. 하이버네이트 사용? A. 국내에서 유독 마이바티스를 많이 사용. 전 세계적으로 조사하면 하이버네이트 프레임워크 사용 비중이 더 높음. JPQL엔티티 객체를 조회하는 객체지향 쿼리 네이티브 SQLJPQL을 사용해도 특정 데이터베이스에 의존하는 기능 (예: 오라클/MySQL만의 기능) 을 지원 스프링 데이터 JPA스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트. Repository를 개발할 때 인터페이스만 작성하면 실행 시점에서 스프링 데이터가 JPA가 구현 객체를 동적으로 생성해서 주입해줌. (데이터 접근 객체 구현 시, 구현 클래스 없이 인터페이스만 작성) 책에서 JpaRepository&lt;(객체), (데이터타입)&gt;을 상속 받아서 사용하라고 함. 쇼핑몰 프로젝트에서 모든 Repository는 CrudRepository&lt;(객체), (데이터타입)&gt;을 상속 받음 CrudRepository&lt;(객체), (데이터타입)&gt; : 스프링 데이터 프로젝트가 공통으로 사용하는 인터페이스 JpaRepository&lt;(객체), (데이터타입)&gt; : 스프링 데이터 프로젝트 인터페이스에 JPA 특화된 기능들을 제공 위 인터페이스들을 상속 받아 Repository를 구현하면 엔티티를 제어하는 주요 메소드들을 구현 클래스 작성 없이 사용 가능. 특정 조건에 만족하는 쿼리 수행하는 방법 쿼리를 유추할 수 있는 메소드 이름을 통해 쿼리를 정의. 메소드 이름 규칙 : findBy + (조건 필드이름) + (And) / (Or) java123public interface UserRepository extends Repository&lt;User, Long&gt; &#123; List&lt;User&gt; findByEmailAddressAndLastname(String emailAddress, String lastname);&#125; 쿼리 메소드 기능스프링 데이터 JPA가 제공하는 기능 대표적인 기능은 메소드 이름만으로 쿼리를 생성하는 기능. Repository 인터페이스에서 메소드만 선언하면 해당 메소드 이름(정해진 규칙에 따라 메소드 이름을 지어야 함)으로 적절한 JPQL 쿼리를 생성하여 실행. 쇼핑몰 프로젝트 내 해당 부분 java12345@Repositorypublic interface CartItemRepository extends CrudRepository&lt;CartItem, CartItemId&gt; &#123; List&lt;CartItem&gt; findCartItemsByCart(Cart cart);&#125; 그 외 다양한 기능들 포함함. 엔티티의 생명주기 비 영속 : 엔티티를 new 한 시점 영속 : 엔티티를 new 한 후 persist(삽입), find(조회), query 메소드를 사용하여 저장, 조회한 경우 삭제 : 영속 객체를 remove 메소드로 삭제한 경우 준 영속 : 트랜잭션이 commit되었거나 clear, flush 메소드가 실행된 경우. 이걸 다시 영속 객체 상태로 만들기 위한 merge 메소드가 존재함. 영속성 컨텍스트Entity Manager가 엔티티들을 관리할 때 이곳에 보관하고 관리함. 관리되는 모든 엔티티 인스턴스의 집합. EntityManager엔티티의 생명주기, 영속성 컨텍스트, 트랜잭션을 관리함 EntityManagerFactoryEntityManager를 관리","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"REDIS","slug":"Redis","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.979Z","comments":true,"path":"2018/02/23/Redis/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/Redis/","excerpt":"","text":"REDIS (REmote DIctionary Server)key/Value Store in memory key value database key/value 저장소 특정 키 값에 값을 저장하는 구조 메모리에 데이터를 저장 빠른 read /write 속도 전체적인 저장 가능한 데이터의 용량은 물리적인 용량을 넘을수 없음 RDB나 NoSQL이 기본적으로 file system에 데이터 저장 ​ 유용 사례 최신 랭킹이 필요한 경우 많은 데이터 필요 x , 빠른 처리만 필요 최신 데이터 간의 비교, 차이계산 경우 최근에 이직 신청을 한 다음 직원은? ​ 저장 구조 in-mamory + hard disk 빠른데 + 복구도 가능 Pub/Sub Model 분산 처리 Replication Topology(Master-Slave &lt;- Query Off Loading, Sharding) read/write 성능 향상 ​ 저장 형태 다양한 data set 제공 다양한 집합set 연산 가능 -&gt; 데이터 저장 키 값에 다양한 데이터 타입을 매핑 시킬수 있음 다양한 테이터 타입을 지원 복잡한 구조를 저장 가능​ 관리 정책Persistence(지속성) disk에 저장 가능, shutdown 후에도 데이터 보존 가능 서버가 shutdown된 후 restart되더라도, disk에 저장해놓은 데이타를 다시 읽어서 메모리에 Loading 데이터 저장 방식 RDB[snapshotting] 순간적으로 메모리에 있는 내용을 DISK에 전체를 옮겨 담는 방식 AOF[Append On File] 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태이다 Expiation 데이터 유효기간 설정 가능 (데이터 생명주기를 정해서 일정 시간이 지나면 자동으로 삭제 되게 한다) 내부 정책 Active 데이터 접근할 때 유효기간 체크 passive 주기적으로 키를 100개 랜덤 뽑아 체크 랜덤이라 체크 안된 garbage 잔존가능 expired time이 지난 후 클라이언트에 의해서 접근 되지 않은 데이타는 Active 방식으로 인해서 지워지지 않고 Passive 방식으로 지워져야 하는데, 이 경우 Passive 방식의 경우 전체 데이타를 scan하는 것이 아니기 때문에 ​","categories":[],"tags":[{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"vee-validate","slug":"vee-validate","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.995Z","comments":true,"path":"2018/02/23/vee-validate/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/vee-validate/","excerpt":"","text":"몇가지 사전 체크사항&lt;label&gt;, &lt;input&gt; and id, name attribute &lt;label for=&quot;&quot;&gt;의 대상은 input의 id VeeValidate에서 validation 대상은 input의 name으로 errors.has(&#39;name&#39;)와 같이 사용 그러므로 input은 id, name을 모두 명시해 주는 것이 좋음 Migrating to Bootstrap 4Form Grouplabel과 input을 한 줄에 배치하려면 class에 &quot;row&quot;를 추가 Labelcontrol-label은 더이상 사용 불가능하며 오른쪽 정렬도 해주지 않음 col-form-label을 사용하고 정렬은 text-*를 사용 html1&lt;label for=\"username\" class=\"col-form-label text-right\"&gt;아이디&lt;/label&gt; Inputform-control을 필히 명시 validation에 대한 bootstrap 클래스는 is-invalid | is-valid html1&lt;input id=\"username\" class=\"form-control is-invalid\"&gt; &lt;!--invalid인 경우--&gt; vee-validatevue에서 validation 수행을 도와준다. 공식사이트 : http://vee-validate.logaretm.com/ 사용방법htmlhtml1234567&lt;!-- 기본 vue.js --&gt;&lt;script src=\"https://unpkg.com/vue\"&gt;&lt;/script&gt;&lt;!--vee validate--&gt;&lt;script src=\"https://unpkg.com/vee-validate@2.0.0-rc.13\"&gt;&lt;/script&gt;&lt;script&gt; Vue.use(VeeValidate);&lt;/script&gt; 기본 validate 설정html123&lt;input v-validate=\"'required|email'\" :class=\"&#123;'input': true, 'is-danger': errors.has('email') &#125;\" name=\"email\" type=\"text\" placeholder=\"Email\"&gt; 에러메세지 출력html12345&lt;div class=\"has-icon has-icon-right\"&gt; &lt;i v-show=\"errors.has('email')\" class=\"fa fa-warning\"&gt;&lt;/i&gt; &lt;span v-show=\"errors.has('email')\" class=\"invalid-feedback\"&gt;&#123;&#123; errors.first('email') &#125;&#125;&lt;/span&gt;&lt;/div&gt; fa, fa-warning으로 아이콘 출력 가능 (icons 참조) 아이콘을 input과 함께 표시해주기 위해 div에 has-icon 클래스를 추가 해당 클래스에 대한 스타일은 vee-validate 예제 페이지를 참조하여 apex-web-base.css에 추가 속성v-validate v-validate 속성에 rule 을 지정 여러가지 rule 입력 가능 html12&lt;input v-validate=\"'required|min:6|max:16'\"&gt; // 1&lt;input v-validate=\"&#123; rules: &#123; required: true, min:6, max:16&#125;&#125;\"&gt; // 2 1방법에서 rule을 여러개 입력하는 경우, 반드시 큰 따옴표 안에 작은 따옴표로 감싸준다. 주요 v-validate 값 예제 : https://jsbin.com/siqodemose/4/edit?html,js,output ​ (이메일, 비밀번호(대,소문자,특수문자), 전화번호, 웹사이트) v-bind:class class를 동적 바인딩 errors.has(&#39;field&#39;)로 해당 필드에 에러가 있는지 판단 html12&lt;input v-validate=\"'required|email'\" :class=\"&#123;'form-control': true, 'is-invalid': errors.has('userId')&#125;\" Rendering Errors : errors를 통해 에러가 있는지, 어떤 에러인지 알아 볼 수 있다. has(&#39;field&#39;): 해당 필드에 에러가 있는지 first(&#39;field&#39;): 해당 필드의 첫번째 에러 메시지 가져오기 all(): 해당 필드의 모든 에러 메시지 가져오기 collect(&#39;field&#39;): any(): 경고 메시지 커스텀Vue 생성시 Dictionary를 변경 vue.js12345678910111213141516171819202122created() &#123; let dict = &#123; en: &#123; custom: &#123; userId: &#123; required: () =&gt; 'User ID is empty.', email: () =&gt; 'User ID must be email.' &#125; &#125; &#125;, ko: &#123; custom: &#123; userId: &#123; required: () =&gt; '아이디가 비어 있습니다.', email: () =&gt; '아이디는 email 형태여야 합니다.' &#125; &#125; &#125; &#125; this.$validator.setLocale('ko'); this.$validator.updateDictionary(dict);&#125;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"}]},{"title":"promise","slug":"promise","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.995Z","comments":true,"path":"2018/02/23/promise/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/promise/","excerpt":"","text":"promise 비동기 동작의 흐름을 제어할 때 사용 JavaScript ES6에 추가 아직은 아니지만 나중에 완료될 것으로 기대 되는 연산을 의미 async(비동기)연산에서 사용 Promise object는 new를 통해 initiate될 수 있으며, 함수를 패스받을 수 있다. 이 함수에는 resolve, reject함수가 매개변수로 차례로 들어가있다. javascript1234567891011121314151617function task(resolve, reject) &#123; console.log('task start'); setTimeout(function() &#123; console.log('task end'); resolve('task success'); &#125;, 300);&#125;function resolveed(result) &#123; console.log('resolve : '+result);&#125;function rejected(err) &#123; console.log('rejected : ', err);&#125;new Promise(task).then(resolveed, rejected); promise 이후의 동작 : then 성공과 실패일 때 각각 콜백처리 한다 resolve promise가 성공적으로 종료될 때 promise의 뒤에 따라오는 then의 콜백에 arg로 사용될 value를 넘겨받을 수 있다. reject promise에서 에러가 발견된 경우, 혹은 조건에 맞지 않아 에러를 발생시켜야 하는 경우 호출 promise의 메서드인 catch안에 들어간다. 보통 resolve는 error의 이유가 들어간다 123456789101112let func = function(resolve)&#123; resolve();&#125;;let promise1 =new Promise(func);promise1.then(()=&gt;alert('resolve1'));let promise =new Promise((resolve,reject)=&gt;&#123; reject(); &#125;);promise.then(()=&gt;alert('resolve'));promise.catch(()=&gt;alert('reject')); https://jsbin.com/nusaxemero/2/edit?html,js,console,output","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://apexsoft.github.io/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://apexsoft.github.io/tags/javascript/"}]},{"title":"JPA 엔티티 구성","slug":"JPA 엔티티 구성","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.979Z","comments":true,"path":"2018/02/23/JPA 엔티티 구성/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/JPA 엔티티 구성/","excerpt":"","text":"JPA 엔티티 구성쇼핑몰 소스/중요도 위주로 작성함 레퍼런스@Entity테이블과 매핑할 클래스는 필수로 붙혀야 함 @Table엔티티와 매핑할 테이블을 지정 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용. name : 매핑할 테이블 이름 @Id기본키 직접 할당 @GeneratedValue@Column객체 필드를 테이블 컬럼에 매핑 name : 필드와 매핑할 테이블의 컬럼 이름. 기본값이 필드 이름 java12@Column(name = \"cart_id\")private Long id; columnDefinition : 데이터베이스 컬럼 정보를 직접 설정. nullable : null 값 허용 여부 false일 경우, not null 제약조건이 됨. 기본값이 true @JoinColumn관계를 나타낼 때 사용. 외래 키를 매핑할 때 사용. name : 매핑할 외래 키 이름 @JsonIdentityInfo? @RequiredArgsConstructor생성자를 자동으로 만들어주고, 옵션에 따라 null 체크도 해줌 엔티티 관계 설정 (관계를 가진 엔티티끼리 조인할 때 사용)@ManyToOne다대일 관계 설정에서 사용 fetch : 글로벌 페치 전략을 설정 FetchType.EAGER : 관계된 엔티티의 정보를 미리 읽어오는 것 FetchType.LAZY : 관계된 엔티티의 정보를 실제 요청하는 순간 가져오는 것 java1234567public class CartItem extends BaseEntity implements Serializable &#123; .. @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"cart_id\") private Cart cart; ..&#125; @OneToMany일대다 관계 설정에서 사용 mappedBy : 양방향 관계 설정시 관계의 주체가 되는 쪽에서 정의 fetch : 관계 엔티티의 데이터 읽기 전략을 결정. FetchType.EAGER : 관계된 엔티티의 정보를 미리 읽어오는 것 FetchType.LAZY : 관계된 엔티티의 정보를 실제 요청하는 순간 가져오는 것 java1234567public class Cart extends BaseEntity implements Serializable &#123; .. @OneToMany(mappedBy = \"cart\", fetch = FetchType.EAGER) @OrderBy(\"created_at asc\") private List&lt;CartItem&gt; cartItems; ..&#125; @ManyToOne과 @OneToMany 두가지가 크게 다르지 않음. 어느쪽을 기준으로 작성하느냐에 따라 다름 JPA는 다양한 쿼리 방법을 지원 JPQL JPA Criteria QueryDSL 네이티브 SQL JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께 사용 JPQL로 쿼리 사용SQL과 유사한 문법을 가지는 쿼리. 엔티티 객체를 대상으로 쿼리 두 개의 엔티티를 조인해야 하는 경우, 이런 방법을 쓰는 것 같음. java12345EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"(db정보가 들어갈 듯?)\");EntityManager em = emf.createEntityManager();String jpql = \"select m from Member as m where m.username = 'kim'\";List&lt;Member&gt; resultList = em.createQuery(jpql, Member.class).getResultList(); 실제 실행된 쿼리 sql123456789select member.id as id, member.age as age member.team_id as team, member.name as namefrom Member memberwhere member.name = 'kim'","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"node.js? npm? cdn? 사용하기","slug":"nodjs","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.979Z","comments":true,"path":"2018/02/23/nodjs/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/nodjs/","excerpt":"","text":"javascript 사용1. CDN https://unpkg.com/#/ OR https://www.npmjs.com/ dist 폴더 , 다른이름으로 링크주소 복사 &lt;script &gt; 주소 &lt;/script&gt; 2.npm git 다운 npm run bundle or yarn bundle dist 폴더 , 생성된 물리적 파일 원하는 프로젝트에 옮기기 webpack ? 모듈 번들러 의존성을 가진 모듈들을 다루고 , 그 모듈로부터 정적인 asset을 생성 작동 방법 하나의 파일을 진입점으로 지정 진입점 파일은 트리의 루트가 된다 require에 의해 다른 파일이 트리에 추가 된다 = require으로 명시된 의존성들을 해석하며 의존성 트리를 그린다 webpack명령을 실행하면 , 모든 파일과 모듈은 하나의 파일에 번들로 제공된다 모듈 번들링 모듈간의 의존성을 해석하고 , 그걸 바탕으로 정적 에셋을 만드는 과정 모듈 번들러 모듈 번들링을 하는 친구 ex ) webpack 거대한 파일들을 여러 파일로 나눠 쓸수있게 해준다. ​ webpack-dev-server 메모리에 bundle 파일을 올려 놓고 변경이 있을때 마다 , live reload를 시킨다 webPack.dev.config.js webpack-dev-server가 사용할 환경설정에 대해 정의 devServer host : localhost 모든 ip를 사용하는 경우 0.0.0.0사용 port : 8080 접속 포트 설정 proxy : {‘**’ :”http://localhost:8001&quot;} 프록시 설정 , Springboot 실행되는 url 12345axios .get(`http://localhost:8001/tester/api/proto/ans/ask/$&#123;this.askNo&#125;`) .then((res) =&gt; &#123; &#125; &#125;); ​ 12345axios.get(`/tester/api/proto/ans/ask/$&#123;this.askNo&#125;`).then((res) =&gt; &#123; &#125;&#125;); 실행 bash123456#package.json에 정의된 모듈 설치(node_modules에 다운로드)npm install#webpack -dev-server 구동npm run dev npm run명령 뒤의 스크립트 명(dev)는 pakage.json에 정의 되어있다 package.json npm 설정을 관리 이를 통해 모든 부품이 설치되어 돌아갈 수 있습니다. devDependencies lint 코딩 룰에 위배되는거 체크 해준다 pug babel Babel은 Transform Compiler이다. 보통 TypeScript, CoffeeScript 같은 Javascript 문법이 아닌 각각의 문법으로 작성된 코드를 Javascript 엔진에서 동작 가능한 코드로 변환하는 역할 ES6 -&gt; ES5 transpiler loader 일종의 함수 마지막 로더는 최종적으로 적절하게 변형된 모듈을 번들 자바스크립트 파일에 넣어주게 된다 ex) css 파일 require 하는 경우 css 파일을 그대로 자바스크립트에 넣을수 없으니 , 원래의 css파일과 같은 역활을 할 수 있는 자바스크립트 형태의 무언가를 만들어야 최종 번들에 해당 내용을 포함시킬수 있다. 이 과정을 일련의 로더 파이프라인이 수행 webpack.config.js webpack을 설정한다 12345678910111213var path = require('path')module.exports = &#123; entry: &#123; 'vuejs-test2': path.join(__dirname, '/src/vuejs-test2.js'), 'draggabletest': path.join(__dirname, '/src/draggabletest.js') &#125;, output: &#123; path: path.join(__dirname, '../src/main/resources/static/js/bundles'), publicPath: '/js/bundles', filename: '[name].js' &#125;&#125; enty - 번들의 엔트리 포인트 . webpack은 여러 번들을 생성하는 진입점을 허용하기 때문에 배열이다 output - webpack의 최종 결과물이 되는 형태를 명시 path - 어디에 번들 파일을 위치 시킬 것인지를 지정 ( 빌드 결과물 들어갈 webpack.config.js로 부터의 상태 경로 ) publicPath - 웹사이트에서 해당 에셋에 접근하기 위해 필요한 경로 filename 각 번들 파일의 이름을 지정 [name] : entry에서의 key 값 Loader - Loader는 사전에 처리할 작업을 나타내며 css, html, jpg, scss 등의 자산을 하나의 모듈로 취급하며 이러한 파일들을 종속성 그래프에 추가할 때 모듈로 변환한다. Plug-In - Plug-In은 일반적인 Compile 또는 모듈 처리에 필요한 작업 및 사용자 정의 기능을 수행하는데 사용한다. webpack 명령을 실행하면 , bundles라는 폴더에 draggabletest.js vuejs-test2파일을 생성한다 webpack은 require 하고있는 파일들 모두 묶어 하나의 번들을 내놓게 된다 node-moules npm이 pakage들을 설치하는 디렉토리 폴더 사용설치 node.js 설치 https://nodejs.org/en/download/current/ yarn 설치 npm install -g yarn -g는 글로벌 옵션 Plugins 설치 (선택) vue.js pug 실행 package.json에 정의된 모듈 설치 npm install 주입 후 빌드 refresh webpack -dev-server 구동 npm run dev springboot 서버 실행 시큐리티 설정에 걸리는 경우 , 해당 url .permitAll() 하기 ​ 옮기기 npm run bundle dist 밑에 생기는 파일 복사해서 붙여 넣는다 기타lint 코딩룰 체크 설치 yarn 설치 npm install -g yarn lint 설치 npm install -g eslint pakage.json &gt;&gt; devDependencies &gt;&gt; 추가 사용 rule 확인 + fix yarn lint --fix .eslintrc.js rule 정의","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://apexsoft.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://apexsoft.github.io/tags/npm/"}]},{"title":"spring security","slug":"Spring Security","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.979Z","comments":true,"path":"2018/02/23/Spring Security/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/Spring Security/","excerpt":"","text":"1. build.gradle1compile('org.springframework.boot:spring-boot-starter-security') 2. DB, Domain에 USER와 ROLE 필요 User java12345678910111213141516171819202122232425262728293031@Entity@Table(name = \"USER\")@Getter @Setter@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")public class User extends AbstractBaseEntity implements Serializable &#123; @Id @GeneratedValue @Column(name = \"user_id\") private Long id; @NotNull @Column(name = \"user_name\", unique = true) @Size(min = 8) private String userName; @NotNull @Column(name = \"password\") @Size(min = 8) private String password; @Column(name = \"email\") private String email; @ManyToMany @JoinTable(name = \"user_role\", joinColumns = @JoinColumn(name = \"user_id\"), inverseJoinColumns = @JoinColumn(name = \"role_id\")) private Set&lt;Role&gt; roles;&#125; Role java1234567891011121314151617181920212223@Entity@Table(name = \"role\")@Getter @Setter@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")public class Role extends AbstractBaseEntity implements Serializable &#123; @Id @GeneratedValue private Long id; @NonNull private String name; public Role() &#123; &#125; public Role(String name) &#123; this.name = name; &#125; @ManyToMany(mappedBy = \"roles\") private Set&lt;User&gt; users;&#125; 3. UserServiceDetailImpl 생성UserDetailService를 구현해야만 Spring Security가 정상적으로 조회 가능 InMemoryAuthentication설정이 없다면 기본적으로 UserDetailsService구현 객체를 찾아 로그인 요청시 이용한다. InMemoryAuthentication설정이 있으면, UserDetailsService구현 객체가 있어도 해당 흐름을 타지 않는다. java123456789101112131415161718192021222324@Service@RequiredArgsConstructor(onConstructor = @__(@Autowired))public class UserServiceDetailImpl implements UserDetailsService &#123; @NonNull private final UserRepository userRepository; @Override @Transactional(readOnly = true) public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = this.userRepository .findByUserName(username) .orElseThrow(() -&gt; new UsernameNotFoundException(\"사용자 이름을 찾을 수 없습니다.\")); Set&lt;GrantedAuthority&gt; grantedAuthorities = new HashSet&lt;&gt;(); for (Role role: user.getRoles()) &#123; grantedAuthorities.add(new SimpleGrantedAuthority(role.getName())); &#125; return new org.springframework.security.core.userdetails.User(user.getUserName(), user.getPassword(), grantedAuthorities); &#125;&#125; loadUserByUsername메소드를 반드시 구현해야한다. 스프링시큐리티에서 User 정보를 읽을 때 사용된다. User를 읽어왔으면 권한을 부여해준다. 4. 비밀번호 암호화비밀번호 뿐만 아니라 개인 식별정보는 필히 암호화를 거쳐 저장하여야 한다.암호화는 BCrypt 방식을 이용하며 Spring에서 기본적으로 제공되는 클래스는 BCryptPasswordEncoder 이다.passwordEncoder 라는 이름의 빈으로 등록하면 자동으로 적용된다. java1234@Beanpublic BCryptPasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder();&#125; 회원가입 시 패스워드를 DB에 저장할때는 PasswordEncoder 를 통해 암호화하는 로직을 필히 명시해줘야 한다. java12345678910111213141516@Servicepublic class UserServiceImpl implements UserService &#123; @NonNull private final BCryptPasswordEncoder bCryptPasswordEncoder; @Override public User saveUserUser(User user) &#123; user.setPassword(bCryptPasswordEncoder.encode(user.getPassword())); if (Objects.isNull(user.getRoles()) || user.getRoles().isEmpty()) &#123; Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); roles.add(roleRepository.findByName(\"ROLE_USER\") .orElseThrow(() -&gt; new IllegalStateException(\"ROLE is not set\"))); user.setRoles(roles); &#125; return this.userRepository.save(user); &#125;&#125; 5. 로그인1) WebSecurityConfig.java &gt; 로그인 관련 부분java123456789101112.formLogin() .loginPage(\"/user/view/membership/sign-in\") .loginProcessingUrl(\"/user/auth/login\") .usernameParameter(\"userName\") .passwordParameter(\"password\") .successHandler(loginSuccessHandler()) .failureHandler(loginFailureHandler()) .permitAll().and().logout() .logoutRequestMatcher(new AntPathRequestMatcher(\"/user/auth/logout\")) .logoutSuccessHandler(logoutSuccessHandler()) .loginPage(&quot;/user/view/membership/sign-in&quot;) : 로그인 페이지 지정 .loginProcessingUrl(&quot;/user/auth/login&quot;) 로그인을 수행하는 url 지정 해당 url controller를 별도로 지정하지 않음 UserDetailService 구현부분을 찾아서 로그인을 수행함 .usernameParameter(&quot;userName&quot;) : User 도메인 내 아이디 변수를 그대로 작성 .passwordParameter(&quot;password&quot;) : User 도메인 내 비밀번호 변수를 그대로 작성 .successHandler(loginSuccessHandler()) : 로그인 성공핸들러, 대부분 url을 리다이렉트 함 .failureHandler(loginFailureHandler()) : 로그인 실패 핸들러, 대부분 url을 리다이렉트 함 .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/user/auth/logout&quot;)) : method를 지정할 수 있기 때문에 csrf를 적용하고, get을 이용하는 경우에 사용 .logoutSuccessHandler(logoutSuccessHandler()) : 로그아웃 핸들러, 대부분 url을 리다이렉트 함 RestLoginSuccessHandler java12345678910public class RestLoginSuccessHandler extends SimpleUrlAuthenticationSuccessHandler &#123; Logger logger = LoggerFactory.getLogger(RestLoginSuccessHandler.class); @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; logger.info(\"로그인 성공\"); response.sendRedirect(\"/\"); &#125;&#125; RestLoginFailureHandler java1234567891011121314public class RestLoginFailureHandler implements AuthenticationFailureHandler &#123; Logger logger = LoggerFactory.getLogger(RestLoginFailureHandler.class); @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; int cuase=0; if(exception.getClass().equals(BadCredentialsException.class))&#123; cuase=1; &#125; logger.info(\"로그인 실패\"); response.sendRedirect(\"/?cause=\"+cuase); &#125;&#125; RestLogoutSuccessHandler java123456789101112public class RestLogoutSuccessHandler extends SimpleUrlLogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; String targetUrl = determineTargetUrl(request, response); if (response.isCommitted()) &#123; logger.debug(\"Response has already been committed. Unable to redirect to \" + targetUrl); &#125; logger.info(\"로그아웃 성공\"); response.sendRedirect(\"/\"); &#125;&#125; 2) 로그인 화면 sign-in.ftl html123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;div class=\"text-center\"&gt; &lt;h1&gt;로그인&lt;/h1&gt; &lt;form class=\"pure-form pure-form-aligned\" id=\"form-login\"&gt; &lt;fieldset&gt; &lt;div class=\"pure-control-group\"&gt; &lt;label for=\"userName\"&gt;UserName&lt;/label&gt; &lt;input name=\"userName\" v-model=\"userName\" id=\"userName\" class=\"pure-input-1-3\" value=\"\" placeholder=\"UserName\" type=\"text\"&gt; &lt;/div&gt; &lt;div class=\"pure-control-group\"&gt; &lt;label for=\"password1\"&gt;Password&lt;/label&gt; &lt;input name=\"password\" v-model=\"password1\" id=\"password1\" class=\"pure-input-1-3\" value=\"\" placeholder=\"Password\" type=\"password\"&gt; &lt;/div&gt; &lt;div class=\"pure-controls\"&gt; &lt;button class=\"pure-button pure-button-primary pure-u-1-3\" @click.prevent=\"onSignIn()\"&gt;로그인 &lt;/button&gt; &lt;/div&gt; &lt;input type=\"hidden\" name=\"$&#123;_csrf.parameterName&#125;\" value=\"$&#123;_csrf.token&#125;\"/&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; sign-in.js vue.js123456789101112131415161718new Vue(&#123; el: '#app', i18n: apex_lang, data: &#123; userName: '', password1: '', &#125;, methods: &#123; onSignIn() &#123; console.log('onSignIn'); let form = document.getElementById(\"form-login\"); form.method = 'post'; form.action = '/user/auth/login'; form.submit(); &#125; &#125;&#125;); .loginProcessingUrl(&quot;/user/auth/login&quot;) 시큐리티 설정시, 지정했던 url과 동일한 url을 사용 6. 계정 만료 및 잠금에 의한 로그인 실패처리loadUserByUsername 메소드의 반환값은 UserDetails 타입이다. org.springframework.security.core.userdetails.User java1234567private String password;private final String username;private final Set&lt;GrantedAuthority&gt; authorities;private final boolean accountNonExpired;private final boolean accountNonLocked;private final boolean credentialsNonExpired;private final boolean enabled;","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://apexsoft.github.io/tags/springboot/"},{"name":"security","slug":"security","permalink":"http://apexsoft.github.io/tags/security/"}]},{"title":"블로그 만들기","slug":"Github page와 Hexo 이용, 기술 블로그 만들기","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.979Z","comments":true,"path":"2018/02/23/Github page와 Hexo 이용, 기술 블로그 만들기/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/Github page와 Hexo 이용, 기술 블로그 만들기/","excerpt":"","text":"Github page와 Hexo 이용, 기술 블로그 만들기Git Page1. Github Repository 생성 https://github.com/ New Repository, Repository 이름은 USERNAME.github.io USERNAME 은 Github의 가입시에 사용자의 username을 입력한다 Public / Private 중 Public 선택 Create Repository 버튼을 통해 Repository 생성 확인 - https://USERNAME.github.io Hexo Hexo는 Jekyll와 함께 대표적으로 정적 페이지를 쉽게 만들 수 있도록 도와주는 서비스이다.Hexo의 경우에는 npm을 통해 쉽게 설치가 가능하고 한 줄의 Command Line을 통해 Github에 바로 배포다양한 플러그인과 테마를 지원하고 있다 1. 다운로드 Node.js Git 2. 설치 Hexo node.js1$ npm install -g hexo -cli git node.js1$ npm install hexo-deployer-git --save 3. 블로그 생성bash 123$ hexo init [폴더명]$ cd [폴더명]$ npm install 4. 설정파일 ( _config.yml ) 수정 root 디렉토리에 _config.yml 파일로, 블로그에 대한 설정 한다 문서 - https://hexo.io/docs/ 기본 설정 site 정보 _config.yml1234title: apexsoft 기술블로그 subtitle: 우리모두 masterdescription:author: Hyosook Kim ​ URL 정보 _config.yml1234url: http://apexsoft.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults: ​ Github 정보 _config.yml1234deploy: type: git repo : https://github.com/ApexSoft/apexsoft.github.com.git branch : master 테마 적용 테마 선택 - https://hexo.io/themes/ git clone bash12# hexo [폴더/themes]에 다운$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman _config.yml` theme 수정 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: hueman #폴더명과 매칭되어야한다 검색 기능 (Insight earch)를 이용하기 위해서는 hexo-generator-json-content를 설치 bash1npm install -S hexo-generator-json-content 테마 폴더 안에 있는 _config.yml.example의 이름을_config.yml로 수정 clean bash1$ hexo clean ​ http://futurecreator.github.io/2016/06/14/hexo-apply-hueman-theme/ 5. 포스트 작성 새 포스트 만들기 bash1$ hexo new post [post_name] or 123ㄴ source ㄴ _posts - ##여기에 .md파일 넣기 포스트 제목 및 수정 1234567---title: \"블로그 만들기 \" #post 제목date: 2017-07-07 00:23:23 #post 생성 날짜tags: [\"hexo\", \"clean-blog\", \"theme\"] #tagscover: /assets/contact-bg.jpg #post 커버 이미지subtitle: \"첫 블로그입니다.\" #post 부제--- ​ 6. 로컬에서 testbash1$ hexo server http://localhost:4000 7. Github Page Repository에 배포 정적 리소스 생성 bash1$ hexo generate 배포 bash1$ hexo deploy 생성 + 배포 한번에 bash1$ hexo deploy --generate 확인 http://apexsoft.github.io/ https://github.com/ApexSoft/apexsoft.github.com.git -master branch ​ 8. 소스관리 master : 블로그 (html) 파일 , hexo를 통해서 deploy 된 소스 soucre : hexo 원본 파일들. 9. 사용 git clone &gt; source branch &gt; https://github.com/ApexSoft/apexsoft.github.com.git .md 파일 올리기 git push &gt; source branch &gt; https://github.com/ApexSoft/apexsoft.github.com.git deploy 10. 기타 테마가 적용 안되는 경우 bash1$ hexo clean 테마 안에 있는 git 삭제 bash1$ rm -rf .git 배포가 되지 않는 경우 해볼 것들 git을 못 찾는다면 hexo-deployer-git 설치 bash1$ npm install hexo-deployer-git --save github 관련 에러 경우 http://maxisam.github.io/2016/09/02/Hexo-got-error-on-deploying-to-github/ 블로그 참고 1) Git Credential Manager for Windows 설치 https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases 2) git bash에서 명령어 실행 bash1$ git config --global credential.helper wincred 3) 자격증명 삭제 제어판 &gt; 사용자계정 &gt; 자격증명 관리자 &gt; windows 자격 증명 &gt; 일반 자격 증명 에서 github.com 자격증명을 제거 deploy 혹은 push를 할때, 다시 ID&amp;PW를 입력해야 한다.","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://apexsoft.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://apexsoft.github.io/tags/github/"}]},{"title":"v-cloak","slug":"v-cloak","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.995Z","comments":true,"path":"2018/02/23/v-cloak/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/v-cloak/","excerpt":"","text":"v-cloak실행될때, 머스태쉬 태그들이 짧은 순간 동안 깜박거리는 현상이 존재. 자바스크립트 코드가 실행되기 전이기 때문에. v-cloak 을 사용하면 html 코드를 숨길 수 있다. html123&lt;div id=\"app\" v-cloak&gt; ..&lt;/div&gt; css 123[v-cloak] &#123; display: none;&#125;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"Drag and drop","slug":"Drag and drop 컴포넌트","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.979Z","comments":true,"path":"2018/02/23/Drag and drop 컴포넌트/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/Drag and drop 컴포넌트/","excerpt":"","text":"Drag and dropSortablehttps://github.com/RubaXa/Sortable Sortable을 vue component로 만든 Draggablehttps://github.com/SortableJS/Vue.DraggableDraggable 직접 구현한 예제 https://codepen.io/anon/pen/dzvzGy?editors=1010 html1234567891011121314&lt;head&gt; &lt;!-- CDNJS :: Sortable (https://cdnjs.com/) --&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/Sortable/1.6.0/Sortable.min.js\"&gt;&lt;/script&gt; &lt;!-- CDNJS :: Vue.Draggable (https://cdnjs.com/) --&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/Vue.Draggable/2.14.1/vuedraggable.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;draggable v-model=\"list2\" class=\"dragArea\" :options=\"secondOption\"&gt; &lt;div v-for=\"(element, index) in list2\" :key=\"index\"&gt;&#123;&#123;element.name&#125;&#125; &lt;button @click=\"remove(index)\"&gt;remove&lt;/button&gt; &lt;/div&gt; &lt;/draggable&gt;&lt;/body&gt; vue.js123456789101112131415...data: &#123; firstOption: &#123; group: &#123; name: 'people', pull: 'clone', put: false &#125;, sort: false &#125;, secondOption: &#123; group: 'people' &#125;&#125;... option 속성 속성명 자세한 속성 내용 pull false 선택하여 이동하는 드래그앤드롭 안됨 true 선택한 객체를 드래그앤드롭으로 이동 clone 선택한 객체가 복사되어 드래그앤드롭 가능 put false 드래그로 들어온 객체를 현재 목록에 드롭시키지 못함 true 드래그로 들어온 객체를 현재 목록에 드롭시킬 수 있음 array [foo, boo] sort true 현재 선택한 객체를 현재 리스트 안에서 드래그앤드롭으로 정렬할 수 있음 false 현재 선택한 객체를 현재 리스트 안에서 드래그앤드롭으로 정렬할 수 없음","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"}]},{"title":"확장","slug":"pug","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-27T04:49:24.995Z","comments":true,"path":"2018/02/23/pug/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/pug/","excerpt":"","text":"pug templete 확장을 가능하게 하는 언어 extend 컴포넌트 확장 예제 기본 구조 SurveyInputBase.pug .pub 파일 html에서 닫는 태그가 없다 들여쓰기한 이후에 공백까지 태그로 된다 태그 속성은 괄호( ) 사용 SurveyInputBase.pug12345form div(class=\"form-group\") label(for=\"title\" class=\"form-label\") Title textarea(v-model.lazy=\"element.title\" class=\"form-control\" name=\"title\") block custom SurveyInputBase.vue (기본)DialogFormBase.vue12345678&lt;template lang=\"pug\"&gt; include SurveyInputBase.pug&lt;/template&gt;&lt;script&gt; export default &#123; props: [ 'question' ] &#125;&lt;/script&gt; SurveyInputText.vue (확장)SurveyInputText.vue123456789101112&lt;template lang=\"pug\"&gt; extends SurveyInputBase.pug block input input(type=\"text\" :placeholder=\"placeholder\")&lt;/template&gt;&lt;script&gt; import SurveyInputBase from './SurveyInputBase.vue'; export default &#123; extends: SurveyInputBase, props: [ 'placeholder' ], &#125;&lt;/script&gt; Mixins vue 구성요소에 재사용 가능한 기능을 넣는 방법 재사용 가능한 기능은 기존 기능과 병합 캡슐화 및 공통된 기능을 분리시켜 코드 재사용성을 높혀준다. 오버라이딩 기능도 사용할 수 있어 커스텀 및 확장에 용이하다. extends: 유사한 기능의 컴포넌트들을 추상화 하여 상위 컴포넌트를 만들고 차이가 있는 기능들을 하위 컴포넌트에 구현한다. mixins: 서로 다른 기능의 컴포넌트에 동일한 기능을 배포하는 방법으로 예를 들면 로깅 기능을 aspect 단위로 추가하는 것을 들 수 있다. 참고 url https://vuejsdevelopers.com/2017/06/11/vue-js-extending-components/","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"pug","slug":"pug","permalink":"http://apexsoft.github.io/tags/pug/"},{"name":"extends","slug":"extends","permalink":"http://apexsoft.github.io/tags/extends/"}]}]}