{"meta":{"title":"apexsoft 기술블로그","subtitle":"모두가 master가 되는 날 까지","description":null,"author":"HyoSook Kim","url":"http://apexsoft.github.io"},"pages":[],"posts":[{"title":"다국어처리","slug":"다국어 처리 적용하는 방법","date":"2018-02-23T06:58:20.621Z","updated":"2018-02-23T06:58:20.621Z","comments":true,"path":"2018/02/23/다국어 처리 적용하는 방법/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/다국어 처리 적용하는 방법/","excerpt":"","text":"다국어 처리 적용하는 방법en.js : 영문 번역본 파일ko.js : 한글 번역본 파일 파일위치 : resource/static/js/lang json 형태로 키값을 만들어주어야 함 영문과 한글 번역본의 키값은 동일해야 함 123456789&gt; var ko = &#123;&gt; message: &#123;&gt; hello: “안녕”&gt; &#125;,&gt; userid:&#123;&gt; required :\"필수입력\"&gt; &#125;&gt; &#125;;&gt; Freemarker 문구가 들어가는 부분에 ‘키값’ 맞춰서 작성 123456789&lt;body&gt; &lt;div id=’app’&gt; &#123;&#123; $t(“message.hello”) &#125;&#125; &lt;input name=\"userId\" v-bind:placeholder=$t(\"userid.required\") v-model=\"userId\"&gt; &lt;/div&gt;&lt;/body&gt; Javascript el: &#39;#app&#39; 아랫줄에 i18n: apex_lang 삽입 12345678910111213new Vue(&#123; el: '#app', i18n: apex_lang, data: &#123; userId: '', password: '' &#125;, methods: &#123; onSignIn: function() &#123; alert(apex_lang.t(‘message.hello’)); &#125; &#125;&#125;);","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"i18n","slug":"i18n","permalink":"http://apexsoft.github.io/tags/i18n/"}]},{"title":"webpack","slug":"webpack","date":"2018-02-23T06:58:20.621Z","updated":"2018-02-23T06:58:20.621Z","comments":true,"path":"2018/02/23/webpack/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/webpack/","excerpt":"","text":"모듈화1.스코프 (Scope) 모든 모듈은 자신만의 독립적인 실행 영역이 있어야 한다 전역변수와 지역변수를 분리하는 것이 중요 2. 정의 exports 객체 이용 3. 사용 모듈 사용은 require 함수 사용 webpack 모듈 번들러 의존성을 가진 모듈들을 다루고 , 그 모듈로부터 정적인 asset을 생성 하나의 파일로 js파일을 번들할수있다 작동 방법 하나의 파일을 진입점으로 지정 진입점 파일은 트리의 루트가 된다 require에 의해 다른 파일이 트리에 추가 된다 = require으로 명시된 의존성들을 해석하며 의존성 트리를 그린다 webpack명령을 실행하면 , 모든 파일과 모듈은 하나의 파일에 번들로 제공된다 로더 일종의 함수 마지막 로더는 최종적으로 적절하게 변형된 모듈을 번들 자바스크립트 파일에 넣어주게 된다 ex) css 파일 require 하는 경우 css 파일을 그대로 자바스크립트에 넣을수 없으니 , 원래의 css파일과 같은 역활을 할 수 있는 자바스크립트 형태의 무언가를 만들어야 최종 번들에 해당 내용을 포함시킬수 있다. 이 과정을 일련의 로더 파이프라인이 수행 모듈 번들링 모듈간의 의존성을 해석하고 , 그걸 바탕으로 정적 에셋을 만드는 과정 모듈 번들러 모듈 번들링을 하는 친구 ex ) webpack 거대한 파일들을 여러 파일로 나눠 쓸수있게 해준다. ​ ​ webpack.config.js webpack을 설정한다 12345678910111213var path = require('path')module.exports = &#123; entry: &#123; 'vuejs-test2': path.join(__dirname, '/src/vuejs-test2.js'), 'draggabletest': path.join(__dirname, '/src/draggabletest.js') &#125;, output: &#123; path: path.join(__dirname, '../src/main/resources/static/js/bundles'), publicPath: '/js/bundles', filename: '[name].js' &#125;&#125; enty - 번들의 엔트리 포인트 . webpack은 여러 번들을 생성하는 진입점을 허용하기 때문에 배열이다 output - webpack의 최종 결과물이 되는 형태를 명시 path - 어디에 번들 파일을 위치 시킬 것인지를 지정 ( 빌드 결과물 들어갈 webpack.config.js로 부터의 상태 경로 ) publicPath - 웹사이트에서 해당 에셋에 접근하기 위해 필요한 경로 filename 각 번들 파일의 이름을 지정 [name] : entry에서의 key 값 webpack 명령을 실행하면 , bundles라는 폴더에 draggabletest.js vuejs-test2파일을 생성한다 webpack은 require 하고있는 파일들 모두 묶어 하나의 번들을 내놓게 된다 webpack 로더 require를 이용하여 , .css 와 .html .png등을 불러올수있다 ​ package.json npm 설정을 관리 이를 통해 모든 부품이 설치되어 돌아갈 수 있습니다. node-moules npm이 pakage들을 설치하는 디렉토리 폴더 모듈화1.스코프 (Scope) 모든 모듈은 자신만의 독립적인 실행 영역이 있어야 한다 전역변수와 지역변수를 분리하는 것이 중요 2. 정의 exports 객체 이용 3. 사용 모듈 사용은 require 함수 사용","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"node.js","slug":"node-js","permalink":"http://apexsoft.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://apexsoft.github.io/tags/npm/"}]},{"title":"Spring security config 예제","slug":"간결한 spring security configure","date":"2018-02-23T06:58:20.621Z","updated":"2018-02-23T06:58:20.621Z","comments":true,"path":"2018/02/23/간결한 spring security configure/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/간결한 spring security configure/","excerpt":"","text":"간결한 spring security configure123456789101112131415161718192021222324@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .antMatcher(\"/unreal/**\") .csrf()// .disable() .ignoringAntMatchers(\"/unreal/**\") .and() .formLogin() .loginProcessingUrl(\"/unreal/auth/login\") .usernameParameter(\"username\") .passwordParameter(\"password\") .successHandler(loginSuccessHandler()) .failureHandler(loginFailureHandler()) .and() .logout() .logoutRequestMatcher(new AntPathRequestMatcher(\"/unreal/logout\")) .logoutSuccessHandler(logoutSuccessHandler()) .and() .authorizeRequests() .antMatchers(\"/user/**\").hasRole(\"USER\") .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .anyRequest().permitAll();&#125;","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"Security","slug":"Security","permalink":"http://apexsoft.github.io/tags/Security/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://apexsoft.github.io/tags/SpringBoot/"}]},{"title":"vueRouter","slug":"라우터정리","date":"2018-02-23T06:58:20.621Z","updated":"2018-02-23T06:58:20.621Z","comments":true,"path":"2018/02/23/라우터정리/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/라우터정리/","excerpt":"","text":"라우터VueRouter 불러오기1234567891011import Vue from 'vue'# 이곳에 VueRouter를 불러옵니다.import VueRouter from 'vue-router'import Home from './components/Home' #사용할 컴포넌트 import Login from './components/Login' #사용할 컴포넌트 # Vue에 VueRouter를 연결합니다.Vue.use(VueRouter) 라우트 정의12345# 라우트 정의const routes = [ &#123; path: '/', name: 'home-page',component: Home &#125;, &#123; path: '/login', name: 'Login-page', component: Login &#125;] 라우터 인스턴스 생성12345#라우터 인스턴스 생성const router = new VueRouter(&#123; mode: 'history', // history 모드를 사용하면 주소창에 hash가 없어집니다. routes // routes: routes 의 약어&#125;) history mode를 사용하면 URI가 localhost/#/login에서 localhost/login으로 변경됩니다. 모르겠음아마도 …. 해당 router.js파일에 const들은 export 하는듯 ….. 12345export &#123; routes,&#125;;export default router; Vue 인스턴스에 라우터 마운트하기12345678import router, &#123; routes &#125; from './router';new Vue(&#123; store, router, #이 부분을 추가합니다. el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;&#125;).$mount('#app') #이 부분도요 App 컴포넌트에 라우트 컴포넌트 불러오기12345&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; App.vue 컴포넌트에&lt;router-view&gt;&lt;/router-view&gt;를 추가합니다. 이제 라우팅을 통해 연결한 컴포넌트가 router-view 영역에 렌더링 됩니다. 이제 빌드해보면 에러가 납니다. main.js에 불러왔던 컴포넌트를 App.vue 컴포넌트에도 불러와야 합니다. 12345678910111213141516171819202122&lt;script&gt;import Home from './components/Home' // 추가해주세요.import Login from './components/Login' // 추가해주세요.export default &#123; name: 'app', components: &#123; Home, // 추가해주세요. Login // 추가해주세요. &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;ul class=\"navigation\"&gt; &lt;li&gt;&lt;router-link v-bind:to=\"&#123; name: 'home-page' &#125;\"&gt;Home&lt;/router-link&gt;&lt;/li&gt; &lt;li&gt;&lt;router-link v-bind:to=\"&#123; name: 'Login-page-page' &#125;\"&gt;Counter&lt;/router-link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"}]},{"title":"REDIS","slug":"Redis","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/Redis/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/Redis/","excerpt":"","text":"REDIS (REmote DIctionary Server)key/Value Store in memory key value database key/value 저장소 특정 키 값에 값을 저장하는 구조 메모리에 데이터를 저장 빠른 read /write 속도 전체적인 저장 가능한 데이터의 용량은 물리적인 용량을 넘을수 없음 RDB나 NoSQL이 기본적으로 file system에 데이터 저장 ​ 유용 사례 최신 랭킹이 필요한 경우 많은 데이터 필요 x , 빠른 처리만 필요 최신 데이터 간의 비교, 차이계산 경우 최근에 이직 신청을 한 다음 직원은? ​ 저장 구조 in-mamory + hard disk 빠른데 + 복구도 가능 Pub/Sub Model 분산 처리 Replication Topology(Master-Slave &lt;- Query Off Loading, Sharding) read/write 성능 향상 ​ 저장 형태 다양한 data set 제공 다양한 집합set 연산 가능 -&gt; 데이터 저장 키 값에 다양한 데이터 타입을 매핑 시킬수 있음 다양한 테이터 타입을 지원 복잡한 구조를 저장 가능​ 관리 정책Persistence(지속성) disk에 저장 가능, shutdown 후에도 데이터 보존 가능 서버가 shutdown된 후 restart되더라도, disk에 저장해놓은 데이타를 다시 읽어서 메모리에 Loading 데이터 저장 방식 RDB[snapshotting] 순간적으로 메모리에 있는 내용을 DISK에 전체를 옮겨 담는 방식 AOF[Append On File] 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태이다 Expiation 데이터 유효기간 설정 가능 (데이터 생명주기를 정해서 일정 시간이 지나면 자동으로 삭제 되게 한다) 내부 정책 Active 데이터 접근할 때 유효기간 체크 passive 주기적으로 키를 100개 랜덤 뽑아 체크 랜덤이라 체크 안된 garbage 잔존가능 expired time이 지난 후 클라이언트에 의해서 접근 되지 않은 데이타는 Active 방식으로 인해서 지워지지 않고 Passive 방식으로 지워져야 하는데, 이 경우 Passive 방식의 경우 전체 데이타를 scan하는 것이 아니기 때문에 ​","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"spring security","slug":"Spring Security","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/Spring Security/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/Spring Security/","excerpt":"","text":"1. build.gradle1compile('org.springframework.boot:spring-boot-starter-security') 2. DB, Domain에 USER와 ROLE 필요 User java12345678910111213141516171819202122232425262728293031@Entity@Table(name = \"USER\")@Getter @Setter@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")public class User extends AbstractBaseEntity implements Serializable &#123; @Id @GeneratedValue @Column(name = \"user_id\") private Long id; @NotNull @Column(name = \"user_name\", unique = true) @Size(min = 8) private String userName; @NotNull @Column(name = \"password\") @Size(min = 8) private String password; @Column(name = \"email\") private String email; @ManyToMany @JoinTable(name = \"user_role\", joinColumns = @JoinColumn(name = \"user_id\"), inverseJoinColumns = @JoinColumn(name = \"role_id\")) private Set&lt;Role&gt; roles;&#125; Role java1234567891011121314151617181920212223@Entity@Table(name = \"role\")@Getter @Setter@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")public class Role extends AbstractBaseEntity implements Serializable &#123; @Id @GeneratedValue private Long id; @NonNull private String name; public Role() &#123; &#125; public Role(String name) &#123; this.name = name; &#125; @ManyToMany(mappedBy = \"roles\") private Set&lt;User&gt; users;&#125; 3. UserServiceDetailImpl 생성UserDetailService를 구현해야만 Spring Security가 정상적으로 조회 가능 InMemoryAuthentication설정이 없다면 기본적으로 UserDetailsService구현 객체를 찾아 로그인 요청시 이용한다. InMemoryAuthentication설정이 있으면, UserDetailsService구현 객체가 있어도 해당 흐름을 타지 않는다. java123456789101112131415161718192021222324@Service@RequiredArgsConstructor(onConstructor = @__(@Autowired))public class UserServiceDetailImpl implements UserDetailsService &#123; @NonNull private final UserRepository userRepository; @Override @Transactional(readOnly = true) public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = this.userRepository .findByUserName(username) .orElseThrow(() -&gt; new UsernameNotFoundException(\"사용자 이름을 찾을 수 없습니다.\")); Set&lt;GrantedAuthority&gt; grantedAuthorities = new HashSet&lt;&gt;(); for (Role role: user.getRoles()) &#123; grantedAuthorities.add(new SimpleGrantedAuthority(role.getName())); &#125; return new org.springframework.security.core.userdetails.User(user.getUserName(), user.getPassword(), grantedAuthorities); &#125;&#125; loadUserByUsername메소드를 반드시 구현해야한다. 스프링시큐리티에서 User 정보를 읽을 때 사용된다. User를 읽어왔으면 권한을 부여해준다. 4. 비밀번호 암호화비밀번호 뿐만 아니라 개인 식별정보는 필히 암호화를 거쳐 저장하여야 한다.암호화는 BCrypt 방식을 이용하며 Spring에서 기본적으로 제공되는 클래스는 BCryptPasswordEncoder 이다.passwordEncoder 라는 이름의 빈으로 등록하면 자동으로 적용된다. java1234@Beanpublic BCryptPasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder();&#125; 회원가입 시 패스워드를 DB에 저장할때는 PasswordEncoder 를 통해 암호화하는 로직을 필히 명시해줘야 한다. java12345678910111213141516@Servicepublic class UserServiceImpl implements UserService &#123; @NonNull private final BCryptPasswordEncoder bCryptPasswordEncoder; @Override public User saveUserUser(User user) &#123; user.setPassword(bCryptPasswordEncoder.encode(user.getPassword())); if (Objects.isNull(user.getRoles()) || user.getRoles().isEmpty()) &#123; Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); roles.add(roleRepository.findByName(\"ROLE_USER\") .orElseThrow(() -&gt; new IllegalStateException(\"ROLE is not set\"))); user.setRoles(roles); &#125; return this.userRepository.save(user); &#125;&#125; 5. 로그인1) WebSecurityConfig.java &gt; 로그인 관련 부분java123456789101112.formLogin() .loginPage(\"/user/view/membership/sign-in\") .loginProcessingUrl(\"/user/auth/login\") .usernameParameter(\"userName\") .passwordParameter(\"password\") .successHandler(loginSuccessHandler()) .failureHandler(loginFailureHandler()) .permitAll().and().logout() .logoutRequestMatcher(new AntPathRequestMatcher(\"/user/auth/logout\")) .logoutSuccessHandler(logoutSuccessHandler()) .loginPage(&quot;/user/view/membership/sign-in&quot;) : 로그인 페이지 지정 .loginProcessingUrl(&quot;/user/auth/login&quot;) 로그인을 수행하는 url 지정 해당 url controller를 별도로 지정하지 않음 UserDetailService 구현부분을 찾아서 로그인을 수행함 .usernameParameter(&quot;userName&quot;) : User 도메인 내 아이디 변수를 그대로 작성 .passwordParameter(&quot;password&quot;) : User 도메인 내 비밀번호 변수를 그대로 작성 .successHandler(loginSuccessHandler()) : 로그인 성공핸들러, 대부분 url을 리다이렉트 함 .failureHandler(loginFailureHandler()) : 로그인 실패 핸들러, 대부분 url을 리다이렉트 함 .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/user/auth/logout&quot;)) : method를 지정할 수 있기 때문에 csrf를 적용하고, get을 이용하는 경우에 사용 .logoutSuccessHandler(logoutSuccessHandler()) : 로그아웃 핸들러, 대부분 url을 리다이렉트 함 RestLoginSuccessHandler java12345678910public class RestLoginSuccessHandler extends SimpleUrlAuthenticationSuccessHandler &#123; Logger logger = LoggerFactory.getLogger(RestLoginSuccessHandler.class); @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; logger.info(\"로그인 성공\"); response.sendRedirect(\"/\"); &#125;&#125; RestLoginFailureHandler java1234567891011121314public class RestLoginFailureHandler implements AuthenticationFailureHandler &#123; Logger logger = LoggerFactory.getLogger(RestLoginFailureHandler.class); @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; int cuase=0; if(exception.getClass().equals(BadCredentialsException.class))&#123; cuase=1; &#125; logger.info(\"로그인 실패\"); response.sendRedirect(\"/?cause=\"+cuase); &#125;&#125; RestLogoutSuccessHandler java123456789101112public class RestLogoutSuccessHandler extends SimpleUrlLogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; String targetUrl = determineTargetUrl(request, response); if (response.isCommitted()) &#123; logger.debug(\"Response has already been committed. Unable to redirect to \" + targetUrl); &#125; logger.info(\"로그아웃 성공\"); response.sendRedirect(\"/\"); &#125;&#125; 2) 로그인 화면 sign-in.ftl html123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;div class=\"text-center\"&gt; &lt;h1&gt;로그인&lt;/h1&gt; &lt;form class=\"pure-form pure-form-aligned\" id=\"form-login\"&gt; &lt;fieldset&gt; &lt;div class=\"pure-control-group\"&gt; &lt;label for=\"userName\"&gt;UserName&lt;/label&gt; &lt;input name=\"userName\" v-model=\"userName\" id=\"userName\" class=\"pure-input-1-3\" value=\"\" placeholder=\"UserName\" type=\"text\"&gt; &lt;/div&gt; &lt;div class=\"pure-control-group\"&gt; &lt;label for=\"password1\"&gt;Password&lt;/label&gt; &lt;input name=\"password\" v-model=\"password1\" id=\"password1\" class=\"pure-input-1-3\" value=\"\" placeholder=\"Password\" type=\"password\"&gt; &lt;/div&gt; &lt;div class=\"pure-controls\"&gt; &lt;button class=\"pure-button pure-button-primary pure-u-1-3\" @click.prevent=\"onSignIn()\"&gt;로그인 &lt;/button&gt; &lt;/div&gt; &lt;input type=\"hidden\" name=\"$&#123;_csrf.parameterName&#125;\" value=\"$&#123;_csrf.token&#125;\"/&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; sign-in.js vue.js123456789101112131415161718new Vue(&#123; el: '#app', i18n: apex_lang, data: &#123; userName: '', password1: '', &#125;, methods: &#123; onSignIn() &#123; console.log('onSignIn'); let form = document.getElementById(\"form-login\"); form.method = 'post'; form.action = '/user/auth/login'; form.submit(); &#125; &#125;&#125;); .loginProcessingUrl(&quot;/user/auth/login&quot;) 시큐리티 설정시, 지정했던 url과 동일한 url을 사용 6. 계정 만료 및 잠금에 의한 로그인 실패처리loadUserByUsername 메소드의 반환값은 UserDetails 타입이다. org.springframework.security.core.userdetails.User java1234567private String password;private final String username;private final Set&lt;GrantedAuthority&gt; authorities;private final boolean accountNonExpired;private final boolean accountNonLocked;private final boolean credentialsNonExpired;private final boolean enabled;","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"springboot","slug":"springboot","permalink":"http://apexsoft.github.io/tags/springboot/"},{"name":"security","slug":"security","permalink":"http://apexsoft.github.io/tags/security/"}]},{"title":"node.js? npm? cdn? 사용하기","slug":"nodjs","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/nodjs/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/nodjs/","excerpt":"","text":"javascript 사용1. CDN https://unpkg.com/#/ OR https://www.npmjs.com/ dist 폴더 , 다른이름으로 링크주소 복사 &lt;script &gt; 주소 &lt;/script&gt; 2.npm git 다운 npm run bundle or yarn bundle dist 폴더 , 생성된 물리적 파일 원하는 프로젝트에 옮기기 webpack ? 모듈 번들러 의존성을 가진 모듈들을 다루고 , 그 모듈로부터 정적인 asset을 생성 작동 방법 하나의 파일을 진입점으로 지정 진입점 파일은 트리의 루트가 된다 require에 의해 다른 파일이 트리에 추가 된다 = require으로 명시된 의존성들을 해석하며 의존성 트리를 그린다 webpack명령을 실행하면 , 모든 파일과 모듈은 하나의 파일에 번들로 제공된다 모듈 번들링 모듈간의 의존성을 해석하고 , 그걸 바탕으로 정적 에셋을 만드는 과정 모듈 번들러 모듈 번들링을 하는 친구 ex ) webpack 거대한 파일들을 여러 파일로 나눠 쓸수있게 해준다. ​ webpack-dev-server 메모리에 bundle 파일을 올려 놓고 변경이 있을때 마다 , live reload를 시킨다 webPack.dev.config.js webpack-dev-server가 사용할 환경설정에 대해 정의 devServer host : localhost 모든 ip를 사용하는 경우 0.0.0.0사용 port : 8080 접속 포트 설정 proxy : {‘**’ :”http://localhost:8001&quot;} 프록시 설정 , Springboot 실행되는 url 12345axios .get(`http://localhost:8001/tester/api/proto/ans/ask/$&#123;this.askNo&#125;`) .then((res) =&gt; &#123; &#125; &#125;); ​ 12345axios.get(`/tester/api/proto/ans/ask/$&#123;this.askNo&#125;`).then((res) =&gt; &#123; &#125;&#125;); 실행 bash123456#package.json에 정의된 모듈 설치(node_modules에 다운로드)npm install#webpack -dev-server 구동npm run dev npm run명령 뒤의 스크립트 명(dev)는 pakage.json에 정의 되어있다 package.json npm 설정을 관리 이를 통해 모든 부품이 설치되어 돌아갈 수 있습니다. devDependencies lint 코딩 룰에 위배되는거 체크 해준다 pug babel Babel은 Transform Compiler이다. 보통 TypeScript, CoffeeScript 같은 Javascript 문법이 아닌 각각의 문법으로 작성된 코드를 Javascript 엔진에서 동작 가능한 코드로 변환하는 역할 ES6 -&gt; ES5 transpiler loader 일종의 함수 마지막 로더는 최종적으로 적절하게 변형된 모듈을 번들 자바스크립트 파일에 넣어주게 된다 ex) css 파일 require 하는 경우 css 파일을 그대로 자바스크립트에 넣을수 없으니 , 원래의 css파일과 같은 역활을 할 수 있는 자바스크립트 형태의 무언가를 만들어야 최종 번들에 해당 내용을 포함시킬수 있다. 이 과정을 일련의 로더 파이프라인이 수행 webpack.config.js webpack을 설정한다 12345678910111213var path = require('path')module.exports = &#123; entry: &#123; 'vuejs-test2': path.join(__dirname, '/src/vuejs-test2.js'), 'draggabletest': path.join(__dirname, '/src/draggabletest.js') &#125;, output: &#123; path: path.join(__dirname, '../src/main/resources/static/js/bundles'), publicPath: '/js/bundles', filename: '[name].js' &#125;&#125; enty - 번들의 엔트리 포인트 . webpack은 여러 번들을 생성하는 진입점을 허용하기 때문에 배열이다 output - webpack의 최종 결과물이 되는 형태를 명시 path - 어디에 번들 파일을 위치 시킬 것인지를 지정 ( 빌드 결과물 들어갈 webpack.config.js로 부터의 상태 경로 ) publicPath - 웹사이트에서 해당 에셋에 접근하기 위해 필요한 경로 filename 각 번들 파일의 이름을 지정 [name] : entry에서의 key 값 Loader - Loader는 사전에 처리할 작업을 나타내며 css, html, jpg, scss 등의 자산을 하나의 모듈로 취급하며 이러한 파일들을 종속성 그래프에 추가할 때 모듈로 변환한다. Plug-In - Plug-In은 일반적인 Compile 또는 모듈 처리에 필요한 작업 및 사용자 정의 기능을 수행하는데 사용한다. webpack 명령을 실행하면 , bundles라는 폴더에 draggabletest.js vuejs-test2파일을 생성한다 webpack은 require 하고있는 파일들 모두 묶어 하나의 번들을 내놓게 된다 node-moules npm이 pakage들을 설치하는 디렉토리 폴더 사용설치 node.js 설치 https://nodejs.org/en/download/current/ yarn 설치 npm install -g yarn -g는 글로벌 옵션 Plugins 설치 (선택) vue.js pug 실행 package.json에 정의된 모듈 설치 npm install 주입 후 빌드 refresh webpack -dev-server 구동 npm run dev springboot 서버 실행 시큐리티 설정에 걸리는 경우 , 해당 url .permitAll() 하기 ​ 옮기기 npm run bundle dist 밑에 생기는 파일 복사해서 붙여 넣는다 기타lint 코딩룰 체크 설치 yarn 설치 npm install -g yarn lint 설치 npm install -g eslint pakage.json &gt;&gt; devDependencies &gt;&gt; 추가 사용 rule 확인 + fix yarn lint --fix .eslintrc.js rule 정의","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"node.js","slug":"node-js","permalink":"http://apexsoft.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://apexsoft.github.io/tags/npm/"}]},{"title":"JPA 개념","slug":"JPA 큼직한 개념","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/JPA 큼직한 개념/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/JPA 큼직한 개념/","excerpt":"","text":"HibernateEJB 엔티티빈 기술을 대체 오픈소스 ORM 프레임워크 JPA (Java Persistence API)EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술표준 (JPA를 하이버네이트로 구현) 자바애플리케이션과 JDBC 사이에서 동작 테이블을 객체 지향적으로 만들어서 사용 (상속이 가능함) 제공하는 기능 (대분류) 엔티티와 테이블을 매핑하는 설계 부분 매핑한 엔티티를 실제 사용하는 부분 장점 생산성 향상 : SQL 작성하고, JDBC api 사용하는 반복적인 일들을 대신 처리해줌. ​ 나아가서 DDL 문을 자동으로 생성해주는 기능도 있음. 유지보수 궁금증Q. 매우 복잡한 SQL은 어떻게 하나요? A.통계와 같은 복잡한 쿼리는 SQL 작성이 더 쉬울수도. 마이바티스나 다른 SQL 매퍼 형태의 프레임워크를 혼용할 수도 있음. Q. 하이버네이트 사용? A. 국내에서 유독 마이바티스를 많이 사용. 전 세계적으로 조사하면 하이버네이트 프레임워크 사용 비중이 더 높음. JPQL엔티티 객체를 조회하는 객체지향 쿼리 네이티브 SQLJPQL을 사용해도 특정 데이터베이스에 의존하는 기능 (예: 오라클/MySQL만의 기능) 을 지원 스프링 데이터 JPA스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트. Repository를 개발할 때 인터페이스만 작성하면 실행 시점에서 스프링 데이터가 JPA가 구현 객체를 동적으로 생성해서 주입해줌. (데이터 접근 객체 구현 시, 구현 클래스 없이 인터페이스만 작성) 책에서 JpaRepository&lt;(객체), (데이터타입)&gt;을 상속 받아서 사용하라고 함. 쇼핑몰 프로젝트에서 모든 Repository는 CrudRepository&lt;(객체), (데이터타입)&gt;을 상속 받음 CrudRepository&lt;(객체), (데이터타입)&gt; : 스프링 데이터 프로젝트가 공통으로 사용하는 인터페이스 JpaRepository&lt;(객체), (데이터타입)&gt; : 스프링 데이터 프로젝트 인터페이스에 JPA 특화된 기능들을 제공 위 인터페이스들을 상속 받아 Repository를 구현하면 엔티티를 제어하는 주요 메소드들을 구현 클래스 작성 없이 사용 가능. 특정 조건에 만족하는 쿼리 수행하는 방법 쿼리를 유추할 수 있는 메소드 이름을 통해 쿼리를 정의. 메소드 이름 규칙 : findBy + (조건 필드이름) + (And) / (Or) java123public interface UserRepository extends Repository&lt;User, Long&gt; &#123; List&lt;User&gt; findByEmailAddressAndLastname(String emailAddress, String lastname);&#125; 쿼리 메소드 기능스프링 데이터 JPA가 제공하는 기능 대표적인 기능은 메소드 이름만으로 쿼리를 생성하는 기능. Repository 인터페이스에서 메소드만 선언하면 해당 메소드 이름(정해진 규칙에 따라 메소드 이름을 지어야 함)으로 적절한 JPQL 쿼리를 생성하여 실행. 쇼핑몰 프로젝트 내 해당 부분 java12345@Repositorypublic interface CartItemRepository extends CrudRepository&lt;CartItem, CartItemId&gt; &#123; List&lt;CartItem&gt; findCartItemsByCart(Cart cart);&#125; 그 외 다양한 기능들 포함함. 엔티티의 생명주기 비 영속 : 엔티티를 new 한 시점 영속 : 엔티티를 new 한 후 persist(삽입), find(조회), query 메소드를 사용하여 저장, 조회한 경우 삭제 : 영속 객체를 remove 메소드로 삭제한 경우 준 영속 : 트랜잭션이 commit되었거나 clear, flush 메소드가 실행된 경우. 이걸 다시 영속 객체 상태로 만들기 위한 merge 메소드가 존재함. 영속성 컨텍스트Entity Manager가 엔티티들을 관리할 때 이곳에 보관하고 관리함. 관리되는 모든 엔티티 인스턴스의 집합. EntityManager엔티티의 생명주기, 영속성 컨텍스트, 트랜잭션을 관리함 EntityManagerFactoryEntityManager를 관리","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"}]},{"title":"promise","slug":"promise","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/promise/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/promise/","excerpt":"","text":"promise 비동기 동작의 흐름을 제어할 때 사용 JavaScript ES6에 추가 아직은 아니지만 나중에 완료될 것으로 기대 되는 연산을 의미 async(비동기)연산에서 사용 Promise object는 new를 통해 initiate될 수 있으며, 함수를 패스받을 수 있다. 이 함수에는 resolve, reject함수가 매개변수로 차례로 들어가있다. javascript1234567891011121314151617function task(resolve, reject) &#123; console.log('task start'); setTimeout(function() &#123; console.log('task end'); resolve('task success'); &#125;, 300);&#125;function resolveed(result) &#123; console.log('resolve : '+result);&#125;function rejected(err) &#123; console.log('rejected : ', err);&#125;new Promise(task).then(resolveed, rejected); promise 이후의 동작 : then 성공과 실패일 때 각각 콜백처리 한다 resolve promise가 성공적으로 종료될 때 promise의 뒤에 따라오는 then의 콜백에 arg로 사용될 value를 넘겨받을 수 있다. reject promise에서 에러가 발견된 경우, 혹은 조건에 맞지 않아 에러를 발생시켜야 하는 경우 호출 promise의 메서드인 catch안에 들어간다. 보통 resolve는 error의 이유가 들어간다 123456789101112let func = function(resolve)&#123; resolve();&#125;;let promise1 =new Promise(func);promise1.then(()=&gt;alert('resolve1'));let promise =new Promise((resolve,reject)=&gt;&#123; reject(); &#125;);promise.then(()=&gt;alert('resolve'));promise.catch(()=&gt;alert('reject')); https://jsbin.com/nusaxemero/2/edit?html,js,console,output","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"ES6","slug":"ES6","permalink":"http://apexsoft.github.io/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://apexsoft.github.io/tags/javascript/"}]},{"title":"v-cloak","slug":"v-cloak","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/v-cloak/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/v-cloak/","excerpt":"","text":"v-cloak실행될때, 머스태쉬 태그들이 짧은 순간 동안 깜박거리는 현상이 존재. 자바스크립트 코드가 실행되기 전이기 때문에. v-cloak 을 사용하면 html 코드를 숨길 수 있다. html123&lt;div id=\"app\" v-cloak&gt; ..&lt;/div&gt; css 123[v-cloak] &#123; display: none;&#125;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"}]},{"title":"vee-validate","slug":"vee-validate","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/vee-validate/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/vee-validate/","excerpt":"","text":"몇가지 사전 체크사항&lt;label&gt;, &lt;input&gt; and id, name attribute &lt;label for=&quot;&quot;&gt;의 대상은 input의 id VeeValidate에서 validation 대상은 input의 name으로 errors.has(&#39;name&#39;)와 같이 사용 그러므로 input은 id, name을 모두 명시해 주는 것이 좋음 Migrating to Bootstrap 4Form Grouplabel과 input을 한 줄에 배치하려면 class에 &quot;row&quot;를 추가 Labelcontrol-label은 더이상 사용 불가능하며 오른쪽 정렬도 해주지 않음 col-form-label을 사용하고 정렬은 text-*를 사용 html1&lt;label for=\"username\" class=\"col-form-label text-right\"&gt;아이디&lt;/label&gt; Inputform-control을 필히 명시 validation에 대한 bootstrap 클래스는 is-invalid | is-valid html1&lt;input id=\"username\" class=\"form-control is-invalid\"&gt; &lt;!--invalid인 경우--&gt; vee-validatevue에서 validation 수행을 도와준다. 공식사이트 : http://vee-validate.logaretm.com/ 사용방법htmlhtml1234567&lt;!-- 기본 vue.js --&gt;&lt;script src=\"https://unpkg.com/vue\"&gt;&lt;/script&gt;&lt;!--vee validate--&gt;&lt;script src=\"https://unpkg.com/vee-validate@2.0.0-rc.13\"&gt;&lt;/script&gt;&lt;script&gt; Vue.use(VeeValidate);&lt;/script&gt; 기본 validate 설정html123&lt;input v-validate=\"'required|email'\" :class=\"&#123;'input': true, 'is-danger': errors.has('email') &#125;\" name=\"email\" type=\"text\" placeholder=\"Email\"&gt; 에러메세지 출력html12345&lt;div class=\"has-icon has-icon-right\"&gt; &lt;i v-show=\"errors.has('email')\" class=\"fa fa-warning\"&gt;&lt;/i&gt; &lt;span v-show=\"errors.has('email')\" class=\"invalid-feedback\"&gt;&#123;&#123; errors.first('email') &#125;&#125;&lt;/span&gt;&lt;/div&gt; fa, fa-warning으로 아이콘 출력 가능 (icons 참조) 아이콘을 input과 함께 표시해주기 위해 div에 has-icon 클래스를 추가 해당 클래스에 대한 스타일은 vee-validate 예제 페이지를 참조하여 apex-web-base.css에 추가 속성v-validate v-validate 속성에 rule 을 지정 여러가지 rule 입력 가능 html12&lt;input v-validate=\"'required|min:6|max:16'\"&gt; // 1&lt;input v-validate=\"&#123; rules: &#123; required: true, min:6, max:16&#125;&#125;\"&gt; // 2 1방법에서 rule을 여러개 입력하는 경우, 반드시 큰 따옴표 안에 작은 따옴표로 감싸준다. 주요 v-validate 값 예제 : https://jsbin.com/siqodemose/4/edit?html,js,output ​ (이메일, 비밀번호(대,소문자,특수문자), 전화번호, 웹사이트) v-bind:class class를 동적 바인딩 errors.has(&#39;field&#39;)로 해당 필드에 에러가 있는지 판단 html12&lt;input v-validate=\"'required|email'\" :class=\"&#123;'form-control': true, 'is-invalid': errors.has('userId')&#125;\" Rendering Errors : errors를 통해 에러가 있는지, 어떤 에러인지 알아 볼 수 있다. has(&#39;field&#39;): 해당 필드에 에러가 있는지 first(&#39;field&#39;): 해당 필드의 첫번째 에러 메시지 가져오기 all(): 해당 필드의 모든 에러 메시지 가져오기 collect(&#39;field&#39;): any(): 경고 메시지 커스텀Vue 생성시 Dictionary를 변경 vue.js12345678910111213141516171819202122created() &#123; let dict = &#123; en: &#123; custom: &#123; userId: &#123; required: () =&gt; 'User ID is empty.', email: () =&gt; 'User ID must be email.' &#125; &#125; &#125;, ko: &#123; custom: &#123; userId: &#123; required: () =&gt; '아이디가 비어 있습니다.', email: () =&gt; '아이디는 email 형태여야 합니다.' &#125; &#125; &#125; &#125; this.$validator.setLocale('ko'); this.$validator.updateDictionary(dict);&#125;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"}]},{"title":"Drag and drop","slug":"Drag and drop 컴포넌트","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/Drag and drop 컴포넌트/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/Drag and drop 컴포넌트/","excerpt":"","text":"Drag and dropSortablehttps://github.com/RubaXa/Sortable Sortable을 vue component로 만든 Draggablehttps://github.com/SortableJS/Vue.DraggableDraggable 직접 구현한 예제 https://codepen.io/anon/pen/dzvzGy?editors=1010 html1234567891011121314&lt;head&gt; &lt;!-- CDNJS :: Sortable (https://cdnjs.com/) --&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/Sortable/1.6.0/Sortable.min.js\"&gt;&lt;/script&gt; &lt;!-- CDNJS :: Vue.Draggable (https://cdnjs.com/) --&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/Vue.Draggable/2.14.1/vuedraggable.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;draggable v-model=\"list2\" class=\"dragArea\" :options=\"secondOption\"&gt; &lt;div v-for=\"(element, index) in list2\" :key=\"index\"&gt;&#123;&#123;element.name&#125;&#125; &lt;button @click=\"remove(index)\"&gt;remove&lt;/button&gt; &lt;/div&gt; &lt;/draggable&gt;&lt;/body&gt; vue.js123456789101112131415...data: &#123; firstOption: &#123; group: &#123; name: 'people', pull: 'clone', put: false &#125;, sort: false &#125;, secondOption: &#123; group: 'people' &#125;&#125;... option 속성 속성명 자세한 속성 내용 pull false 선택하여 이동하는 드래그앤드롭 안됨 true 선택한 객체를 드래그앤드롭으로 이동 clone 선택한 객체가 복사되어 드래그앤드롭 가능 put false 드래그로 들어온 객체를 현재 목록에 드롭시키지 못함 true 드래그로 들어온 객체를 현재 목록에 드롭시킬 수 있음 array [foo, boo] sort true 현재 선택한 객체를 현재 리스트 안에서 드래그앤드롭으로 정렬할 수 있음 false 현재 선택한 객체를 현재 리스트 안에서 드래그앤드롭으로 정렬할 수 없음","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"}]},{"title":"JPA 엔티티 구성","slug":"JPA 엔티티 구성","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/JPA 엔티티 구성/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/JPA 엔티티 구성/","excerpt":"","text":"JPA 엔티티 구성쇼핑몰 소스/중요도 위주로 작성함 레퍼런스@Entity테이블과 매핑할 클래스는 필수로 붙혀야 함 @Table엔티티와 매핑할 테이블을 지정 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용. name : 매핑할 테이블 이름 @Id기본키 직접 할당 @GeneratedValue@Column객체 필드를 테이블 컬럼에 매핑 name : 필드와 매핑할 테이블의 컬럼 이름. 기본값이 필드 이름 12@Column(name = \"cart_id\")private Long id; columnDefinition : 데이터베이스 컬럼 정보를 직접 설정. nullable : null 값 허용 여부 false일 경우, not null 제약조건이 됨. 기본값이 true @JoinColumn관계를 나타낼 때 사용. 외래 키를 매핑할 때 사용. name : 매핑할 외래 키 이름 @JsonIdentityInfo? @RequiredArgsConstructor생성자를 자동으로 만들어주고, 옵션에 따라 null 체크도 해줌 엔티티 관계 설정 (관계를 가진 엔티티끼리 조인할 때 사용)@ManyToOne다대일 관계 설정에서 사용 fetch : 글로벌 페치 전략을 설정 FetchType.EAGER : 관계된 엔티티의 정보를 미리 읽어오는 것 FetchType.LAZY : 관계된 엔티티의 정보를 실제 요청하는 순간 가져오는 것 1234567public class CartItem extends BaseEntity implements Serializable &#123; .. @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"cart_id\") private Cart cart; ..&#125; @OneToMany일대다 관계 설정에서 사용 mappedBy : 양방향 관계 설정시 관계의 주체가 되는 쪽에서 정의 fetch : 관계 엔티티의 데이터 읽기 전략을 결정. FetchType.EAGER : 관계된 엔티티의 정보를 미리 읽어오는 것 FetchType.LAZY : 관계된 엔티티의 정보를 실제 요청하는 순간 가져오는 것 1234567public class Cart extends BaseEntity implements Serializable &#123; .. @OneToMany(mappedBy = \"cart\", fetch = FetchType.EAGER) @OrderBy(\"created_at asc\") private List&lt;CartItem&gt; cartItems; ..&#125; @ManyToOne과 @OneToMany 두가지가 크게 다르지 않음. 어느쪽을 기준으로 작성하느냐에 따라 다름 JPA는 다양한 쿼리 방법을 지원 JPQL JPA Criteria QueryDSL 네이티브 SQL JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께 사용 JPQL로 쿼리 사용SQL과 유사한 문법을 가지는 쿼리. 엔티티 객체를 대상으로 쿼리 두 개의 엔티티를 조인해야 하는 경우, 이런 방법을 쓰는 것 같음. java12345EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"(db정보가 들어갈 듯?)\");EntityManager em = emf.createEntityManager();String jpql = \"select m from Member as m where m.username = 'kim'\";List&lt;Member&gt; resultList = em.createQuery(jpql, Member.class).getResultList(); 실제 실행된 쿼리 sql123456789select member.id as id, member.age as age member.team_id as team, member.name as namefrom Member memberwhere member.name = 'kim'","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"}]},{"title":"블로그 만들기","slug":"Github page와 Hexo 이용, 기술 블로그 만들기","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/Github page와 Hexo 이용, 기술 블로그 만들기/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/Github page와 Hexo 이용, 기술 블로그 만들기/","excerpt":"","text":"Github page와 Hexo 이용, 기술 블로그 만들기Git Page1. Github Repository 생성 https://github.com/ New Repository, Repository 이름은 USERNAME.github.io USERNAME 은 Github의 가입시에 사용자의 username을 입력한다 Public / Private 중 Public 선택 Create Repository 버튼을 통해 Repository 생성 확인 - https://USERNAME.github.io Hexo Hexo는 Jekyll와 함께 대표적으로 정적 페이지를 쉽게 만들 수 있도록 도와주는 서비스이다.Hexo의 경우에는 npm을 통해 쉽게 설치가 가능하고 한 줄의 Command Line을 통해 Github에 바로 배포다양한 플러그인과 테마를 지원하고 있다 1. 다운로드 Node.js Git 2. 설치 Hexo node.js1$ npm install -g hexo -cli git node.js1$ npm install hexo-deployer-git --save 3. 블로그 생성bash 123$ hexo init [폴더명]$ cd [폴더명]$ npm install 4. 설정파일 ( _config.yml ) 수정 root 디렉토리에 _config.yml 파일로, 블로그에 대한 설정 한다 문서 - https://hexo.io/docs/ 기본 설정 site 정보 _config.yml1234title: apexsoft 기술블로그 subtitle: 우리모두 masterdescription:author: Hyosook Kim ​ URL 정보 _config.yml1234url: http://apexsoft.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults: ​ Github 정보 _config.yml1234deploy: type: git repo : https://github.com/ApexSoft/apexsoft.github.com.git branch : master 테마 적용 테마 선택 - https://hexo.io/themes/ git clone bash12# hexo [폴더/themes]에 다운$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman _config.yml` theme 수정 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: hueman #폴더명과 매칭되어야한다 검색 기능 (Insight earch)를 이용하기 위해서는 hexo-generator-json-content를 설치 bash1npm install -S hexo-generator-json-content 테마 폴더 안에 있는 _config.yml.example의 이름을_config.yml로 수정 clean bash1$ hexo clean ​ http://futurecreator.github.io/2016/06/14/hexo-apply-hueman-theme/ 5. 포스트 작성 새 포스트 만들기 bash1$ hexo new post [post_name] or 123ㄴ source ㄴ _posts - ##여기에 .md파일 넣기 포스트 제목 및 수정 1234567---title: \"블로그 만들기 \" #post 제목date: 2017-07-07 00:23:23 #post 생성 날짜tags: [\"hexo\", \"clean-blog\", \"theme\"] #tagscover: /assets/contact-bg.jpg #post 커버 이미지subtitle: \"첫 블로그입니다.\" #post 부제--- ​ 6. 로컬에서 testbash1$ hexo server http://localhost:4000 7. Github Page Repository에 배포 정적 리소스 생성 bash1$ hexo generate 배포 bash1$ hexo deploy 생성 + 배포 한번에 bash1$ hexo deploy --generate 확인 http://apexsoft.github.io/ https://github.com/ApexSoft/apexsoft.github.com.git -master branch ​ 8. 소스관리 master : 블로그 (html) 파일 , hexo를 통해서 deploy 된 소스 soucre : hexo 원본 파일들. 9. 사용 git clone &gt; source branch &gt; https://github.com/ApexSoft/apexsoft.github.com.git .md 파일 올리기 git push &gt; source branch &gt; https://github.com/ApexSoft/apexsoft.github.com.git deploy 10. 기타 테마가 적용 안되는 경우 bash1$ hexo clean 배포가 되지 않는 경우 bash1npm install hexo-deployer-git --save git bash1$ rm -rf .git ​","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"hexo","slug":"hexo","permalink":"http://apexsoft.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://apexsoft.github.io/tags/github/"}]},{"title":"pug","slug":"pug","date":"2018-02-23T06:58:20.606Z","updated":"2018-02-23T06:58:20.606Z","comments":true,"path":"2018/02/23/pug/","link":"","permalink":"http://apexsoft.github.io/2018/02/23/pug/","excerpt":"","text":"#pug templete 확장을 가능하게 하는 언어 사용공통 .pub 파일 html에서 닫는 태그가 없다 들여쓰기한 이후에 공백까지 태그로 된다 태그 속성은 괄호( ) 사용 DialogFormBase.pug pug12345form div(class=\"form-group\") label(for=\"title\" class=\"form-label\") Title textarea(v-model.lazy=\"element.title\" class=\"form-control\" name=\"title\") block custom 사용html123&lt;template lang=\"pug\"&gt; include DialogFormBase.pug&lt;/template&gt; 사용 , 확장html1234567&lt;template lang=\"pug\"&gt; extends DialogFormBase.pug block custom div(class=\"form-group\") label(for=\"placeholder\" class=\"form-label\") Input place holder input(v-model.lazy=\"element.placeholder\" class=\"form-control\" name=\"placeholder\")&lt;/template&gt; Mixins Mixins는 Vue 컴포넌트에 재사용 가능한 기능을 배포하는 방법이다. 얼핏 보면 extends와 유사하게 보일 수가 있다. 캡슐화 및 공통된 기능을 분리시켜 코드 재사용성을 높혀준다. 오버라이딩 기능도 사용할 수 있어 커스텀 및 확장에 용이하다. extends: 유사한 기능의 컴포넌트들을 추상화 하여 상위 컴포넌트를 만들고 차이가 있는 기능들을 하위 컴포넌트에 구현한다. mixins: 서로 다른 기능의 컴포넌트에 동일한 기능을 배포하는 방법으로 예를 들면 로깅 기능을 aspect 단위로 추가하는 것을 들 수 있다.","categories":[],"tags":[{"name":"apexsoft","slug":"apexsoft","permalink":"http://apexsoft.github.io/tags/apexsoft/"},{"name":"templete ","slug":"templete","permalink":"http://apexsoft.github.io/tags/templete/"}]}]}