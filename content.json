{"meta":{"title":"apexsoft 기술블로그","subtitle":"모두가 master가 되는 날 까지","description":null,"author":"HyoSook Kim","url":"http://apexsoft.github.io"},"pages":[],"posts":[{"title":"Postman 활용 - Runner로 반복 호출 수행하기","slug":"postman - runner 사용","date":"2019-03-27T03:20:48.795Z","updated":"2019-03-27T04:43:33.280Z","comments":true,"path":"2019/03/27/postman - runner 사용/","link":"","permalink":"http://apexsoft.github.io/2019/03/27/postman - runner 사용/","excerpt":"","text":"Postman은 테스트도구로써 사용할 수 있다.api 수행하는 것을 테스트 라고 볼 수 있다.같은 api를 여러번 반복해야하는 경우에 Postman의 Runner를 사용할 수 있다.ex) 회원가입 유저를 100명 생성 1. Collection, folder 생성반복해야하는 api 작업을 collection과 folder를 생성해서 저장한다. 2. Environments 생성Environments를 생성하고, 데이터가 변경되는 부분을 variable로 만든다. 3. variable 부분 정의 부분은 반복해서 api를 실행할때 데이터를 바꿔줄 부분이다. form-data, json등 넣고싶은 부분에 를 넣는다. 여러 부분에 변수를 두고싶으면 variable을 추가해서 사용하면 된다. 4. Runner 설정 및 Run상단 메뉴중 Runner 클릭한다. Environment : Environments 중에서 선택 Iterations : 반복 횟수 Delay : 테스트사이 지연 시간 Log Response : (추후 확인 필요) Data : 외부 데이터를 변수로 설정","categories":[],"tags":[{"name":"postman","slug":"postman","permalink":"http://apexsoft.github.io/tags/postman/"}]},{"title":"DDD설계 개념과 구현","slug":"DDD 자주사용 요약 정리","date":"2019-01-09T08:10:45.138Z","updated":"2019-01-09T08:12:53.833Z","comments":true,"path":"2019/01/09/DDD 자주사용 요약 정리/","link":"","permalink":"http://apexsoft.github.io/2019/01/09/DDD 자주사용 요약 정리/","excerpt":"","text":"개념정의도메인 모델의 엔티티 속성이 아닌 식별성을 기준으로 정의되는 도메인 객체.반드시 식별자가 있어야 하고, 식별자가 같으면 같은 Object 인 것이 보장되어야 한다. 단순히 데이터를 담고 있는 데이터 구조라기 보다 , 데이터와 함께 기능을 제공하는 객체 도메인 로직 두개이상의 데이터가 개념적으로 하나인 경우, 벨류 타입(Value Object )을 이용해서 표현할수 있다 Value Object 식별자가 없으며 영속성이 필요없는 객체 값이 변경되면, 원본데이터를 찾기 어렵다 모든 데이터를 삭제하고, 모든 데이터를 다시 저장해야한다 실무에서 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면, 일대다 관계를 고려(엔티티로만들어라) 식별자 없는 물리테이블로 표현될수도 , 칼럼으로 표현될수도 있다 불변타입 데이터 변경 기능을 제공하지 않는다 set 없다 &gt;&gt; 생성자 등 사용 벨류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다. 예를들어 밸류타입인 File를 다음과 같이 작성할 수 있다. 1234567public class File &#123; private String originName; private String path; private String size; ...&#125; 벨류 타입을 사용할 때의 또다른 장점은 밸류타입을 위한 기능을 추가 할 수 있다. s3파일 path가 붙은 전체 path 추가 가능 Aggregate 관련된 모델을 하나로 모은것 애그리거트의 루트는 엔티티 므로 @Entity로 매핑 설정한다 애그리거트에 속한 객체는 유사하거나 ,동일한 라이프 사이클을 가진다 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다 ex) 상품 과 리뷰 는 함께 생성되지 않고, 함께 변경되지 도 않는다 또한 변경 주체도 다르다 애그리거트는 독립된 객체 군이며, 각 에그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다 애그리거트 내의 엔티티 및 밸류 객체의 데이터 수정은 애그리것 루트를 통해서만 수행 다른 애그리것의 엔티티를 참조할 때 객체 직접 참조 대신 ID 참조 방식을 적용 애그리것에 포함된 객체의 정보 수정은 애그리것 내에서만 가능하도록 제한 애그리거트에서 루트 엔터티를 뺀 나머지 구성요서는 대부분 밸류 루트 엔터티 외 다른 밸류가 있다면 진짜 엔터티인지 의심 필요 단지 별도 테이블에 데이터 저장한다고 해서 엔터티는 아님 엔터티가 확실하다면 다른 애그리거트는 아닌지 확인 필요 - 예를 들어 쇼핑몰 사이트에서 주문 Entity내에 배송주소 정보를 우편번호 주소1, 주소2, 상세주소 이런식으로 각 컬럼으로 정의하는 것이 아니라, 주소라는 Value Object를 별도로 작성하고 주문 Entity는 주소 Value Object를 포함하는 방식으로 관계 일관성 및 단순화를 유지한다. Repository 리포지터리는 애그리거트의 저장소이다. 애그리거트를 저장, 조회, 삭제 &gt; 리포지터리의 기본 기능 매핑 구현1. 엔티티와 기본 벨류 매핑Embeddable value object 기간(시작 날짜, 끝 날짜)이나 좌표(X, Y) 등 항상 같이 다니는 값들을 객체로 묶어서 Entity의 속성으로 지정 테이블이 생기지 않고, 칼럼만 추가된다 객체의 클래스에 @Embeddable 어노테이션을 붙여서 선언 Entity에서 @Embedded어노테이션을 붙여서 사용 123456789@Embeddable public class EmploymentPeriod &#123; @Column(name=\"START_DATE\") private java.sql.Date startDate; @Column(name=\"END_DATE\") private java.sql.Date endDate; ....&#125; 12@Embedded private EmploymentPeriod period; 2.두개 이상의 프로퍼티를 가진 밸류타입을 한개의 칼럼에 매핑@Converter 데이터를 변환해서 데이터베이스에 저장 두개 이상의 프로퍼티를 가진 밸류타입을 한개의 칼럼에 매핑하기 위해서 사용 사용 편의상 변환 사용 자바의 boolean 사용 하고, 데이터베이스에 y n 으로 저장하기123456789101112@Converterpublic class BooleanToYNConverter implements AttributeConverter&lt;Boolean, Character&gt; &#123; @Override public Character convertToDatabaseColumn(Boolean attribute) &#123; return (attribute != null &amp;&amp; attribute) ? 'Y' : 'N'; &#125; @Override public Boolean convertToEntityAttribute(Character dbData) &#123; return dbData == 'Y'; &#125;&#125; AttributeConverter 인터페이스 구현 convertToDatabaseColumn : 엔티티의 데이터를 데이터베이스 칼럼에 저장할 데이터로 변환한다 convertToEntityAttribute : 데이터베이스에서 조회한 칼럼 데이터를 엔티티의 데이터로 변환 제네릭에 현재타입과 변환할 타입을 지정해야한다 칼럼 레벨에 적용123@Column(name = \"MULTI_YN\")@Convert(converter = BooleanToYNConverter.class)private boolean multi; 글로벌 설정123456789101112@Converter(autoApply=true)public class BooleanToYNConverter implements AttributeConverter&lt;Boolean, Character&gt; &#123; @Override public Character convertToDatabaseColumn(Boolean attribute) &#123; return (attribute != null &amp;&amp; attribute) ? 'Y' : 'N'; &#125; @Override public Boolean convertToEntityAttribute(Character dbData) &#123; return dbData == 'Y'; &#125;&#125; 모든 Boolean 타입에 컨버터를 적용한다 따로 @Convert를 지정하지 않아도 된다 3.Value Collection 값 타입을 하나 이상 저장 하려면, 컬렉션에 보관해야하고 보관 방법은 두가지가 있다 3-1.별도 테이블 매핑 밸류 컬렉션을 별도 테이블로 매핑하는 방법이다. @ElementCollection을 통해 변경이 발생할 시, 전체를 지우고 다시 입력하는 이슈가 있음. 이를 완화시키기 위해서 @OrderColumn을 추가하는 방법이 있긴하나 완벽하지는 않음 Entityjava12345678@Entitypublic class Order &#123; @ElementCollection @CollectionTable(name = \"order_line\", joinColumns= @JoinColumn(name = \"order_number\")) @OrderColumn(name = \"line_idx\") private List&lt;OrderLine&gt; orderLines;&#125; 밸류 컬렉션을 별도 테이블로 매핑할 땐, @ElementCollection, @CollectionTable 함께 사용 Value Objectjava1234@Embeddablepublic class OrderLine &#123; ..&#125; List 타입 자체가 인덱스를 가지기 때문에, 인덱스 값을 저장하기 위한 프로퍼티가 존재하지 않음 Entity에 @OrderColumn 이용해서 지정한 칼럼에 인덱스 저장 사회혀신타운 프로젝트에서 Portfolio엔터티에 첨부인 Attachment밸류 컬렉션을 매핑한 방법 3-2.한 개 칼럼 매핑 (@Converter) 별도 테이블 아닌 한 개 칼럼에 저장해야 할때 방법이다. 예를 들어, 도메인 모델에는 이메일 주소 목록을 Set으로 보관하고 DB에는 한개 컬럼에 콤마로 구분해서 저장해야 할 때가 있다. 이때 AttributeConverter를 사용하면 밸류 컬렉션을 한 개 칼럼에 쉽게 매핑할 수 있다. EmailSetjava123456789101112public class EmailSet &#123; private Set&lt;Email&gt; emails = new HashSet&lt;&gt;(); private EmailSet() &#123;&#125; private EmailSet(Set&lt;Email&gt; emails) &#123; this.emails.addAll(emails); &#125; public Set&lt;Email&gt; getEmails() &#123; return Collections.unmodifiableSet(emails); &#125;&#125; Entityjava123@Column(name = \"emails\")@Convert(converter = EmailSetConverter.class)private EmailSet emailSet; 크라우드 프로젝트 EvalAns부분에 답변이 여러개인 경우 때문에, items에 콤마로 구분해서 여러값이 들어갈수 있도록 매핑한 방법 AttributeConverter 를 구현해서 만든 ListToStringConverter가 매핑을 도와준다. 차이점 : 책에서는 Set타입 사용했지만 책임님은 List&lt;Object&gt; 사용, 코드집합 (예: itemSet 타입)이 필요하다고 했는데, 책임님은 만들지 않으셨다. Value Collection을 테이블로 저장할지, 컬럼으로 저장할지 결정하는 기준은?책에 의하면, List는 순서가 있는 타입이며 순서가 필요한 경우 List&lt;밸류컬렉션&gt; 으로 선언하여 테이블로 저장한다고만 짧게 언급했다. @OneToMany @Entity 끼리의 매핑을 위해서 사용된다 대부분의 다른 애그리거트에 있는, 엔티티 간의 관게를 표현 할때 사용된다 애그리거트는 ROOT 엔티티를 한개를 가진다 ROOT 엔티티 끼리의 관계를 표현 간혹 개념적으로 벨류인데, 여러이유로 @Entity를 사용해야 할때도 사용된다 Enumerated 자바의 enum 타입을 매핑할 때 사용 Enum클래스 123public enum FileType &#123; IMAGE, MOVIE, DOC, ETC &#125; 매핑 EnumType.STRING : enum 이름을 db에 저장 EnumType.ORDINAL: enum ‘순서’ 를 db에 저장 123/*첨부유형구분코드*/ @Enumerated(EnumType.STRING) @NonNull private FileType fileType; @MappedSuperclass 추상 클래스와 유사 단순히 매핑 정보를 상속할 목적으로만 사용된다 부모클래스는 테이블과 매핑하지않고, 부모클래스를 상속받는 자식클래스에게 매핑 정보만 제공한다 여러엔티티에서 공통으로 사용하는 속성을 효과적으로 관리 123456789101112131415@EntityListeners(AuditingEntityListener.class) // 생성 수정 자동 설정@MappedSuperclass // 부모설정 @Datapublic class AbstractBaseEntity implements Serializable &#123; @CreatedDate @Column(name = \"CREATED_AT\", updatable = false) @JsonIgnore private LocalDateTime createdDateTime; @LastModifiedDate @Column(name = \"LAST_MODIFIED_AT\", updatable = true) @JsonIgnore private LocalDateTime lastModifiedDateTime;&#125; 12345678@Entity@Table(name = \"USER\")public class User extends AbstractBaseEntity implements Serializable &#123; @Id @Column(name = \"USER_ID\") private String userId;&#125; jaksonjackson은 자바진영 json 라이브러리로 잘 알려져 있지만 json 뿐만 아니라 XML, YAML, CSV 등 다양한 형식의 데이타를 지원하는 data-processing 툴이다. 스트림 방식이므로 속도가 빠르며 유연하며 다양한 third party 데이터 타입을 지원하며 annotation 방식으로 메타 데이타를 기술할 수 있으므로 JSON 의 약점중 하나인 문서화와 데이타 validation 문제를 해결할 수 있다. @JsonIgnore : VO의 멤버변수 위에 선언해서 제외처리 (비밀번호 같은거) @JsonProperty : json으로 변환 시에 사용할 이름이다. (DB 칼럼과 이름이 다르거나 api 응답과 이름이 다르지만 매핑시켜야 할 때) @JsonGetter : 어떤 필드값을 가져올 떄 이 메소드로 접근해서만 가져오라고 jackson에게 명시적으로 알린다. @JsonSetter : 위와 동일, Deserialize 때","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"DDD","slug":"DDD","permalink":"http://apexsoft.github.io/tags/DDD/"}]},{"title":"JPA 연관관계","slug":"연관관계","date":"2019-01-02T08:19:26.701Z","updated":"2019-01-02T08:19:26.702Z","comments":true,"path":"2019/01/02/연관관계/","link":"","permalink":"http://apexsoft.github.io/2019/01/02/연관관계/","excerpt":"","text":"단방향 연관관계ex ) 회원과 팀 회원과 팀이 있다 회원은 하나의 팀에만 소속될 수 있다 회원과 팀은 다대일 관계이다 객체 vs 테이블 , 연관관계객체 연관관계 참조(주소)로 연관관계를 맺는다 회원 객체와 팀 객체는 단방향 관계 회원은 , Member.team 필드를 통해서 팀을 알 수 있지만, 팀을 회원을 알 수 없다 테이블 연관관계 외래 키 로 연관관계를 맺는다 회원테이블과 팀 테이블은 양방향 관계 회원테이블의 TEAM_ID 외래키를 통해서 회원과 팀을 조인할수 있고 , 팀과 회원도 조인할수 있다 MEMBER JOIN TEAM 과 TEAM JOIN MEMBER 객체연관관계와 테이블 연관관계의 가장 큰 차이 참조를 통한 연관관계는 항상 단방향 이다. 객체간에 연관관계를 양방향으로 만들고 싶으면, 연관관계를 하나 더 만들어야한다 양방향 관계가 아니라 , 서로다른 단방향 관계 2개 이다 테이블은 외래 키 하나로 양방향으로 조인할 수 있다 그래프탐색 객체는 참조를 사용해서 연관관계를 탐색할수 있는데 이것을 그래프 탐색 이라 한다 조인 데이터베이스는 외래 키를 사용해서 연관관계를 탐색 할수 있는데 이것을 조인이라 한다 JAP 객체 관계 매핑 회원 12345678910111213@Entity public class Member&#123; @Id private String id; private String username; //연관관계 매핑 @ManyToOne @JoinColum(name=\"TEAM_ID\") private Team team; &#125; 팀 1234567@Entity public class Team&#123; @Id private String id; private String name; &#125; 객체 연관관계 : 회원 객체의 Member.team 필드 사용 테이블 연관관게 : 회원 테이블의 MEMBER.TEAM_ID 외래키 칼럼 사용 fetch 관계 엔티티의 데이터 읽기 전략을 결정. FetchType.EAGER : 관계된 엔티티의 정보를 미리 읽어오는 것 FetchType.LAZY : 관계된 엔티티의 정보를 실제 요청하는 순간 가져오는 것 양방향 연관관계 정확히 이야기하면 서로다른 단방향 관계 2개 단방향으로 매핑을 한다 반대 방향으로 객체 그래프 탐색 기능 (jpql 쿼리탐색 포함)이 필요할때 , 양방향을 사용하도록 코드를 추가함 연관관계의 주인을 정하는 기준 단방향은 항상 외래키가 있는 곳을 기준으로 매핑하면 된다 연관관계의 주인만 데이터베이스 연관관게 매핑되고, 외래키를 관리할 수 있다 주인이 아닌 반대편은 읽기만 가능하고, 외래키를 변경하지는 못한다 양방향에서 연관관계의 주인은 외래 키의 위치와 관련해서 정해야지 비즈니스 중요도로 접근 하면 안됨 연관관계의 주인 = 외래키 관리자 외래키의 위치와 관련해서 정해야한다!!!! 1234class Team&#123; @OneToMany(mappedBy=\"team\") // mappedBy 속성의 값은 연관관계의 주인인 Member.team private List&lt;Member&gt; members =new ArrayList&lt;Member&gt;();&#125; 주인의 반대편은 mappedBy로 주인을 지정해야한다 진짜 매핑 : 연관관계의 주인 (Member.team) 가짜 매핑 : 주인의 반대편 (Team.member )","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"}]},{"title":"JPA 상속관계","slug":"상속관계","date":"2019-01-02T08:19:26.697Z","updated":"2019-01-02T08:19:26.698Z","comments":true,"path":"2019/01/02/상속관계/","link":"","permalink":"http://apexsoft.github.io/2019/01/02/상속관계/","excerpt":"","text":"@MappedSuperclass 부모클래스는 테이블과 매핑하지않고, 부모클래스를 상속받는 자식클래스에게 매핑 정보만 제공한다 추상클래스와 유사 @Entity는 실제 테이블과 매핑되지만, @MappedSuperclass는 실제 테이블과는 매핑되지 않는다 단순히 매핑 정보를 상속할 목적으로만 사용된다 등록일자 , 수정일자 , 등록자 , 수정자 같은 여러엔티티에서 공통으로 사용하는 속성을 효과적으로 관리 할 수 있다. 부모 AuditEntityListener Spring data jpa에서 구현한 EntityListener이다. @PrePersist, @PreUpdate 설정을 통해 엔티티가 영속화 되기이전에 AuditingHandler를 통해 생성일, 생성자, 수정일, 수정자를 자동으로 찾아 설정한다. JsonIgnore : 제외처리 123456789101112131415@EntityListeners(AuditingEntityListener.class) // 생성 수정 자동 설정@MappedSuperclass // 부모설정 @Datapublic class AbstractBaseEntity implements Serializable &#123; @CreatedDate @Column(name = \"CREATED_AT\", updatable = false) @JsonIgnore private LocalDateTime createdDateTime; @LastModifiedDate @Column(name = \"LAST_MODIFIED_AT\", updatable = true) @JsonIgnore private LocalDateTime lastModifiedDateTime;&#125; 자식 12345678@Entity@Table(name = \"USER\")public class User extends AbstractBaseEntity implements Serializable &#123; @Id @Column(name = \"USER_ID\") private String userId;&#125;","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"}]},{"title":"Node - MongoDB 간단 프로젝트","slug":"Node - MongoDB 간단 프로젝트","date":"2018-12-17T05:01:08.962Z","updated":"2018-12-17T05:01:08.963Z","comments":true,"path":"2018/12/17/Node - MongoDB 간단 프로젝트/","link":"","permalink":"http://apexsoft.github.io/2018/12/17/Node - MongoDB 간단 프로젝트/","excerpt":"","text":"Node - MongoDB 간단 프로젝트123Mongoose는 ODM(Object Data Mapping) library이다. Java기반의 Hibernate, iBatis 등의 ORM(Object Relational Mapping)과 유사한 개념이다.몽고디비를 로컬에 설치하지 않아도 클라우드 서비스로 개발할 수 있다. 프로젝트부터 만들자. 프로젝트 경로 폴더를 만들고 아래와 같이 터미널에 실행하자. 1npm init -y //기본 설정으로 프로젝트 생성 모듈을 준비하자.(body-parser, express, mongoose, ejs, dotenv를 일단 추가해주자.) 1npm install body-parser express mongoose ejs dotenv 디비를 만들자. 위에 설명한 것처럼 클라우드 서비스로 생성할 수 있다. 디비만들기1 디비만들기2 1GUI도구인 compass나 robomongo를 쓰면 편하게 디비에 접속, 관리할 수 있다. 준비가 끝났으면 환경설정파일과 서버파일부터 만들어보자. 환경설정 파일은 아래와 같다. URI 정보는 디비만들기1 링크를 참고한다. 123// 파일명은 없고 .env 확장자만 달아서 생성한다.PORT=3000MONGO_URI=mongodb://사용자명:비밀번호@mlab에서 생성한 주소.mlab.com:포트/디비명 서버는 평범하게 app.js로 생성했다. 일단 이만큼이 기본이다. 터미널에 node app.js 를 입력해서 서버를 시작해보자.(종료할 때는 컨트롤+C를 입력하고 y를 입력해준다.) 디비연결메시지, 서버시작 메시지를 봤다면 연결테스트는 끝났다. 12345678910111213141516171819202122232425// app.jsvar express = require(&apos;express&apos;);var env = require(&apos;dotenv&apos;).config();var app = express();var router = express.Router();var mongoose = require(&apos;mongoose&apos;);var bodyParser = require(&apos;body-parser&apos;);app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.use(router);mongoose.Promise = global.Promise;// 윗부분까지는 기본설정 부분이다.// 디비 연결부분이다. 성공메시지로 연결을 확인했다.mongoose.connect(process.env.MONGO_URI) .then(() =&gt; console.log(&apos;successfully connnected to mongodb!&apos;)) .catch(e =&gt; console.log(e))// 서버시작app.listen(process.env.PORT || 3000, () =&gt; &#123; console.log(&apos;server start!&apos;);&#125;); 연결테스트까지 완료하고 준비가 끝났다면 이제 CRUD를 해보자. 아이디와 이름을 가지는 스키마를 만들겠다. 12345678// user.jsvar mongoo = require(&apos;mongoose&apos;);var UserSchema = new mongoo.Schema(&#123; userid: String, username: String&#125;);module.exports = mongoo.model(&apos;user&apos;, UserSchema); 12// app.js의 기본설정 부분에 추가하자.var User = require(&apos;./user&apos;); 이제 유저를 추가해보자. 유저를 추가할 수 있는 간단한 인풋이 있는 화면을 ejs로 만들어보겠다. views라는 폴더를 생성하고 그 안에 만들어주었다. 123456789101112131415161718// ./views/main.ejs&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;title&gt;Mongoose test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/add&quot; method=&quot;POST&quot;&gt; &lt;input name=&quot;id&quot; type=&quot;text&quot; /&gt; &lt;input name=&quot;name&quot; type=&quot;text&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;send&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011ejs에 대해 몇 가지만 적어보겠다.1. html의 기본적인 문법은 같다.2. css코드를 별도로 분리해서 개발하고 싶다면 css코드를 &lt;style&gt;&lt;/style&gt;로 감싼 ejs파일을 생성하고 헤드부분에 &lt;%include css파일.ejs%&gt; 이렇게 추가해주자. 확장자가 css인 파일을 추가하는 법은 못 찾겠다. js도 마찬가지.3. js코드를 분리하고 싶을 때도 마찬가지다. &lt;script&gt;&lt;/script&gt;로 감싼 ejs파일을 생성하고 위와 같은 방식으로 바디의 아랫부분에 추가해준다. 화면을 뿌려보자. 12345// app.js 에 아래 코드를 추가하자.// 메인 화면을 렌더링한다.router.get(&apos;/&apos;, (req, res) =&gt; &#123; res.render(__dirname + &apos;/views/main.ejs&apos;);&#125;); 서버를 재시작하고 localhost:3000/ 에 들어가보자. 텍스트 입력칸 2개와 버튼 하나가 화면에 나올 것이다. 화면이 나왔으니 유저를 추가해보자. 화면코드에서 눈치 챘겠지만 버튼을 누르거나 엔터를 치면 아이디와 이름이 디비에 추가되도록 할 것이다. 1234567891011// app.js 에 아래 코드를 추가하자.// 유저를 추가한다.router.post(&apos;/add&apos;, (req, res) =&gt; &#123; User.create(&#123; _id: req.body.id, first_name: req.body.name &#125;, (err, user) =&gt; &#123; if (err) return res.status(500).send(&apos;fail!&apos;); res.status(200).redirect(&apos;/&apos;); &#125;);&#125;); 위에서 나오는 User가 아까 생성했던 스키마인 그 녀석이 맞다. body-parser를 사용했기 때문에 input에 넣은 id와 name의 값을 가져와 설정할 수 있다. 유저를 추가하고 에러메시지가 나오는지 새로고침이 되는지 확인해보자. 새로고침이 되었다면 유저가 추가된 것이다. compass, robomongo, mlab페이지 등을 통해 확인해보자. 정상적으로 추가된 것이 확인되었다면 전체 유저 리스트를 가져와서 뿌려보자. 123456789101112131415161718192021222324252627&lt;!-- ./views/user.ejs --&gt;&lt;!-- 화면은 이렇게 정의한다. --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;% for(var i=0; i &lt; users.length; i++) &#123; %&gt; &lt;tr&gt; &lt;td&gt; &lt;%= users[i].userid %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= users[i].username %&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% &#125; %&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 12345678// app.js 에 아래 코드를 추가하자.router.get(&apos;/getuser&apos;, (req, res) =&gt; &#123; User.find((err, users) =&gt; &#123; if (err) return res.status(500).send(&apos;fail!&apos;); res.status(200).render(__dirname + &apos;/views/user.ejs&apos;, &#123; users: users &#125;); &#125;);&#125;); 서버를 재시작하고 localhost:3000/getuser 에 들어가보자. main.ejs 화면을 통해 추가한 목록이 잘 나오면 성공이다. 메인화면에 유저목록을 함께 출력하고 유저가 추가되면 업데이트되도록 바꿨다. main.ejs에서 목록을 추가할 부분에 아까 ejs 설명에 적은 것 처럼 1&lt;%include user.ejs%&gt; 위의 코드를 추가해주면 된다. 나는 폼태그의 바로 아래에 추가했다. 12345678910&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;form action=&quot;/add&quot; method=&quot;POST&quot;&gt; &lt;input name=&quot;id&quot; type=&quot;text&quot; /&gt; &lt;input name=&quot;name&quot; type=&quot;text&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;send&quot; /&gt; &lt;/form&gt; &lt;%include user.ejs%&gt;&lt;/body&gt; 이렇게 되는 것이다. 그러면 이제 유저목록과 함께 메인화면이 나오게 된다. 메인화면을 출력하는 서버코드도 살짝 변경하였다. 12345678// app.jsrouter.get(&apos;/&apos;, (req, res) =&gt; &#123; User.find((err, users) =&gt; &#123; if (err) return res.status(500).send(&apos;fail!&apos;); res.status(200).render(__dirname + &apos;/views/main.ejs&apos;, &#123; users: users &#125;); &#125;);&#125;); 서버를 재시작해서 확인해보자. 한명의 유저를 조회해보자. 1234567891011// app.js에 아래 코드를 추가하자.// 유저 조회router.get(&apos;/:id&apos;, (req, res) =&gt; &#123; User.findById(req.params.id, (err, user) =&gt; &#123; if (err) return res.status(500).send(&apos;조회 실패&apos;); if (!user) return res.status(404).send(&apos;유저 없음&apos;); res.status(200).send(user); &#125;);&#125;); 서버를 재시작하고 아래와 같이 입력하면 한명의 유저 정보가 출력된다. 오브젝트아이디는 디비에서 직접 확인해서 붙여넣는다. 1localhost:3000/오브젝트아이디 삭제와 수정은 아래의 코드를 참고하면 된다. 1234567891011121314151617// User 삭제router.get(&apos;/del/:id&apos;, (req, res) =&gt; &#123; User.findByIdAndRemove(req.params.id, (err, user) =&gt; &#123; if (err) return res.status(500).send(&apos;del fail&apos;); res.status(200).redirect(&apos;/&apos;); &#125;);&#125;);// User 수정router.post(&apos;/update/:id&apos;, (req, res) =&gt; &#123; User.findByIdAndUpdate(req.params.id, req.body, &#123; new: true &#125;, (err, user) =&gt; &#123; if (err) return res.status(500).send(&apos;update fail&apos;); res.status(200).redirect(&apos;/&apos;); &#125;);&#125;); 수정을 위한 화면과 삭제버튼은 만들어서 사용해보자.","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"http://apexsoft.github.io/tags/Node/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://apexsoft.github.io/tags/MongoDB/"}]},{"title":"JFrame for IntelliJ","slug":"JFrame for IntelliJ","date":"2018-12-17T04:47:10.833Z","updated":"2018-12-17T04:55:02.519Z","comments":true,"path":"2018/12/17/JFrame for IntelliJ/","link":"","permalink":"http://apexsoft.github.io/2018/12/17/JFrame for IntelliJ/","excerpt":"","text":"JFrame for IntelliJ자바로 응용프로그램을 개발할 때 Swing을 많이 사용한다. JFrame은 Swing기반의 인텔리제이에 내장되어있는 개발 툴킷이다. 개발을 시작하는 방법은 매우 쉽다. 새 프로젝트를 시작하고 java를 선택한 후 만들면 된다. 비어있는 프로젝트에서 우클릭을 해서 new 탭에 가보면 GUI Form이 나온다. 이걸 클릭하면 form파일과 java파일이 생성되고 form파일을 클릭해보면 마치 안드로이드스튜디오를 만들 때처럼 디자인 에디터같은 화면이 나오는걸 볼 수 있다. 안드로이드와 만드는 방법도 비슷하다. 기본적인 버튼이나 텍스트 등을 꺼내둔 다음 저장을 한다. 새 파일을 추가해서 메인 메서드를 만들거나 form과 한쌍인 자바파일에 메인 메서드를 추가해준다. 그리고 나서 이 내용을 붙여넣는다. 123456789public static void main(String[] args) &#123; SwingUtilities.invokeLater(new Runnable() &#123; @Override public void run() &#123; MainWin mainWin = new MainWin(); mainWin.setVisible(true); &#125; &#125;); &#125; 실행을 해보면 창이 나온다. 그 외의 설정들은 JFrame을 검색해서 하나씩 적용해보도록 하자. 몇가지 간단한 것을 소개해주자면 아래와 같다. 123// 메인 메서드에 추가mainWin.setUndecorated(true); // 최소화 최대화 닫기 등이 표시되는 상단바가 사라진다.mainWin.setResizable(false); // 사이즈 조절을 할 수 없도록 바꾼다. 123456789101112131415161718192021222324252627282930313233// 폼의 생성자 메서드에 추가/* 1. 응용 프로그램의 아이콘 이미지를 등록할 수 있다. 이때, 이미지 경로는 src 아래에 있어야 인식한다. src를 루트로 여기고 계산하면 된다. */setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource(\"이미지경로\")));/* 2. 마우스 클릭과 드래그를 통해 창의 위치를 변경할 수 있다. 아래 두줄의 내용을 생성자 메서드 밖, 즉 클래스에 먼저 선언해둔다. 패널명은 form에서 제일 최상위 패널에 변수명을 입력하면 알아서 등록된다. 되지 않으면 직접 입력하여 시도해본다. */private JPanel 패널명;int posX = 0, posY = 0;// 다시 생성자로 돌아와서 아래의 내용을 작성한다.setSize(400, 500); // 응용프로그램의 창 사이즈를 설정한다.Dimension scrSize = Toolkit.getDefaultToolkit().getScreenSize(); setLocation(scrSize.width - 400, scrSize.height - 500);패널명.addMouseListener(new MouseAdapter() &#123; @Override public void mousePressed(MouseEvent e) &#123; super.mousePressed(e); posX = e.getX(); posY = e.getY(); &#125;&#125;);패널명.addMouseMotionListener(new MouseMotionAdapter() &#123; @Override public void mouseDragged(MouseEvent e) &#123; super.mouseDragged(e); setLocation(e.getXOnScreen() - posX, e.getYOnScreen() - posY); &#125;&#125;); 이러면 드래그를 했을 때 응용프로그램의 창을 움직일 수 있으며 원하는 아이콘 이미지를 등록하여 작업표시줄에 나타나게 할 수 있다. 디자인 객체(버튼 텍스트박스 등)에 이벤트를 연결하는 방법은 아래와 같다. 해당 객체 위에서 우클릭을 한 후 Create Listener를 클릭해주면 된다. 사용 가능한 이벤트가 나오게 되는데 그 중 원하는 것을 선택하여 적용한다. 보통은 ActionListener를 적용한다.","categories":[],"tags":[{"name":"JFrame","slug":"JFrame","permalink":"http://apexsoft.github.io/tags/JFrame/"},{"name":"IntelliJ","slug":"IntelliJ","permalink":"http://apexsoft.github.io/tags/IntelliJ/"}]},{"title":"AR.js로 쉽게 브라우저용 AR 개발하기","slug":"AR.js_쉽게 브라우저용 AR 개발하기","date":"2018-12-17T04:47:10.827Z","updated":"2018-12-17T04:55:02.513Z","comments":true,"path":"2018/12/17/AR.js_쉽게 브라우저용 AR 개발하기/","link":"","permalink":"http://apexsoft.github.io/2018/12/17/AR.js_쉽게 브라우저용 AR 개발하기/","excerpt":"","text":"AR.js12345678&lt;script src=\"https://aframe.io/releases/0.8.0/aframe.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.rawgit.com/jeromeetienne/AR.js/1.5.5/aframe/build/aframe-ar.js\"&gt;&lt;/script&gt;&lt;body style='margin : 0px; overflow: hidden;'&gt; &lt;a-scene embedded arjs='sourceType: webcam;'&gt; &lt;a-box position='0 0.5 0' material='opacity: 0.5;'&gt;&lt;/a-box&gt; &lt;a-marker-camera preset='hiro'&gt;&lt;/a-marker-camera&gt; &lt;/a-scene&gt;&lt;/body&gt; 단지 이거다. 컴퓨터에 카메라를 연결하고 이것만 추가하면 증강현실 객체를 볼 수가 있다. ar.js페이지에서는 qrcode를 접목해서 마커로 사용한다. 마커 안에 작게 qrcode를 박아넣고 휴대폰으로 qrcode를 인식했을 때 그걸 확인할 수있는 페이지로 이동되고(브라우저) qrcode를 감싸고 있는 마커에서 객체를 인식하는 방식이다. 링크를 보면 무슨 말인지 이해할 수 있을 것이다. 그래서 ar.js에서는 qrcode를 유저가 제작할 수 있도록 지원해준다. ar.js를 사용하면 누구라도(설령 개발을 오늘 처음 하더라도!) 손쉽게 증강현실을 적용할 수 있는 것이다. 하지만 카메라가 너무 빠를 경우 추적을 따라가지 못하는 경우가 많이 발생한다. arcore의 트래킹 수준이 어느정도인지 확실하게 파악해볼 필요가 있다. 만약 arcore나 arkit의 트래킹 수준이 높지 않다면 높은 비용을 감수하고 그것들을 할 필요가 없다. ar.js면 되는 것이다. 하지만 현실에 대한 정밀 추적이 가능하다면 ar.js를 사용하는 것은 미련한 짓이다.","categories":[],"tags":[{"name":"ARjs","slug":"ARjs","permalink":"http://apexsoft.github.io/tags/ARjs/"},{"name":"브라우저AR","slug":"브라우저AR","permalink":"http://apexsoft.github.io/tags/브라우저AR/"},{"name":"증강현실","slug":"증강현실","permalink":"http://apexsoft.github.io/tags/증강현실/"}]},{"title":"vuex 사용(모듈화 포함)","slug":"Vuex 개념 모듈화 사용","date":"2018-12-17T02:32:14.313Z","updated":"2018-12-17T02:35:26.574Z","comments":true,"path":"2018/12/17/Vuex 개념 모듈화 사용/","link":"","permalink":"http://apexsoft.github.io/2018/12/17/Vuex 개념 모듈화 사용/","excerpt":"","text":"vuex 단일상태관리 패턴 + 라이브러리 모든 컴포넌트에 대한 중앙 집중식 저장소 역활 단일 state , Getters로 읽고 , actions로 mutations변화하고 mutations로 값을 변경 한다 One-way data flow 를 가진다 사용 이유? eventBus 도 있는데, 왜 vuex를 쓸까? 컴포넌트 간의 부-자 컴포넌트 간의 형제 두 타입간의 데이터 공유가 씽크문제가 발생하는 것을 막을 수 있다. vuex 부르기 main.js 안에서 적용된 것은 $를 붙여서 불러올수 있다. 12345const app = new Vue(&#123; // \"store\" 옵션을 사용하여 저장소를 제공하십시오. // 그러면 모든 하위 컴포넌트에 저장소 인스턴스가 삽입됩니다. store&#125;) this.$store vuex는 store 옵션(Vue.use(Vuex)에 의해 가능)으로 루트 컴포넌트의 모든 자식 컴포넌트에 저장소를 주입하는 메커니즘을 제공합니다. 플러그인 형태 = 전역으로 .use () 사용 State Vuex는 단일 상태 트리 를 사용합니다. 즉, 이 단일 객체는 모든 애플리케이션 수준의 상태를 포함하며 “원본 소스” 역할을 합니다. 단일 상태 트리를 사용하면 특정 상태를 쉽게 찾을 수 있으므로 디버깅을 위해 현재 앱 상태의 스냅 샷을 쉽게 가져올 수 있습니다. 선언12345const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;&#125;) vuex 상태를 vue 컴포넌트 에서 가져오기 상태를 “검색”하는 가장 간단한 방법은 계산된 속성내에서 일부 저장소 상태를 가져오는 것 1. computed12345computed: &#123; count () &#123; return this.$store.state.count &#125;&#125; 2. mapState 배열 형태 사용 ( 매핑 된 계산된 속성의 이름이 상태 하위 트리 이름과 같을 때 문자열 배열을 mapState에 전달할 수 있습니다.) 12345import &#123;mapState&#125; from 'vuex' ///vuex에서 mapState 가져오기computed: mapState([ // this.count를 store.state.count에 매핑 합니다. 'count']) 3. mapState ,proposal-object-rest-spread 다른 계산된 속성과 사용시 12345import &#123;mapState&#125; from 'vuex' ///vuex에서 mapState 가져오기computed:&#123;localComputed () &#123; /* ... */ &#125;,...mapState(['count'])&#125; 만약 , vue컴포넌트 내에서 단 한개의 상태만을 가져온다면, 1 번의 방법을 사용하겠지만 확장 성을 위해서 3번 사용을 표준으로 한다 Getters 때로는 저장소 상태를 기반하는 상태를 계산해야 할 수도 있습니다.(예: 아이템 리스트를 필터링하고 계산) 장소의 계산된 속성으로 생각할 수 있습니다. 계산된 속성처럼 getter의 결과는 종속성에 따라 캐쉬되고, 일부 종속성이 변경된 경우에만 다시 재계산 됩니다. 모든 컴포넌트에서 부르는 상태가 있다면, getters에 등록해서 사용하는것이 중복코드를 막는 좋은방법 선언12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 속성 인자로 다른 getter 로 가능 123456getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125; getter에 전달 인자로 전달 12345678910getters: &#123; // ... getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125;///컴포넌트에서 사용 store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: '...', done: false &#125; ###1.computed 12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 2.mapGetters ,proposal-object-rest-spread Enhancde Object Literals object의 property가 key와 value가 동일하다면, 하나로 축약 가능 12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // getter를 객체 전개 연산자(Object Spread Operator)로 계산하여 추가합니다. ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; getter를 다른 이름으로 매핑 123456computed: &#123;...mapGetters(&#123; // this.doneCount를 store.getters.doneTodosCount에 매핑하십시오. doneCount: 'doneTodosCount'&#125;) &#125; mutations state 값을 변화 시키는 mutations state는 직접 변경도 가능하다 &gt;&gt; but 절대 권장 하지 않는다 디버깅을 보장 되지 않음 (dev-tools) 상황에 따라서, 값이 바뀌지 않을 때도 있다 같은 기능을 하는 함수 사용을 막기 위해서 사용 무조건 동기적 이여야 한다 &gt;&gt; 대부분 상태 변경 비동기 (axios) 같은 경우 , action에서 mutations 을 호출 = commit mutations을 commit 해서 state를 변화 한다 vue.set()을 사용해서 state를 변경 가능 &gt; vue reactive rule에 따라서 가능. 이후에 mutation을 시킴. 선언1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 상태 변이 state.count++ &#125; &#125;&#125;) 1this.$store.commit('increment', 10) 전달 인자(payload) 가능 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment: (state, payload)=&gt; &#123; // 상태 변이 state.count+=payload.amount &#125; &#125;&#125;) vue의 반응성 규칙 Vuex 저장소의 상태는 Vue에 의해 반응하므로, 상태를 변경하면 상태를 관찰하는 Vue 컴포넌트가 자동으로 업데이트됩니다. 이것은 또한 Vuex 변이가 일반 Vue로 작업 할 때 동일한 반응성에 대한 경고를 받을 수 있음을 의미합니다. 원하는 모든 필드에 앞서 저장소를 초기화하는 것이 좋습니다. 1state.obj = &#123; ...state.obj, newProp: 123 &#125; 객체 스타일로 commit 가능 (명사로 표현이 가능하므로, 더 직관적이다) 1234this.$store.commit(&#123; type: 'increment', // mutations 이름 amount: 10&#125;) mapMutations 컴포넌트 안에서 변이 커밋하기 this.$store.commit(&#39;xxx&#39;)를 사용하여 컴포넌트에서 변이를 수행하거나 컴포넌트 메소드를 store.commit 호출에 매핑하는 mapMutations 헬퍼를 사용할 수 있습니다 (루트 store 주입 필요) 12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment' // this.increment()를 this.$store.commit('increment')에 매핑합니다. ]), ...mapMutations(&#123; add: 'increment' // this.add()를 this.$store.commit('increment')에 매핑합니다. &#125;) &#125;&#125; 이렇게 하면, 실제 선언된 함수처럼 사용이 가능하다 actions mutaions은 모든 기능이 동기로 작동한다 하나의 state에 여러가지 데이터가 접근하려 할떄 순서를 알기 힘들다 dispatch(보내다) 사용해서 actions을 부른다 컴포넌트에서 dispatch로 actions을 부르고 , commit으로 mudtaions이 호추로디어 state가 변함 1234567actions: &#123; incrementAsync: (&#123; commit &#125;,payload)=&gt; &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; mapActions12345678910111213import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment' // this.increment()을 this.$store.dispatch('increment')에 매핑 ]), ...mapActions(&#123; add: 'increment' // this.add()을 this.$store.dispatch('increment')에 매핑 &#125;) &#125;&#125; why ??sate , getters 는 computed 인데 , mutations,actions는 methods 에 매핑할까? 수정하는 것이지 , 가져오는게(state, getter) 아니다 computed는 캐싱 모듈화 저장소를모듈로 나눌수 있다. 관리를 위해 모듈로 나누어서 사용한다. store/modules/modal.jsmodal이라는 모듈 한개 1234567891011121314151617181920const state = &#123; test: 'test1'&#125;const actions = &#123;&#125;const getters = &#123;&#125;const mutations = &#123;&#125;export default &#123; state, getters, actions, mutations&#125; store/modules/index.js모든 모듈을 store/index.js 상단에 import XX from &#39;store/modules/XX&#39; 라고 써줘야하는 번거로움이 있다. js 로 modules 파일 아래 모든 파일들을 import 해주도록 짜두면 편리하다. js12345678910111213141516171819202122232425import camelCase from 'lodash/camelCase'// Storing in variable a context with all files in this folder// ending with `.js`.const requireModule = require.context('.', false, /\\.js$/)const modules = &#123;&#125;requireModule.keys().forEach(fileName =&gt; &#123; if (fileName === './index.js') return // filter fullstops and extension // and return a camel-case name for the file const moduleName = camelCase( fileName.replace(/(\\.\\/|\\.js)/g, '') ) // create a dynamic object with all modules modules[moduleName] = &#123; // add namespace here namespaced: true, ...requireModule(fileName).default // if you have exported the object with name in the module `js` file // e.g., export const name = &#123;&#125;; // uncomment this line and comment the above // ...requireModule(fileName)[moduleName] &#125;&#125;)export default modules store/index.jsmodules 만 import 해준다. js1234567891011import Vue from 'vue'import Vuex from 'vuex'import modules from './modules'Vue.use(Vuex)const store = new Vuex.Store(&#123; modules&#125;)export default store","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"vuex ","slug":"vuex","permalink":"http://apexsoft.github.io/tags/vuex/"},{"name":"저장소","slug":"저장소","permalink":"http://apexsoft.github.io/tags/저장소/"}]},{"title":"ES6 사용","slug":"ES6 기본사용","date":"2018-11-29T05:16:29.282Z","updated":"2018-11-29T05:16:29.283Z","comments":true,"path":"2018/11/29/ES6 기본사용/","link":"","permalink":"http://apexsoft.github.io/2018/11/29/ES6 기본사용/","excerpt":"","text":"ES6화살표 함수123456789// 일반적인 자바스크립트 함수(ES5)function (인자) &#123; 함수 로직&#125;// 화살표 함수(ES6)(인자) =&gt; &#123; 함수 로직&#125; 값을 this로 바인딩 하지 않는다 인자값이 1개인 경우, ()도 필요없다 &gt; 간결 기존 12345filterBySize() &#123; return this.items.filter((item) =&gt; &#123; return item.size === this.size; &#125;);&#125; 변경 후 123filterBySize() &#123; return this.items.filter(item =&gt; item.size === this.size);&#125; 템플릿 리터럴 작은 따옴표(‘) 나 큰따옴표(“) 대신에 , 백틱(`) 사용을 의미한다 문자열을 여러줄에 걸쳐서 표시 가능 기존 123456Vue.component(&#123; template: '&lt;div&gt;' + '&lt;h1&gt;&lt;/h1&gt;' + '&lt;p&gt;&lt;/p&gt;' + '&lt;/div&gt;'&#125;); ES6 123456Vue.component(&#123; template: `&lt;div&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;`&#125;); 변수 삽입 표현식 ${} 문법 활용 기존 1'Hello ' + this.name + ' how are you?' ES6 , ${}사용 1`Hello $&#123;this.name&#125; how are you?` 모듈 자바스크립트 애플리케이션을 여러 개의 파일로 분할할 수 있습니다. 프로젝트 안에서 재사용이 가능한 코드를 생성할 수 있습니다. 1234// file1.jsexport default &#123; myVal: 'Hello'&#125; 123// file2.jsimport obj from './file1.js';console.log(obj.myVal); // Hello 컴포넌트 모듈로 사용 1234// component1.jsexport default &#123; // 컴포넌트 내용 정의&#125;; 123// app.jsimport component1 from './component1.js';Vue.component('component1', component1); ## Array Helers Functional Programming 트렌트에 따라서 , array 값을 for loop를 통해 가져오는 대신, 여러 array 메서드를 이용하는것을 권장한다 forEach 전달받은 함수를 배열의 각각 원소에대해서 실행 12345let fruits = ['apple','banana','peach','blue berry'];fruits.forEach((fruit) =&gt; console.log(fruit);&#125;); map 각각의 배열 원소들에 대해서 전달받은 함수를 호출하고, 그결과를 모아서 새로운 배열 만든다 return 이 없는 함수인 경우, 원래 배열의 원소 갯수만틈 undefined로 채워진 배열 만듬 과일이름이 들어있는 배열에, 각각원소에 juice 문자열을 덧붙여 새로운 배열 만듬 123let fruits = ['apple','banana','peach','blue berry'];let juice = fruits.map(fruit =&gt; `$&#123;fruit&#125; juice`); 객체로 이루어진 배열에서 , 특정 원소의 맴버 변수로만 이루어진 배열을 만든다 12345678let comments = [ &#123; id: 3, content: 'apexsoft' &#125;, &#123; id: 6, content: '우리모두' &#125;, &#123; id: 10, content: 'master가 되자' &#125;];let idx = comments.map( comment =&gt; &#123; return comment.id;&#125;); filter 각각 배열의 원소에 대해서 전달받은 함수의 결과가 true를 반환한 원소들로만 배열을 만듭니다. 객체 배열에서 어떤 특정한 조건에 맞는 원소들로만 배열을 만들고 싶다 ! 123456789let datas = [ &#123; id: 3, type: 'comment', content: 'apexsoft'&#125;, &#123; id: 6, type: 'post', content: '우리모두' &#125;, &#123; id: 10, type: 'comment' ,content: 'master가' &#125;, &#123; id: 6, type: 'post', content: '되나요?' &#125;];const filteredData = datas.filter( data =&gt; &#123; return data.type === 'post';&#125;); find 배열에서 특정 값을 검색할 때 find함수로 조건에 만족하는 원소를 반환하지 못하는 경우 undefined 를 반환합니다. find함수는 배열 원소에 대해서 주어진 함수연산을 하다가 함수가 true를 반환하면 find함수도 같이 종료됩니다. 123var ret = datas.find( data =&gt; &#123; return data.id === 10;&#125;); every 주어진 조건을 모두 만족하는지 확인 배열의 모든 원소들이 제공된 함수로 구현된 테스트를 통과하는지 검사 some 해당 조건을 하나라도 만족하면 참 123456789const users=[ &#123;nickname:'master'&#125;, &#123;nickname:'hskim'&#125;, &#123;nickname:'master'&#125;,]users.find(function(user)&#123; return user.nickname === 'master'&#125;) // 맨처음 찾은 것만 리턴 users.every(function(user){ return user.nickname === &apos;master&apos; }) // false users.some(function(user){ return user.nickname === &apos;master&apos; }) // true 12345678910* fill * 모든 배열 요소에 지정된 값으로 교체 ```javascript const arr2 = new Array(2).fill(undefined); // [undefined, undefined] ​123const arr4 = new Array(2).fill('x');// ['x', 'x']​ * 첫 번째 파라미터에 설정할 값을 작성합니다. * 두 번째 파라미터는 선택으로 범위 시작 인덱스를 작성하며 디폴트 값은 0입니다. * 세 번째 파라미터는 선택으로 범위 끝 인덱스를 작성하며 디폴트 값은 배열 length 값입니다 ​12345678910111213let one = [1, 2, 3];console.log(one.fill(7)); // [7, 7, 7]let two = [1, 2, 3, 4, 5];console.log(two.fill(7, 1)); // [1, 7, 7, 7, 7] let three = [1, 2, 3, 4, 5]; console.log(three.fill(7, 1, 3)); // [1, 7, 7, 4, 5]​ reduce 배열의 각 원소에 대해서 첫번째 원소부터 마지막 원소 순으로 연산한 값이 줄도록 함수 적용 12let scores = [1,2,3,4,5];let sum = scores.reduce((sum, number) =&gt; sum + number,0); (((( 1 + 2 ) + 3 ) + 4 ) + 5) 순으로 연산 0은 initial value로서 누산값의 초기값 Enhancde Object Literals object의 property가 key와 value가 동일하다면, 하나로 축약 가능 Rest 매개변수 Spread 연산자(...) 을 사용해서 매개변수를 정의하는것 인자를 함수 내부에서 배열로 전달 받을수 있다 인자를 함수 내부에서 배열로 전달 받을수 있다 1234function fruit(...rest)&#123; console.log(rest) // [\"사과\",\"배\",\"딸기\",\"바나나\"] 출력&#125;fruit(\"사과\",\"배\",\"딸기\",\"바나나\") 인자는 입력된 순서대로 기존 매개변수와 Rest 매개변수에 할당 된다 반드시 마지막 매개변수로 지정 되어야한다 123456function fruit(num1, num2,...rest)&#123; console.log(num1) // 10 출력 console.log(num2) // 20 출력 console.log(rest) // [\"사과\",\"배\",\"딸기\",\"바나나\"] 출력&#125;fruit(10,20\"사과\",\"배\",\"딸기\",\"바나나\") Spread 연산자 함수의 인자로 사용하는 경우 배열의 요소를 개별적으로 분리하여 순서대로 매개 변수에 할당 Rest 매개변수는, spread 연산자를 사용하여 매개변수를 정의한것 ! 두개가 다름 12345678function num(num1, num2,num3)&#123; console.log(num1) // 10 출력 console.log(num2) // 20 출력 console.log(num3) // 30 출력 &#125;cnost arr =[10,20,30]num(...arr); Rest 매개변수는 반드시 마지막에 작성 되어야 하지만, spread 연산자는 위치 상관 없이 자유롭다 12345678function num(num1, num2,num3,num4)&#123; console.log(num1) // 10 출력 console.log(num2) // 20 출력 console.log(num3) // 30 출력 console.log(num4) // 40 출력 &#125;num(10,...[20,30],40); 배열에서 사용하는 경우 객체에서 사용하는 경우 더 편하게 객체의 값을 복사 가능 123456789101112let myObj = &#123; prop1: 'Hello', prop2: 'World'&#125;;let newObj = &#123; name: 'George', prop1: myObj.prop1, prop2: myObj.prop2&#125;;console.log(newObj.prop1); // Hello 123456let newObj = &#123; name: 'George', ...myObj&#125;;console.log(newObj.prop1); // Hello 기존 12345678// store.jsnew Vuex.Store(&#123; state: &#123; prop1: ..., prop2: ..., prop3: ... &#125;&#125;); 123456789101112// app.jsnew Vue(&#123; computed: &#123; prop1() &#123; return store.state.prop1; &#125;, prop2() &#123; return store.state.prop2; &#125; ... &#125;&#125;); mapState 사용 1234import &#123; mapState &#125; from 'vuex';var state = mapState(['prop1', 'prop2', 'prop3']);console.log(state.prop1) // &#123; ... &#125; ... 연산자 사용 123456789// app.jsimport &#123; mapState &#125; from 'vuex';new Vue(&#123; computed: &#123; someLocalComputedProp() &#123; ... &#125;, ...mapState(['prop1', 'prop2', 'prop3']) &#125;&#125;);","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://apexsoft.github.io/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://apexsoft.github.io/tags/javascript/"}]},{"title":"@ 전송 Annotation","slug":"전송 어노테이션","date":"2018-11-26T02:53:50.532Z","updated":"2018-11-26T02:53:50.533Z","comments":true,"path":"2018/11/26/전송 어노테이션/","link":"","permalink":"http://apexsoft.github.io/2018/11/26/전송 어노테이션/","excerpt":"","text":"REST API 전송파라미터 앞에 @ModelAttribute와 @RequestBody를 사용했는데, 바인딩이 안되는 경우 에러를 찾지 못하는 경우 Client에서 Server로 Ajax call을 날렸다. 분명히 날렸음에도 인자값은 전달되지않고 Null Pointer Exception을 발생시켜버린다. 이유가 무엇일까? GET/POST 등은 각각의 다른 방식으로 데이터를 서버로 전송한다.GET URL에 데이터를 담아 전송하며 1차원 데이터밖에 담지 못한다(2차원 배열, 객체속 객체 등등은 불가능하다.) 따라서 검색조건 수준의 데이터를 담는게 옳바르다 POST Request 의 Body에 데이터를 담는데 이 경우 JSON, 다차원 데이터를 담을 수 있다. EX) 컨트롤러를 작성할 때 GET방식 메서드의 파라미터 앞에 @RequestBody 어노테이션을 붙혔다. 그럼 데이터 바인딩이 가능할까? “GET 방식 프로토콜은 Request 패킷에 Body가 존재하지 않는다. 따라서 데이터를 가져올 수 없다. “ EX)당연히 자동으로 바인딩해주는 줄 알고 파라미터에 @RequestBody 어노테이션을 쓰지 않았다. 하지만 테스트를 해보니 ‘java.lang.NullPointerException’가 개발자를 반겼다. 어디서부터 문제인가? “@RequestBody 어노테이션으로 명시해주지 않은 파라미터는 GET방식으로 데이터를 바인딩 시키기 때문에 결과적으로 NULL이 들어간다.POST방식은 Body에 데이터가 들어가 있기 때문이다.” 결론 : @RequestBody는 POST방식일때@RequstBody http 본문자체를 읽는 부분을 모델로 변환시켜주는 어노테이션이다. Rest API 만들때는 자주 사용하는 어노테이션이다. JSON 이나 XML같은 데이터를 적절한 messageConverter로 읽을때 사용하거나, POJO형태의 데이터 전체로 받을경우에 사용된다. Content-Type이 application/json 이거나 XML 페이지에서 FORM에 들어가는 객체를 Submit으로 전송할 때는 @RequestBody 형태로 넘어가지 않는다. HTML 기반의 컨텐츠 타입에서 데이터를 Submit할 때는 Content-Type이 application/x-www-form-urlencoded 방식으로 넘어가기 때문이다. 이 때 객체를 넘겨 받는 커텐츠의 Content-Type의 형태는 application/x-www-form-urlencoded 나 multipart/form-data 의 형태가 되어야한다. 반드시 POST형식으로 응답을 받는 구조여야만 한다. @ModelAttribute 기존에는 post방식으로 전송하면 파라미터를 객체와 맵핑 하였다 이전에는 api서비스가 많지 않았고 , 대부분 웹에서 form을 사용하여 submit을 하였기 때문에 POST로 넘어오는 객체 파라미터를 @ModelAttribute에 매핑하기 위해서는 HTTP Request의 컨텐트타입이 application/x-www-form-urlencoded 이나 multipart/form-data 이어야만 한다. application/x-www-form-urlencoded와 multipart/form-data의 차이는 POST를 전송할 때 MultipartFile 파일을 함께 전송하는지에 따라 차이가 난다. http 요청 파라미터를 VO로 받는다 (커맨드 객체라고도 한다.) 도메인이나 오브젝트로 파라미터를 받을 경우는 @ModelAttribute으로 받을수 있다. @RequestParam과 비슷한데 1:1로 파라미터를 받을경우는 @RequestParam를 사용하고, 검증(Validation)작업을 추가로 할수 있는데 예로들어 null이라던지, 각 멤버변수마다 valid옵션을 줄수가 있고 여기서 에러가 날 경우 BindException 이 발생한다. @ModelAttribute 어노테이션은 Parameter에 쓸 경우 받아오고자하는 데이터의 이름을 지정하여 해당 데이터만을 가져온다. EX) { name : &#39;master&#39;, comment : &#39;모두가 master가 되는 그날 까지 &#39; }이라고 ajax-data에 넣었다고 치고, 컨트롤러에 @ModelAttribute(‘comment’) String comment 라고 하면 comment속엔 ‘모두가 master가 되는 그날 까지’만을 받아온다. 결론 : @ModelAttribute는 받아오는 데이터를 ‘지정’한다. 파일 업로드 여러개의 파일을 가지고 있다면 List&lt;MutlipartFile&gt;을 추가하면 될 것이다. 우리는 JSON 타입의 결과를 받는데 MultipartFile을 JSON으로 serialization 을 할 수 없기 때문에 JSON으로 변경될 때 무시하기 위해서 @JsonIgnore 를 사용하였고 대신 fileName이라는 필드가 file이라는 JSON 프로퍼티로 첨부파일의 이름을 가지고 만들어질 수 있도록 @JsonProperty(“file”)로 추가하였다. 12345@RequestMapping(value = \"/articles\", method = RequestMethod.POST) @ResponseBody public Article submit(@ModelAttribute Article article, MultipartFile file)&#123; return article; &#125; 12345678910111213public class Article implements Serializable &#123; private long id; private String title; private String content; private List&lt;Comment&gt; comments; @JsonIgnore private MultipartFile file; @JsonProperty(\"file\") private String fileName; &#125; ###@RequestParam 요청 파라미터를 넣어주는 어노테이션이다. @PathVariable 마찬가지로 변수 앞에 작성해주면 된다. 만약 name이라는 파라미터를 넘겨 받는다면 아래와 같이 작성해 주면 된다. 1234public String hello(@RequestParam String name) &#123;/sample?name=wonwoo 또한 파라미터가 여러개일 경우에는 Map으로도 받을 수 있다. 1public String hello(@RequestParam Map&lt;String, String&gt; parameters) &#123; @Valid 델을 검증작업을 추가적으로 할 수 있다. 그 타입이 Errors 혹은 BindingResult로 검증 작업을 할 수 있다. ModelAttribute 혹은 RequestBody 어노테이션 바로 뒤에 작성되어야만 한다 자신의 바로 앞에 있는 모델만 검증 작업을 하기 때문이다 1234567891011121314151617181920212223242526@RestControllerpublic class SampleController &#123; @PostMapping(\"/sample\") public String hello(@ModelAttribute @Valid Account account, BindingResult result) &#123; if(result.hasErrors()) &#123; return \"error\"; &#125; return \"hello\"; &#125;&#125;class Account &#123; @NotBlank private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; @PathVariable 중괄호에 명시된 값을 변수로 받는다. 12@RequestMapping(\"/user/&#123;id&#125;\")public String userInfo(@PathVariable(\"id\") String id)","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://apexsoft.github.io/tags/spring/"},{"name":"SPRINGBOOT","slug":"SPRINGBOOT","permalink":"http://apexsoft.github.io/tags/SPRINGBOOT/"},{"name":"annotation","slug":"annotation","permalink":"http://apexsoft.github.io/tags/annotation/"}]},{"title":"vueRouter","slug":"vue-router","date":"2018-11-26T02:53:50.522Z","updated":"2018-11-26T02:53:50.523Z","comments":true,"path":"2018/11/26/vue-router/","link":"","permalink":"http://apexsoft.github.io/2018/11/26/vue-router/","excerpt":"","text":"#vue-router 뷰에서 라우팅 기능을 구현할 수 있도록 지원하는 공식 라이브러리 SPA(Single Page Application) 사용 페이지를 이동할 때 마다 서버에 웹 페이지를 요청하여 새로 갱신하는것이 아니라 미리 해당 페이지들을 받아놓고 페이지 이동 시에 클라이언트의 라우팅을 이용하여 화면을 갱신하는 패턴을 적용한 어플리케이션 라우팅이 경로에 따라 컴포넌트를 바꿔치기해서 렌더링 태그 사용라우터 링크 &lt;router-link to=&quot;url 값&quot;&gt; 페이지 이동 태그 to에 지정한 url로 이동 &lt;a&gt;태그 사용 안하는 이유 히스토리모드와 해쉬뱅 모드에서는 주소 체계가 달라서 &lt;a&gt; 태그를 사용할 경우 모드 변경시 주소값을 일일이 변경해 줘야한다. 하지만 &lt;router-link&gt;는 변경할 필요가 없다. &lt;a&gt; 태그를 클릭하면 화면을 갱신하는데 &lt;router-link&gt;는 이를 차단해준다. 갱신 없이 화면을 이동할 수 있다. 라우터 뷰 &lt;router-view&gt; 페이지 표시 태그 변경되는 url에 따라 해당 컴포넌트 뿌려줌 랜더링 해주는 부분 정의1234567const router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '/', component: Home &#125;, &#123; path: '*', component: NotFound &#125; ]&#125;) ###mode 기본값은 , 해쉬뱅 모드 history모드 사용 시 , 브라우져 history 객체의 pushState() API를 사용 routes 경로와 컴포넌트로 이뤄진 컬렉션 실제 이 맵을 보고 , 라우터가 경로에 따라 그에 맞는 컴포넌트를 렌더링한다 정의한 순서대로 경로를 매칭해서 컴포넌트를 출력 정의되지 않은 경로로 들어올결우 { path: &#39;*&#39;, component: NotFound } 설정에 의해 NotFound 컴포넌트가 그려질 것이다. children 중첩된 라우팅이 중첩된 화면을 구성한다(http://blog.jeonghwan.net/2018/04/07/vue-router.html) 특정 라우팅의 하위 경로가 변경됨에 따라 하위 컴포넌트로 변경할수 있는 기능 부모 컴포넌트 부분에는 &lt;router-view&gt;&lt;/router-view&gt; 반드시 들어가야 한다 이부분에 자식이 보여짐 1234567891011121314151617export default new VueRouter(&#123; routes: [ // 생략 &#123; path: '/posts', component: &#123; template: '&lt;div&gt;Posts &lt;br/&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;' &#125;, // 중첩된 라우트는 children 속성으로 하위 라우트를 정의할 수 있다. children: [ &#123; path: 'new', component: &#123; template: '&lt;div&gt;New Post&lt;/div&gt;' &#125; &#125;, &#123; path: 'detail', component: &#123; template: '&lt;div&gt;Post Detail&lt;/div&gt;' &#125; &#125; ] &#125; ]&#125;) 동적 라우트 매칭12345678910const User = &#123; template: '&lt;div&gt;User&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ // 동적 세그먼트는 콜론으로 시작합니다. &#123; path: '/user/:id', component: User &#125; ]&#125;) 동적 세그먼트는 콜론 :으로 표시됩니다. 라우트가 일치하면 동적 세그먼트의 값은 모든 컴포넌트에서 this.$route.params로 표시됩니다. 123const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125; 라우트 정의 우선순위로 처리 /post/new /post/:id 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;header&gt; &lt;h1&gt;Router&lt;/h1&gt; &lt;/header&gt; &lt;p&gt; &lt;router-link to=\"/main\"&gt;Main 컴포넌트로 이동&lt;/router-link&gt; &lt;router-link to=\"/login\"&gt;Login 컴포넌트로 이동&lt;/router-link&gt; &lt;/p&gt; &lt;router-view&gt;&lt;router-view&gt; &lt;!-- url 값에 따라 갱신되는 화면 영역 --&gt; &lt;/div&gt; &lt;hr&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router@3.0.1/dist/vue-router.js\"&gt;&lt;/script&gt; &lt;script&gt; var Main = &#123; template: '&lt;div&gt;main&lt;/div&gt;' &#125; var Login = &#123; template: '&lt;div&gt;Login&lt;/div&gt;' &#125; var routes = [ &#123;path:'/main', component:Main&#125;, &#123;path:'/login', component:Login&#125; ] var router = new VueRouter(&#123; routes &#125;); new Vue(&#123; el :'#app', router :router &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 정의되지 않은 경로로 들어올결우 { path: &#39;*&#39;, component: NotFound } 설정에 의해 NotFound 컴포넌트가 그려질 것이다. 라우터를 통해 값 전달###1. path에 key-value 전달 router.pash()의 인자로 path를 넘길때 , key-value 작성 1router.push(\"/login?key=value &amp;key2=value\") 받기 vue 객체의 query 이용 1this.$route.query.key 전달 값은 주소창에 노출되므로, 보안 내용은 금지한다 2.params를 이용한 값 전달 params를 이용할때는 name 와 props:true 사용 routes에 추가한다 12345678routes:[ &#123; path: '/user', name:'login', componet:Login, props:true &#125;] 전달 1router.push(&#123; name:'login',params:&#123;'key':'value'&#125; &#125;) path대신 name을 이용해 어떤 경로로 갈지 알려주고 params를 이용해 전달한 값을 객체로 알려준다 받기 1this.$route.params.key rul에 노출이 없엇, path 방법보다는 안전하다 ## 데이터 가져오기 매개 변수와 함께 라우트를 사용할 때 주의 해야할 점은 사용자가 /user/foo에서 /user/bar로 이동할 때 동일한 컴포넌트 인스턴스가 재사용된다는 것입니다. 두 라우트 모두 동일한 컴포넌트를 렌더링하므로 이전 인스턴스를 삭제 한 다음 새 인스턴스를 만드는 것보다 효율적입니다. 그러나 이는 또한 컴포넌트의 라이프 사이클 훅이 호출되지 않음을 의미합니다. 동일한 컴포넌트의 params 변경 사항에 반응하려면 $route 객체를 보면됩니다. 데이터 페치 : 서버로 부터 데이터를 가져오는 기능 각 화면별로 라우팅이 일어나는 시점에 데이터를 불러와야한다 화면이 리프레시 될 경우만 created훅이 동작한다 :id 값이 변경될때 같이 변경되는 것이 필요하다 =&gt;watch사용 created() 훅에서 가져온다 12345678910111213141516171819created() &#123; // 컴포넌트 생성시 데이터를 패치한다 this.fetchData()&#125;,watch: &#123; // 라우터 객체를 감시하고 있다가 fetchData() 함수를 호출한다 '$route': 'fetchData'&#125;,methods: &#123; fetchData () &#123; this.data = null this.loading = true Post.get(this.$route.params.key).then(data =&gt; &#123; this.data = data this.loading = false &#125;) &#125;&#125; ## 라우트 컴포넌트에 속성 전달컴포넌트에서 $route를 사용하면 특정 URL에서만 사용할 수 있는 컴포넌트의 유연성을 제한하는 라우트와 강한 결합을 만듭니다. 컴포넌트와 라우터 속성을 분리하려면 다음과 같이 하십시오. $route에 의존성 추가 12345678const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User &#125; ]&#125;) 속성에 의존성 해제 12345678910111213141516171819202122232425262728293031323334var MasterReqCncpDetail = &#123; template: `&lt;div&gt; 의뢰서 상세 &#123;&#123; param.reqType &#125;&#125; &#123;&#123; param.key &#125;&#125; 값 :&#123;&#123; param.keyNo &#125;&#125; &lt;/div&gt;` , data() &#123; return &#123;&#125;; &#125;, props: &#123; param: &#123; type: Object, default() &#123; return null; &#125;, &#125; &#125;, created() &#123; &#125;&#125;var router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '/master/request', component: &#123;template: '&lt;router-view&gt;&lt;/router-view&gt;'&#125;, children: [ &#123;path: 'reqList/:key/:keyNo', name: 'masterReqList', component: MasterReqList, props: true&#125;, &#123;path: ':reqType/detail', name: 'masterReqCncpDetail', component: MasterReqCncpDetail, props: true&#125;, &#125; ]&#125;) &lt;router-link :to=\"&#123; name:'masterReqCncpDetail',params: &#123;param: &#123;keyNo:'5', reqType:'proto',key:'reqNo'&#125;&#125;&#125;\"&gt;masterReqCncpDetail&lt;/router-link&gt;&lt;br&gt; 이를 통해 어디서나 컴포넌트를 사용할 수 있으므로 컴포넌트 재사용 및 테스트하기가 더 쉽습니다. ## ## ## 인증 플루우 권한이 있는 path로 만 들어가게 하기 SPA 개발에서는 로그인 후 서버에서 발급받은 액세스 토큰(access token)의 유무로 확인할 수 있다. 뷰 라우터에는 네비게이션 가드라는 기능이 있는데 이것이 인증 플로우를 구현하는데 적합하다. vue 각각에서 처리하면 번거롭다 - &gt; 라우터에서 생성되기 전에 체크를 한다 라우터가 타고 들어가는건, 해당 컴포넌트를 그리는 것이므로 그리기전에 체크한다 네비게이션 가드 라우터 설정 객체에는 beforeEnter() 함수를 추가할 수 있다. 이 함수는 경로에 따라 라우트 매칭을 결정하고 해당 컴포넌트를 생성하기 직전에 호출되는 함수다. 여기서 인증 여부를 판단한 뒤 컴포넌틀 랜더링을 진행하거나 혹은 로그인 페이지로 이동하는 등의 로직을 구현하면 된다. const requireAuth = (to, from, next) =&gt; { if (Auth.loggedIn()) return next() next({ path: &apos;/login&apos;, query: { redirect: to.fullPath } }) } { path: &apos;/posts&apos;, component: Posts, children: [{ path: &apos;new&apos;, component: NewPost, // 인증 여부를 체크하는 requreAuth를 beforeEnter 속성에 추가했다 beforeEnter: requireAuth }, 라우터 url에 해시 값(#)을 없애는 방법var router = new VueRouter({ mode:&apos;history&apos;, routes });","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"Chrome 브라우저로 Vue.js 디버깅하기","slug":"vscode_vue 프로젝트 디버깅","date":"2018-11-26T02:53:50.509Z","updated":"2018-11-26T02:53:50.509Z","comments":true,"path":"2018/11/26/vscode_vue 프로젝트 디버깅/","link":"","permalink":"http://apexsoft.github.io/2018/11/26/vscode_vue 프로젝트 디버깅/","excerpt":"","text":"[vsCode] Chrome 브라우저로 Vue.js 디버깅하기설치 Vue CLI 1&gt; npm install -g @vue/cli Debugger for Chrome 마켓플레이스에서 검색하여 설치 설정 config/index.js 123dev: &#123; devtool: 'source-map'&#125; webpack.dev.config.js 1devtool: 'source-map' 디버그설정 좌측메뉴에 디버그 메뉴 클릭 좌측상단에 디버그 구성 선택 &gt; launch.json파일 생성됨 12345678910111213141516&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"type\" : \"chrome\", \"request\" : \"launch\", \"name\" : \"vuejs: chrome\", \"url\" : \"http://localhost:3000\", \"webRoot\" : \"$&#123;workspaceFolder&#125;/src\", \"breakOnLoad\" : true, \"sourceMapPathOverrides\": &#123; \"webpack:///src/*\": \"$&#123;webRoot&#125;/*\" &#125; &#125; ]&#125; 디버그 실행 중단점 설정 프로젝트 실행 1&gt; npm start 디버그 실행 디버그 화면에서 실행버튼 클릭","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"vscode","slug":"vscode","permalink":"http://apexsoft.github.io/tags/vscode/"},{"name":"디버깅","slug":"디버깅","permalink":"http://apexsoft.github.io/tags/디버깅/"}]},{"title":"EventBus","slug":"이벤트 ","date":"2018-07-31T02:12:47.289Z","updated":"2018-07-31T02:12:47.290Z","comments":true,"path":"2018/07/31/이벤트 /","link":"","permalink":"http://apexsoft.github.io/2018/07/31/이벤트 /","excerpt":"","text":"이벤트비 부모자식이벤트 버스 생성1var EventBus = new Vue() 이벤트 발행1EventBus.$emit('message', 'hello world'); 인벤트 구독 bus 인스턴스에 바인딩 이벤트를 수신하는 쪽은 미리 이벤트 헨들러를 등록 해두어야 한다. vue 인스턴스 생명 주기 created 이벤트 훅을 통해서 ,$on메서드를 사용해 이벤트 수신 정보 등록 123EventBus.$on('message', function(text) &#123; console.log(text);&#125;); this 현재 인스턴스 바인딩 123EventBus.$on('isAdmin', text =&gt; &#123; this.isAdmin = text; &#125;); 이벤트 리스너 제거 모두제거 1EventBus.$off(); 1EventBus.$off(['message']); 부모 자식 통신부모 컴포넌트가 자식컴포넌트의 이벤트를 청취 @이벤트 리스너 부모 컴포넌트는 자식컴포넌트가 사용되는 템플릿에서 ,자식 컴포넌트에 발생한 이벤트를 직접 청취 할수 있다. update이벤트가 발생할때 , componentEvent 메서드가 실행된다 1&lt;apex-page @update=\"componentEvent($event)\":per-page=\"perPage\"&gt;&lt;/apex-page&gt; 자식 (apex-page) 123456props: &#123; perPage: &#123; type: Number, default: () =&gt; 10 &#125; &#125; 123 methods: &#123; this.$emit('update', res.data); &#125; 부모 123456componentEvent($event) &#123; this.projectResults = $event.content; this.totalItems = $event.totalElements; this.searchData = $event.searchData; this.perPage = $event.size; &#125;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"}]},{"title":"영속성 컨텍스트","slug":"영속성 컨텍스트 트랜잭션","date":"2018-07-31T02:12:47.288Z","updated":"2018-07-31T02:12:47.288Z","comments":true,"path":"2018/07/31/영속성 컨텍스트 트랜잭션/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/영속성 컨텍스트 트랜잭션/","excerpt":"","text":"영속성 컨텍스트 엔티티를 영구 저장하는 환경 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다 엔티티의 생명주기 비영속 (영속성 컨텍스트와 전혀 관계가 없는 상태) 영속 (영속성 컨텍스트에 저장된 상태) 준영속 (저장되었다가 분리) 삭제 영속성 컨텍스트 특징 영속성 컨텍스트 엔티티 = 식별자 값 (@id) 로 매핑 동일성 보장 변경 감지 변경 감지 스냅샷 : jpa는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장해둔다 플러시 시점에 스탭샷과 엔티티를 비교해서 변경된 엔티티를 찾는다 트랜잭션 커밋 = 엔티티 매니저 플러시가 호출 스냅샷으로 변경된 엔티티 찾는다 변경된 엔티티가 있으면 수정 쿼리를 생성해서 , 쓰기 지연 sql 저장소에 보낸다 쓰기 지연 저장소의 sql을 데이터 베이스에 보낸다 데이터베이스의 트랜잭션을 커밋한다 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다. 트랜잭션 범위의 영속성 컨텍스트스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 사용한다 트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 같다 트랜잭션을 시작할 때 영속성 컨텍스를 생성하고 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다 ​ 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다 123456789@Transactionalpublic class ProjectService &#123;public void delete(int projectCode) &#123; Project project = projectRepository.findOne(projectCode); project.setProjectFlag(\"0\"); &#125;&#125; @Transactional 선언해서 , 메소드를 호출할 때 트랜잭션을 먼저 시작한다 project는 영속 상태 projectRepository.findOne(projectCode) 통해 조회한 project엔티티는 트랜잭션 범위 안에 있으므로 ,영속성 컨텍스트의 관리를 받는다 project는 영속 상태로 변경 감지가 가능한다 @Transactional 선언한 메소드가 정상 종료 되면 트랜잭션 커밋 = 영속성 컨텍스트 종료 = 엔티티 매니저 플러시가 호출 스냅샷으로 변경된 엔티티 찾는다 변경된 엔티티가 있으면 수정 쿼리를 생성해서 , 쓰기 지연 sql 저장소에 보낸다 쓰기 지연 저장소의 sql을 데이터 베이스에 보낸다 데이터베이스의 트랜잭션을 커밋한다 ​ ​ ​","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"아임포트 소개 및 사용방법","slug":"아임포트 소개 및 사용방법","date":"2018-07-31T02:12:47.286Z","updated":"2018-07-31T02:12:47.287Z","comments":true,"path":"2018/07/31/아임포트 소개 및 사용방법/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/아임포트 소개 및 사용방법/","excerpt":"","text":"아임포트 (I’mport) http://www.iamport.kr/ PG사 결제모듈과 시스템 사이를 연동해주는 라이브러리 결제모듈 안에서 일어나는 행위에 전혀 영향을 주지 않음. PG사 한개까지는 무료 다양한 REST API 제공 https://api.iamport.kr/ 사용 방법 아임포트 관리자모드 회원가입 관리자 페이지 안에서 PG사 선택 소스코드 html12&lt;script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.12.4.min.js\" &gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://service.iamport.kr/js/iamport.payment-1.1.5.js\"&gt;&lt;/script&gt; javascript12var IMP = window.IMP; // 생략가능IMP.init('iamport'); // 'iamport' 대신 부여받은 \"가맹점 식별코드\"를 사용 (관리자페이지에서 확인) 결제 요청 부분 javascript12345678910111213141516171819IMP.request_pay(&#123; pg: 'uplus', // version 1.1.0부터 지원. pay_method: method, merchant_uid: this.merchantId, name: 'project ID: ' + this.projectId, amount: this.amount, buyer_email: this.buyerEmail, buyer_name: this.buyerName, buyer_tel: this.buyerTel&#125;, rsp =&gt; &#123; console.log(rsp); if (rsp.success) &#123; // 결제 성공 후 처리 // 주로 서버에 결제 데이터 저장 &#125; else &#123; // 결제 실패 처리 // 결제 실패 alert &#125;&#125;); pay_method : card (신용카드), trans (실시간계좌이체), vbank (가상계좌) Notification URL 관리자페이지 &gt; 시스템설정 &gt; PG설정(일반결제 및 정기결제) 탭에서 설정 아임포트 서버에서 가맹점서버로 호출함으로 외부에서 접근 가능한 URL이여야 함 설정한 URL로 {“imp_uid”:”imp_1234567890”,”merchant_uid”:”merchant_1234567890”,”status”:”ready”} Body가 POST로 전송됨 신용카드 결제, 실시간계좌이체, 가상계좌발급, 가상계좌입금확인시에 호출됨 호출 상황 status 신용카드 결제 완료 paid 실시간계좌이체 완료 paid 가상계좌 발급 완료 ready 가상계좌 입금 확인 paid 테스트 관리자페이지 &gt; 시스템설정 &gt; PG설정에서 테스트모드 ON 가상계좌 입금통보 테스트 관리자페이지 &gt; 결제승인내역 페이지 안 ‘테스트 가상계좌 입금통보 호출’버튼 클릭 (설정한 Notification URL이 호출됨) 실제 사용 관리자페이지 &gt; 시스템설정 &gt; PG설정에서 테스트모드 OFF lgdacom/conf/mall.conf 파일 안에 상점아이디와 MertKey 입력 차후결제 취소 기능 구현도 가능할 것으로 보임. 확장하여 기능을 추가하는 것도 좋을 것 같음.","categories":[],"tags":[{"name":"아임포트","slug":"아임포트","permalink":"http://apexsoft.github.io/tags/아임포트/"},{"name":"결제모듈","slug":"결제모듈","permalink":"http://apexsoft.github.io/tags/결제모듈/"}]},{"title":"배치프로그램, Quartz","slug":"배치 프로그램 (Batch)","date":"2018-07-31T02:12:47.282Z","updated":"2018-07-31T02:12:47.283Z","comments":true,"path":"2018/07/31/배치 프로그램 (Batch)/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/배치 프로그램 (Batch)/","excerpt":"","text":"배치 프로그램 (Batch)사용자와 상호작용 없이 대량의 데이터를 작업단위로 묶어서 정지거으로 수행하거나 정해진 규칙에 따라 자동으로 수행 정기 배치 : 정해진 시점에 실행 예) 일정 기간이 지나면 비밀번호 변경을 권장하는 페이지 보여줌 이벤트성 배치 : 사전에 정의해 둔 조건이 충족되면 자동으로 실행 ON-DEMAND 배치 : 사용자의 명시적 요구가 있을 때 실행 스프링 배치는 스케쥴링 기능을 제공하지 않음 Quartz주기적인 작업을 처리하기 위해서 사용 스케쥴러 동작방식 Simple : interval time 으로 동작하는 방식, 몇초, 분, 시간 단위로 작동하고 싶을 때 사용 Cron : 몇월, 몇일 몇시마다 동작하고 싶으면 사용 (예- 매일 10시15분에 실행) Cron Expression (표 - 각각의 필드) | 필드 이름 | 허용값 || ————— | —————— || Seconds | 0 ~ 59 || Minutes | 0 ~ 59 || Hours | 0 ~ 23 || Day-of-month | 1 ~ 31 || Month | 1 ~12 or JAN ~ DEC || Day-Of-Week | 1 ~ 7 or SUN-SAT || Year (optional) | empty, 1970 ~ 2099 |","categories":[],"tags":[{"name":"Quartz","slug":"Quartz","permalink":"http://apexsoft.github.io/tags/Quartz/"},{"name":"Spring","slug":"Spring","permalink":"http://apexsoft.github.io/tags/Spring/"},{"name":"배치","slug":"배치","permalink":"http://apexsoft.github.io/tags/배치/"}]},{"title":"다국어처리","slug":"다국어 처리 적용하는 방법","date":"2018-07-31T02:12:47.277Z","updated":"2018-07-31T02:12:47.278Z","comments":true,"path":"2018/07/31/다국어 처리 적용하는 방법/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/다국어 처리 적용하는 방법/","excerpt":"","text":"다국어 처리 적용하는 방법en.js : 영문 번역본 파일ko.js : 한글 번역본 파일 파일위치 : resource/static/js/lang json 형태로 키값을 만들어주어야 함 영문과 한글 번역본의 키값은 동일해야 함 123456789&gt; var ko = &#123;&gt; message: &#123;&gt; hello: “안녕”&gt; &#125;,&gt; userid:&#123;&gt; required :\"필수입력\"&gt; &#125;&gt; &#125;;&gt; Freemarker 문구가 들어가는 부분에 ‘키값’ 맞춰서 작성 123456789&lt;body&gt; &lt;div id=’app’&gt; &#123;&#123; $t(“message.hello”) &#125;&#125; &lt;input name=\"userId\" v-bind:placeholder=$t(\"userid.required\") v-model=\"userId\"&gt; &lt;/div&gt;&lt;/body&gt; Javascript el: &#39;#app&#39; 아랫줄에 i18n: apex_lang 삽입 12345678910111213new Vue(&#123; el: '#app', i18n: apex_lang, data: &#123; userId: '', password: '' &#125;, methods: &#123; onSignIn: function() &#123; alert(apex_lang.t(‘message.hello’)); &#125; &#125;&#125;);","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"i18n","slug":"i18n","permalink":"http://apexsoft.github.io/tags/i18n/"}]},{"title":"JPA기본키설정","slug":"기본키설정","date":"2018-07-31T02:12:47.276Z","updated":"2018-07-31T02:12:47.276Z","comments":true,"path":"2018/07/31/기본키설정/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/기본키설정/","excerpt":"","text":"@Entity테이블과 매핑할 클래스는 필수로 붙혀야 함 클래스에 @Entity 를 붙여주면 JPA가 Entity로서 관리 한다는 것을 의미한다. 속성 name다른 Entity와 충돌이 우려될 경우 이름을 바꿔준다. 기본적으로는 Class명을 따른다. 주의사항 기본 생성자 필수 final, enum, interface, inner 클래스 사용 못함 저장 필드에 final 사용 못함 @Table엔티티와 매핑할 테이블을 지정 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용. name : 매핑할 테이블 이름 속성 name매핑할 table 이름, 기본은 Entity 이름을 사용한다. catalogcatalog 기능이 있는 DB에서 catalog를 매핑 schemaschema 기능이 있는 DB에서 schema를 매핑 uniqueConstraintsDDL 생성 시에 유니크 제약조건을 만든다. @Id기본키 직접 할당 자동 생성(Auto_Increment) 123@GeneratedValueprivate String userId; ​ @EmbeddedId2개이상의 기본키 조합 1234567891011121314@Entity@Getter@Setter@Table(name = \"COMM_CODE\")@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"commCodeId\")public class CommCode extends BaseEntity implements Serializable &#123; @EmbeddedId private CommCodeId commCodeId; @Column(name = \"CODE_VAL\") private String codeVal;&#125; 1234567@Embeddablepublic class CommCodeId implements Serializable &#123; private String codeGrp; private String code;&#125; @Column객체 필드를 테이블 컬럼에 매핑 name : 필드와 매핑할 테이블의 컬럼 이름. 기본값이 필드 이름 123456@Column(name = \"cart_id\")private Long id;private String name;&gt;&gt;&gt; 매핑 정보가 없는 필드 &gt;&gt; 자동으로 매핑 columnDefinition : 데이터베이스 컬럼 정보를 직접 설정. nullable : null 값 허용 여부 false일 경우, not null 제약조건이 됨. 기본값이 true update 여부 설정 1234@CreatedDate@Column(name = &quot;created_at&quot;, updatable = false)@JsonIgnoreprivate LocalDateTime createdDateTime; @Transient필드는 매핑 하지 않는다. 데이터베이스에 저장하지 않고 , 조회하지도 않는다 객체에 임시로 어떤 값을 보관하고 싶을때 사용한다","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"Spring security config 예제","slug":"간결한 spring security configure","date":"2018-07-31T02:12:47.275Z","updated":"2018-07-31T02:12:47.275Z","comments":true,"path":"2018/07/31/간결한 spring security configure/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/간결한 spring security configure/","excerpt":"","text":"간결한 spring security configure123456789101112131415161718192021222324@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .antMatcher(\"/unreal/**\") .csrf()// .disable() .ignoringAntMatchers(\"/unreal/**\") .and() .formLogin() .loginProcessingUrl(\"/unreal/auth/login\") .usernameParameter(\"username\") .passwordParameter(\"password\") .successHandler(loginSuccessHandler()) .failureHandler(loginFailureHandler()) .and() .logout() .logoutRequestMatcher(new AntPathRequestMatcher(\"/unreal/logout\")) .logoutSuccessHandler(logoutSuccessHandler()) .and() .authorizeRequests() .antMatchers(\"/user/**\").hasRole(\"USER\") .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .anyRequest().permitAll();&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"Security","slug":"Security","permalink":"http://apexsoft.github.io/tags/Security/"},{"name":"springboot","slug":"springboot","permalink":"http://apexsoft.github.io/tags/springboot/"}]},{"title":"web 서버","slug":"web 서버","date":"2018-07-31T02:12:47.273Z","updated":"2018-07-31T02:12:47.274Z","comments":true,"path":"2018/07/31/web 서버/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/web 서버/","excerpt":"","text":"web 서버 웹 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고, HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램 초기 웹은 정보교환이 목적이었기 때문에 전송할 데이터가 정적인 데이터뿐이었다. (html, img, xml…) 따라서 그에 맞는 기능에 충실하였고, 지금도 정적인 데이터를 전송하는데는 웹서버가 안정적이다 웹서버의 표준으로 불리는 것이 있다. 바로 ‘Apache’이다. 시간이 흐르면서 웹을 사용하는 용도는 변화했습니다. 데이터를 주고 받으면서 화면이 동적으로 움직여야 했습니다. 입력된 값에 따라 출력된 결과가 나타나는 것이죠. 그런 요구에 따라 나타난게 Web Application Server입니다. 핵심정리 : apache = 웹서버 Web Application 서버 WAS 동적인 변화를 위해 만들어진 서버입니다. 웹서버는 정적인 데이터를 처리했다면, WAS는 동적인 데이터를 담당하겠죠. 사용자의 요청으로 데이터의 조작이 가능하고 그에 따라 화면의 동적으로 변하는 것을 가능하게 도와주는 서버입니다. 동적인 데이터 뿐만 아니라 정적 데이터도 처리가 가능하다는 것입니다. 그러나 큰 프로젝트나 많은 사용자를 가진 웹서비스는 흔히 웹서버와 WAS를 함께 사용합니다. 그 이유는 각각의 역할을 구분하여 더 효율적인 일을 하기 위해서이죠. 위에서도 밝혔듯이 웹서버는 정적인 데이터를 WAS에 비해 더 안정적이고 빠르게 다룰 수 있습니다. 그런 이유로 apache 와 WAS를 연동하여 사용하는 경우가 대부분입니다 ​ 핵심정리 : Web Application Server (웹서버 + 웹 컨테이너) = tomcat(WAS) Web서버와 Web Container의 역할을 둘다 감당하고 있는 것을 볼 수 있습니다. tomcat만으로도 웹서비스를 할 수 있습니다. 그러나 웹서버 apache와 함께 연동해서 역할을 구분해주면 더욱 강력하게 사용할 수 있습니다. ​ Web Container 웹컨테이너는 자바언어에서 사용하는 개념입니다. 서블릿(Servlet) &amp; JSP를 구동하기위해 필요한 것이 웹컨테이너이죠. (서블릿에 대한 더 자세한 설명) 서블릿은 자바로 작성되어 있기 때문에 따로 이를 구동시켜줄 프로그램이 필요합니다. 그것이 바로 웹컨테이너라 이해하며 되겠습니다. ​ Web 서버, WAS의 차이웹서버는 정적인 데이터 (html, img, xml…) 를 처리합니다. 웹서버를 통하면 WAS 보다 빠르고 안정적입니다. WAS는 동적인 데이터를 처리하는 서버이고 데이터베이스에 연결되어 데이터를 주고받아 웹어프리케이션을 운영합니다. IOC 제어의 역전 객체 생성을 직접 하지 않고 WAS(Web Application Service / 톰캣) 또는 프레임워크(스프링)가 생성해주는 객체를 가져다 사용 하는 것 WAS는 대부분 서블릿 객체를 자동으로 생성 Spring은 설정파일에 만든 Bean을 자동으로 생성 Ioc를 이용하게 되면 생성과 소멸을 WAS나 프레임워크가 담당하게 되어 싱글톤을 만드는 코드나 메모리 정리 등의 코드를 우리가 하지 않도 되기 때문에 관리가 편하다 @Component @Contoller, @Service, @Repository의 상위 개념으로 자동으로 Bean을 등록하고 싶은 곳에 사용된다. 객체를 등록하고 싶은 클래스 위에 썾면 Bean으로 등록 해달라는 표시 빈으로 등록할 Class에 선언하는 annotation @Configuration의 @ComponentScan에 의해서 scan되고 빈으로 등록 됨 Stereotype annotation &gt; @Component를 용도에 따라 미리 정형화 해놓은 타입 stereotype들은 내부적으로 @Component를 가지고 있음 @Repository - DAO 또는 레포지토리 클래스에 사용 &gt;예외를 모두 DataAccessException으로 변환 처리 @Service - 서비스 계층의 클래스에 사용 @Controller - 프레젠테이션 계층의 MVC 컨트롤러에 사용 presentation layer의 controller에 적용 spring web servlet에 의해 웹 요청을 처리하는 controller bean 선정 객체풀 부팅과 동시에 자신이 가져야할 객체를 생성(스프링빈)한다. 객체를 쌓아두었다가 필요할 때 주입. 쌓아둔 모양이 콩처럼 겼다고 해서 beans. DI (의존성 주입) Dependence Injection 원하는 부품 목록을 작성하면, Spring이 조립해준다. 필요한 객체는 스프링을 통해서 주입받는 구조. xml이나 어노테이션(@)를 통하여 객체 간 의존 관계를 설정. 객체 자체를 직접 생성 또는 검색 할 필요가 없다 @Autowired● 컨테이너에 들어있는 빈 객체 중에서 타입이 일치하는 빈 객체를 주입시킴 ● 타입이 일치하는 빈 객체가 없으면 ? ! ? ! ? → 에러 !! 해당 빈 객체 자체가 등록이 안되고, 그러면 컨테이너 자체가 빌드가 안됨 → 에러는 안띄우고 그냥 주입없이 가고 싶으면 .. ? required값을 false로 지정 : @Autowired(required = false) 컨테이너가 생성안돼서 생기는 BeanCreateException 에서 생성은 되지만 넣을게 없는 NullPointerException ​ ​ ​ ​ spring boot최소한의 노력으로 spring 기반의 프로젝트를 시작 할 수 있도록 도와주는 기술사용 이유 단독으로 상용제품 수준의 스프링 기반 애플리케이션 자바 기반에서는 WAS (웹 컨테이너 / 웹 서버 역활 )가 없이는 웹 애플리케이션이 구동하지 않았습니다. 하지만, Spring Boot를 사용하면 이런 복잡한 WAS 설치나 배포 없이 stand-alone 으로 웹 프로젝트를 생성하고 java –jar 명령어를 통해 tomcat이나 jetty를 내장한 상태로 웹 애플리케이션을 실행할 수 있습니다 최소한의 설정으로 spring 플랫폼과 서드파티 라이브러리 사용 구성시 설정을 위한 xml 코드를 생성하거나 요구하지 않음 Java-based configuration 메인 클래스에 @Configuration 과 main method를 두자 @ImportResource xml 설정을 import @EnableAutoConfiguration classpath 의 jar dependencies를 참고해서 자동으로 설정을 해준다. 현재 자동 설정된 내용을 알고 싶으면 스프링부트를 –debug 모드로 시작하면 콘솔 로그를 통해 확인 가능 하다 Classpath의 내용에 기반해서 알아서 설정 작업들을 해준다. 즉, classpath에 tomcat-embed-core.jar 가 존재 하면 톰캣 서버가 세팅되고, spring-webmvc.jar가 존재하면 자동으로 web.xml을 생성해 DispatcherServlet을 등록해준다. = @RestController = @Controller + @ResponseBody 별도의 @RequestMapping된 메소드들 마다 일일이 @ResponseBody를 붙이지 않아도 된다. ​ ymlyml 설정하기yml12345678910111213141516---spring.profiles: awsfile.rootDir: gradnetpay: lgdacom: /opt/lgdacom casnoteurl: https://casnote.gradnet.co.kr/yonsei/casnote/notice---spring.profiles: rdsspring.datasource: type: org.apache.tomcat.jdbc.pool.DataSource driver-class-name: com.mysql.jdbc.Driver---spring.profiles: prodpay.platform: serviceaws.s3.bucketName: apexsoft.service.gradnet.upload — 구분 된다 사용 vm argument 에 정보를 넣는다 1234-Dspring.profiles.active=aws,rds,prod$ java -jar -Dspring.profiles.active=aws,rds,prod -Dfile.encoding=UTF-8 -jar build/libs/gradnet-0.0.1-SNAPSHOT.jar","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://apexsoft.github.io/tags/web/"},{"name":"server","slug":"server","permalink":"http://apexsoft.github.io/tags/server/"}]},{"title":"vue.js 기본","slug":"vue 정리","date":"2018-07-31T02:12:47.272Z","updated":"2018-11-26T02:53:50.515Z","comments":true,"path":"2018/07/31/vue 정리/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/vue 정리/","excerpt":"","text":"JSBin 브라우저에서 JavaScript, CSS, HTML 코드를 작성 하여 실시간으로 결과를 확인 할 수 있는 서비스 https://jsbin.com/fivomus/edit?html,output MVVM ( Model-View-ViewModel ) 웹페이지는 돔(사람들이 눈으로 보는 페이지 ) 과 자바스크립트의 연합으로 만들어지게 되는데 돔이 View 역할을 하고, 자바스크립트가 Model 역할을 한다. ​ 뷰모델이 없는 아키텍처에서는 getElementById 같은 돔 API를 직접 이용해서 모델과 뷰를 연결해야 한다. 자바스크립트에서 컨트롤러 혹은 프리젠터 역할까지 하면서 코드양이 증가하는 단점이 생기기게 되는데 제이쿼리를 이용해 돔에 데이터 뿌려주는 코드들이 대부분 그랬다. view와 model 그 사이에서 View와는 바인딩이나 커멘드로 연결하고 Model과는 Data를 주고 받는 역할을 담당 뷰모델이 대신 수행해 주는 것이 MVVM 모델이다. 뷰모델에 자바스크립트 객체와 돔을 연결해 주면 뷰모델은 이 둘간의 동기화를 자동으로 처리한다. 이것이 뷰js가 하는 역할이다. MVC 패턴에서 컨트롤러 역할처럼 데이터를 관리하고 액션을 처리한다. 뷰모델 View Model MVVM 모델의 VM을 뷰js가 담당한다. MVC 패턴에서 컨트롤러 역할처럼 데이터를 관리하고 액션을 처리한다. Vue 생성자 함수의 인스턴스를 생성하면서 뷰 모델을 다루게 된다. 아래 예제와 같이 인스턴스를 생성할 때 뷰와 데이터를 연결하기 위한 옵션을 설정할 수 있다. 뷰 관련 옵션 : el, template 데이터 관련 옵션 : data, methods, computed 컴포넌트 관련 옵션 : components 생명 주기 훅 : created, mounted, updated, destroyed 데이터 관련 옵션computed( 선언적 의존 관계) computed 라는 의미는 진짜 말그대로 “계산된” 으로 해석이 됩니다. 선언적으로 의존 관계를 만들었다는 것입니다. 기본적으로 getter만 가지고 있지만, 필요한 경우 setter를 제공할 수 있습니다. 기본 (getter 사용)vue.js123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) computed (계산된) setter computed는 기본적으로 getter만 가지고 있지만 필요한 경우 setter를 제공함 vue.js1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 처음 fullname이 시작될 떄는 get부분의 코드가 작동된다는 뜻이며, fullname이란 값이 변한다면 set에 있는 함수가 작동된다는 것이다. 사용 html123456789&lt;div id=\"product-list-bottom\"&gt; &lt;div v-if=\"noMoreItems\"&gt;No more items&lt;/div&gt; &lt;/div&gt;computed: &#123; noMoreItems: function() &#123; return this.items.length == this.results.length &amp;&amp; this.results.length &gt; 0 &#125; &#125; ​ 감시자(watch) 대부분은 computed가 더 적합하지만 일부는 watch 가 필요한 경우가 있음 데이터 변경에 대한 응답으로 비동기식 또는 시간이 많이 소요되는 조작을 수행할 때 사용 우리나라말로 해석하면 감시자와 같습니다. 값의 변화를 주시하는 역할 우리가 알고있는 input text 에 이벤트로 onkeyup 을 넣으면 값이 들어오는걸 주시하고 있죠. onfocus 도 포커싱이 들어오면 바로 반응을 합니다. 이렇든 개발자들에게 감시자라는 단어는 매우 친숙하게 다가옵니다. ​ 우선 이 기능은 미리 data 안에 선언해주어야 합니다. 우리가 전역변수를 만들듯이 data , state , props 개념으로 사용되죠. n또한 v-model 과 함께 사용됩니다. 우리가 배운 v-model 은 양방향 바인딩이라고해서 클라이언트 측에서 데이터를 보내면 Script 단에 바로 받아 데이터를 수정해버립니다 v-model로 양방향 바인딩을 합니다. 즉 always 에 변화가 있을때 watch가 그걸 알아 차리고 그에 맞게 선언된 always 에 function 을 작동시킵니다. vue.js123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model='always'/&gt; &lt;div&gt;&#123;&#123;ing&#125;&#125;&lt;/div&gt;&lt;/div&gt;var demo = new Vue(&#123; el : \"#app\", data : &#123; always : '', ing : \"입력을 기다리는 중입니다.\" &#125;, watch : &#123; always : function(hook)&#123; console.log(hook) this.ing = \"입력중......\" this.fail(this.always); &#125; &#125;, methods : &#123; fail : function(text)&#123; if(text.length &lt; 5)&#123; this.ing = '5글자 이상이어야 합니다.'; &#125; &#125; &#125;&#125;) 계산된 캐싱(Computed Caching) vs 메소드(Methods) 둘다 vue.js 안에서 함수를 정의하는 부분 ​ 둘의 차이점은 데이터가 변동되지 않는다고 가정했을때에 드러난다. computed 데이터 변동이 없는 상태에서 computed는 이전의 계산된 값을 캐시해 두었다가 함수 호출시 다시 쓰게 된다. 종속성 중 일부가 변경된 경우에만 다시 계산 methods 사용될 때마다 함수의 계산을 다시 하게 된다. 종속성에 따라 캐시된다 만약 데이터가 자주 변동되지 않는다면, 비용적인 면에서는 computed가 좋다고 할 수 있고, 데이터가 수시로 업데이트 된다면 계속해서 캐시를 저장하는 computed보다는 methods가 더 좋을 수 있다. 그래서인지 html 상에서 computed는 마치 변수처럼 쓰이고, methods는 함수처럼 쓰인다. 예를들어 똑같은 parse라는 함수가 있다면 computed는 parse를 그대로 쓰고 methods는 parse()라고 쓰게 된다. 계산된 속성(Computed) vs 감시된 속성(Watched)html1&lt;div id=\"demo\"&gt; &#123;&#123; fullName &#125;&#125; &lt;/div&gt; vue.js12345678910111213141516var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 위의 코드를 보면 firstName 과 lastName 의 코드가 중복되므로 효율적이지 못함이때는 computed를 이용한다면 아래와 같이 한줄로 작성 가능해짐 vue.js123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) Template사용하기 편하고 반복적으로 사용할 수 있는 플랫폼 Component템플릿은 뭔가 추상적인 개념이라고 한다면 컴포넌트는 이를 구현할 기술이라고 생각해보죠. 독립적인 JS 하나당 component 하나를 만들어서 기능을 줘서 반복사용을 통해 활용성을 높이고 유지보수도 간편하게 할 수 있습니다. text 나 값은 props 나 data로 바꾸면 되니까요. 컴포넌트는 Vue의 가장 강력한 기능 중 하나입니다. 기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 캡슐화하는 데 도움이 됩니다. 상위 수준에서 컴포넌트는 Vue의 컴파일러에 의해 동작이 추가된 사용자 지정 엘리먼트입니다. 경우에 따라 특별한 is 속성으로 확장 된 원시 HTML 엘리먼트로 나타날 수도 있습니다. 새 vue 인스턴스 만들기 (root 인스턴스 생성) vue.js1234// 루트 인스턴스 생성new Vue(&#123; el: '#example'&#125;) ​ 전역 컴포넌트 등록 vue.js1234// 등록Vue.component('my-component', &#123; template: '&lt;div&gt;사용자 정의 컴포넌트 입니다!&lt;/div&gt;'&#125;) 컴포넌트는 인스턴스의 템플릿에서 커스텀 엘리먼트,&lt;my-component&gt;&lt;/my-component&gt;로 사용할 수 있습니다. 루트 Vue 인스턴스를 인스턴스화하기 전에 컴포넌트가 등록되어 있는지 확인하십시오. html123&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 모든 컴포넌트를 전역으로 등록 할 필요는 없습니다. 컴포넌트를 components 인스턴스 옵션으로 등록함으로써 다른 인스턴스/컴포넌트의 범위에서만 사용할 수있는 컴포넌트를 만들 수 있습니다: vue.js12345678910var Child = &#123; template: '&lt;div&gt;사용자 정의 컴포넌트 입니다!&lt;/div&gt;'&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 는 상위 템플릿에서만 사용할 수 있습니다. 'my-component': Child &#125;&#125;) data 는 반드시 함수여야합니다. Vue 생성자에 사용할 수 있는 대부분의 옵션은 컴포넌트에서 사용할 수 있습니다. 한가지 특별한 경우가 있습니다. data 는 함수여야 합니다. 컴포넌트 작성컴포넌트는 부모-자식 관계에서 가장 일반적으로 함께 사용하기 위한 것입니다. 컴포넌트 A는 자체 템플릿에서 컴포넌트 B를 사용할 수 있습니다. 그들은 필연적으로 서로 의사 소통이 필요합니다. 부모는 자식에게 데이터를 전달해야 할 수도 있으며, 자식은 자신에게 일어난 일을 부모에게 알릴 필요가 있습니다. 그러나 부모와 자식이 명확하게 정의된 인터페이스를 통해 가능한한 분리된 상태로 유지하는 것도 매우 중요합니다. 이렇게하면 각 컴포넌트의 코드를 상대적으로 격리 할 수 있도록 작성하고 추론할 수 있으므로 유지 관리가 쉽고 잠재적으로 쉽게 재사용 할 수 있습니다. Vue.js에서 부모-자식 컴포넌트 관계는 props는 아래로, events 위로 라고 요약 할 수 있습니다. 부모는 props를 통해 자식에게 데이터를 전달하고 자식은 events를 통해 부모에게 메시지를 보냅니다 v-bind를 사용하여 부모의 데이터에 props를 동적으로 바인딩 할 수 있음데이터가 상위에서 업데이트 될 때마다 하위 데이터로도 전달된다. html12345&lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt; 위와같이 코드를 작성하면 입력창에 입력하면 아랫줄에 같은 내용이 실시간으로 바인딩된다. 디렉티브 (Directive) 엘리먼트에게 이러이러하게 작동해라! 하고 지시를 해주는 지시문 vue 엘리먼트에서 사용디는 특별한 속성 디렉티브는 Vue 의 기능들을 사용하기 위해서 사용하는, HTML 태그 안에 들어가는 하나의 속성 v-text 이런 식으로 v- prefix 를 지니고 있습니다. ​ HTML 태그 안의 내용을 Vue 인스턴스 안의 데이터값으로 설정 할수 있음 머스태쉬 태그나, 디렉티브를 사용 할 때, 그 내부의 값을 꼭 데이터 명으로 해야 하는건 아니다. 자바스크립트 표현식을 사용 할 수도 있습니다. html12&gt; &lt;h1&gt;&#123;&#123; Date() &#125;&#125;&lt;/h1&gt;&gt; ​ 머스태쉬 태그 내부의 값으로 데이터 명 , 자바스크립트 표현식 을 사용 할수 있다. html12/* Date 함수 사용 */&lt;h1&gt; &#123;&#123; Date() &#125;&#125; &lt;/h1&gt; 123456789101112131415161718/* 자바스크립트 표현식 3항 연산자 사용 */ &lt;div id=\"app\"&gt; &lt;img :src=\"smile ? feelsgood : feelsbad\"/&gt; &lt;img v-bind:src=\"smile ? feelsgood : feelsbad\"&gt;&lt;/img&gt; &lt;/div&gt;var app = new Vue(&#123; data: &#123; smile: true, feelsgood: 'https://imgh.us/feelsgood_1.jpg', feelsbad: 'http://imgh.us/feelsbad.jpg' &#125; &#125;); vue.js123456789101112131415161718192021 /* 함수 사용 */ &lt;div id=\"app\"&gt; &lt;h1&gt; &#123;&#123; myfunction() &#125;&#125; &lt;/h1&gt; &lt;/div&gt; var app = new Vue(&#123; el: '#app', data : &#123; funvalue : '함수 값' &#125;, methods: &#123; myfunction: function() &#123; // 인스턴스 내부의 데이터모델에 접근 할 땐, // this 를 사용한다. return this.funvalue &#125; &#125;&#125;); ​ ​ 1. v-text 디렉티브(결과 머스태쉬 태그 와 같다) v-text 라는 디렉티브를 사용 vue.js123&lt;h1&gt; &#123;&#123;number&#125;&#125;&lt;/h1&gt; ||&lt;h1 v-text=\"number\"&gt; &lt;/h1&gt; vue 엘리먼트의 name 변수로 설정 되게 한다 ​ 2. v-html 디렉티브“여기서 렌더링 할 건 html 형식이야” 라는걸 지정하기 위해서 v-html 이라는 디렉티브를 사용합니다. ​ html/vue.js1234567891011 &lt;div id=\"app\"&gt; &lt;h1 v-html=\"nameItaly\"&gt;&lt;/h1&gt; &lt;/div&gt; var app = new Vue(&#123; el: '#app', data: &#123; nameItaly:'&lt;i&gt;기울어짐&lt;/i&gt;' &#125;&#125;); ​ 3. v-show 디렉티브해당 엘리먼트가 보여질지, 보여지지 않을지 true / false 값으로 지정 할 수 있습니다. html/vue.js12345678910 &lt;h1 v-show=\"show\" v-html=\"nameItaly\"&gt;&lt;/h1&gt; var app = new Vue(&#123; el: '#app', data: &#123; nameItaly:'&lt;i&gt;기울어짐&lt;/i&gt;', show:false &#125;&#125;); ​ 4. v-if 디렉티브 변수명 대신에 조건문을 씁니다 (변수명을 입력해도 작동하긴 합니다) 5. v-else 디렉티브v-if 디렉티브를 사용 했을때 그 아래에 v-else 디렉티브를 사용하는 엘리먼트를 넣어주면, 윗부분의 조건문이 만족하지 않을때 보여진답니다. v-if 바로 아래에 v-else 디렉티브를 사용했죠? 이 디렉티브의 값은 따로 설정해주지 않아도 됩니다. 6. v-else-if 디렉티브v-else-if 는 첫번째 조건문의 값이 참이 아닐 때, 다른 조건문을 체크하여 다른 결과물을 보여줄 수 있게 해줍니다. v-else-if 는, 언제나 v-if 디렉티브를 사용하는 엘리먼트의 다음위치에 있어야 합니다. 만약에 v-else 디렉티브가 사용되는 경우엔 그 사이에 위치해있어야 하구요, 이 디렉티브를 여러번 사용해도 됩니다. html12345&lt;div id=\"app\"&gt; &lt;h1 v-if=\"value &gt; 5\"&gt;value 가 5보다 크군요&lt;/h1&gt; &lt;h1 v-else-if=\"value === 5\"&gt;값이 5네요&lt;/h1&gt; &lt;h1 v-else&gt;value 가 5보다 작아요&lt;/h1&gt; &lt;/div&gt; ​ 7. v-pre 디렉티브특정 엘리먼트를 무시하는데에 사용 됩니다. 이걸 사용하므로서, Vue 시스템에서 해당 엘리먼트는 지시문이 없다는걸 인식하게 되어 그 엘리먼트 내부의 자식엘리먼트들을 신경쓰지 않고 그냥 건너뜁니다. html1&lt;h1 v-pre&gt; &#123;&#123; 이건 그대로 렌더링해줘요 &#125;&#125; &lt;/h1&gt; ​ 9. v-once 디렉티브컴포넌트를 초기에 딱 한번만 렌더링합니다. 초기 값은 그대로 고정이 되어있고 현재 값은 그때 그떄 업데이트 되죠? ​ html123&lt;h2 v-once&gt; value초기 값 보여준다 : &#123;&#123; value &#125;&#125;&lt;/h2&gt;&lt;h2&gt;value 현재 값 보여준다: &#123;&#123; value &#125;&#125;&lt;/h2&gt; ​ v-for 디렉티브 HTML 에서 for-loop 을 구현하기 위하여 사용됩니다. 즉, 비슷한 내용을 반복적으로 보여줄 때 사용 html1v-for \"(arr , index ) in arrs\" &#123;&#123; arr.value&#125;&#125; item in items 의 형식으로 작성합니다. items 는 Vue 엘리먼트의 데이터 안에 들어있는 배열 이름 ​ item 은 렌더링 하게 될 때, 각 원소를 가르키는 별침(alias) ​ 123456789101112131415161718 &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in todos &quot;&gt; &#123;&#123; item .text &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; todos: [ &#123; text: &apos;Vue.js 튜토리얼 작성하기&apos; &#125;, &#123; text: &apos;Webpack2 알아보기&apos; &#125;, &#123; text: &apos;사이드 프로젝트 진행하기&apos; &#125; ] &#125; &#125;); index 값 받아오기렌더링을 할 때, 각 원소들을 순서번호(index) 를 가져오려면, 디렉티브 값에 (todo, index) in todos 형식으로 작성을 하면 됩니다. 1234567&lt;div class=\"product\" v-for=\"(item, index) in items\"&gt; &lt;img v-bind:src=\"item.productImage\"&gt; &lt;span v-on:click=\"onDetail(index)\"&gt; &#123;&#123; item.productName &#125;&#125; &lt;/span&gt; &lt;/div&gt; html/vue.js1234567891011121314151617181920 &lt;div id='test'&gt; &lt;div v-for=\"(item,index) in arr\"&gt; index :&#123;&#123;index&#125;&#125;/ value : &lt;button @click=\"fncClick1(index)\"&gt;&#123;&#123;item&#125;&#125;&lt;/button&gt; &lt;/div&gt; new Vue(&#123; el : '#test', data :&#123; arr:['a','b'] &#125;, methods:&#123; fncClick1 : function(index)&#123; return alert (this.arr[index]) &#125; &#125;&#125;) ​ ​ v-bind 디렉티브 , : HTML 태그의 속성 값을 데이터값을 사용해야 한다면 어떻게 해야할까요? ​ HTML 엘리먼트에서 src 값을 Vue 엘리먼트의 데이터 중 image 로 설정하고 싶다 &lt;img v-bind:src=&quot;image&quot;/&gt; 와 같은 형식으로 하면 됩니다. v-bind: 뒤에 속성의 이름 / 편의를 위해서, v-bind 를 생략 할 수 있습니다. 그냥 콜론 뒤에 속성의 이름만 넣어주면 돼요. ​ html/vue.js1234567891011121314&lt;div id=\"app\"&gt; &lt;img v-bind:src=\"addr\"/&gt; &lt;img :src=\"addr\"/&gt; &lt;/div&gt; var app = new Vue(&#123; el: '#app', data: &#123; addr: 'https://imgh.us/feelsgood_1.jpg' &#125; &#125;); ​ v-model , 양 방향 데이터 바인딩(폼 관련 태크만 사용가능 ) 뷰 ⇄ 데이터 형태로 바인딩하여 데이터가 양 방향 으로 흐르게 해주는 것 입니다. 데이터에 있는 값이 뷰에 나타나고, 이 뷰의 값이 바뀌면 데이터의 값도 바뀌는것이죠. v-model 을 설정 함으로서 , 이 input 엘리먼트의 값이 업데이트 되면 자동으로 바뀐다 이렇게 폼에 관련된 태그에만 사용 될 수 있습니다: &lt;input&gt; &lt;select&gt; &lt;textarea&gt; ​ html/vue.js123456789101112131415161718 &lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123; feels &#125;&#125;&lt;/h1&gt; &lt;h3&gt;&lt;input type=\"text\" v-model=\"feels\"/&gt;개구리&lt;/h3&gt; &lt;img v-bind:src=\"feels=='웃어요' ? feelsgood : feelsbad\"/&gt; &lt;/div&gt; // 새로운 뷰를 정의합니다var app = new Vue(&#123; el: '#app', // 어떤 엘리먼트에 적용을 할 지 정합니다 // data 는 해당 뷰에서 사용할 정보를 지닙니다 data: &#123; feels:'울어요', feelsgood: 'https://imgh.us/feelsgood_1.jpg', feelsbad: 'http://imgh.us/feelsbad.jpg' &#125; &#125;); https://kr.vuejs.org/v2/guide/forms.html v- on 디렉티브 ,이벤트 핸들링 @ v-on 디렉티브를 사용하여 DOM 이벤트를 듣고 트리거 될 때 JavaScript를 실행할 수 있습니다. 메소드(함수) 자바스트립트 표현식 … ​ 많은 이벤트 핸들러의 로직은 더 복잡할 것이므로, JavaScript를 v-on 속성 값으로 보관하는 것은 간단하지 않습니다. 이 때문에 v-on이 호출하고자 하는 메소드의 이름을 받는 이유입니다. ​ 메소드를 준비할때는, 우리가 뷰 인스턴스에서 사용 할 데이터들을 data 안에 넣은 것 처럼, 함수들을 만들어서 뷰 인스턴스의 methods 안에 넣으면 됩니다. ​ v-on: 이벤트이름 = “메소드이름” v-on: 을 @ 로 대체 가능 ​ html/vue.js1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;h1&gt;카운터: &#123;&#123; number &#125;&#125;&lt;/h1&gt; &lt;button v-on:click=\"increment\"&gt;증가&lt;/button&gt; &lt;button @click=\"decrement\"&gt;감소&lt;/button&gt;&lt;/div&gt;var app = new Vue(&#123; el: '#app', data: &#123; number: 0 &#125;, // app 뷰 인스턴스를 위한 메소드들 methods: &#123; increment: function() &#123; // 인스턴스 내부의 데이터모델에 접근 할 땐, // this 를 사용한다 this.number++; &#125;, decrement: function() &#123; this.number--; &#125; &#125;&#125;); html/vue.js1234567891011&lt;div id=\"example-1\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;Add 1&lt;/button&gt; &lt;p&gt;위 버튼을 클릭한 횟수는 &#123;&#123; counter &#125;&#125; 번 입니다.&lt;/p&gt;&lt;/div&gt;var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0 &#125;&#125;) 메소드 이름을 직접 바인딩 하는 대신 인라인 JavaScript 구문에 메소드를 사용할 수도 있습니다. validation http://fronteer.kr/bbs/view/338 https://m.dotdev.co/form-validation-using-vue-js-2-35abd6b18c5d https://monterail.github.io/vuelidate/#sub-basic-form https://www.npmjs.com/package/vue-form-validator https://blog.midkemia.fr/form-validation-with-vue-js/","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"vee-validate","slug":"vee-validate","date":"2018-07-31T02:12:47.271Z","updated":"2018-12-17T02:32:14.317Z","comments":true,"path":"2018/07/31/vee-validate/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/vee-validate/","excerpt":"","text":"vee-validatevue에서 validation 수행을 도와준다. 공식사이트 사용방법HTML, NPM 방식 두가지 있음 공식사이트 - Get started 기본 validate 설정html123&lt;input v-validate=\"'required|email'\" :class=\"&#123;'input': true, 'is-danger': errors.has('email') &#125;\" name=\"email\" type=\"text\" placeholder=\"Email\"&gt; 에러메세지 출력html12345&lt;div class=\"has-icon has-icon-right\"&gt; &lt;i v-show=\"errors.has('email')\" class=\"fa fa-warning\"&gt;&lt;/i&gt; &lt;span v-show=\"errors.has('email')\" class=\"invalid-feedback\"&gt;&#123;&#123; errors.first('email') &#125;&#125;&lt;/span&gt;&lt;/div&gt; fa, fa-warning으로 아이콘 출력 가능 (icons 참조) 에러메세지 APIhttps://baianat.github.io/vee-validate/api/errorbag.html#api 원하는 에러메세지를 출력할 수 있도록 API 제공됨 속성v-validate v-validate 속성에 rule 을 지정 여러가지 rule 입력 가능 html12&lt;input v-validate=\"'required|min:6|max:16'\"&gt; // 1&lt;input v-validate=\"&#123; rules: &#123; required: true, min:6, max:16&#125;&#125;\"&gt; // 2 1방법에서 rule을 여러개 입력하는 경우, 반드시 큰 따옴표 안에 작은 따옴표로 감싸준다. 주요 v-validate 값 예제 : https://jsbin.com/siqodemose/4/edit?html,js,output ​ (이메일, 비밀번호(대,소문자,특수문자), 전화번호, 웹사이트) name 필수 속성 id 처럼 쓰이는 유니크한 속성 data-vv-as error 메시지 출력할 때 나오는 필드명 (다국어 처리가 필요하면, 다국어 처리된 데이터를 바인딩 해야 함) v-bind:class class를 동적 바인딩 errors.has(&#39;field&#39;)로 해당 필드에 에러가 있는지 판단 html12&lt;input v-validate=\"'required|email'\" :class=\"&#123;'form-control': true, 'is-invalid': errors.has('userId')&#125;\" Rendering Errors : errors를 통해 에러가 있는지, 어떤 에러인지 알아 볼 수 있다. has(&#39;field&#39;): 해당 필드에 에러가 있는지 first(&#39;field&#39;): 해당 필드의 첫번째 에러 메시지 가져오기 all(): 해당 필드의 모든 에러 메시지 가져오기 collect(&#39;field&#39;): any(): 경고 메시지다국어validate/index.js javascript12345678910import Vue from 'vue'import VeeValidate from 'vee-validate'import validationKoMessages from 'vee-validate/dist/locale/ko.js'const validate = &#123; locale: Vue.i18n.locale(), dictionary: &#123; ko: validationKoMessages &#125;&#125; 기본으로 영문 경고메시지를 띄운다. vee-validate에서 제공하는 다른 언어 경고메시지가 있으니, 필요한 것을 import 하여 사용한다. (설치된 패키지에 포함되어 있음) 커스텀Dictionary를 변경 제공되는 다국어 메시지 외에 사용자정의 validate 에 대한 메시지나 다른 문구를 넣고싶은 경우에 사용한다. vue.js12345678910111213141516171819202122created() &#123; let dict = &#123; en: &#123; custom: &#123; userId: &#123; required: () =&gt; 'User ID is empty.', email: () =&gt; 'User ID must be email.' &#125; &#125; &#125;, ko: &#123; custom: &#123; userId: &#123; required: () =&gt; '아이디가 비어 있습니다.', email: () =&gt; '아이디는 email 형태여야 합니다.' &#125; &#125; &#125; &#125; this.$validator.setLocale('ko'); this.$validator.updateDictionary(dict);&#125; 저장버튼에 validatejavascript 1234567this.$validator.validateAll().then((result) =&gt; &#123; if (result) &#123; alert('From Submitted!'); &#125; else &#123; alert('Correct them errors!'); &#125; &#125;);","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"}]},{"title":"vue.js 파일업로드","slug":"v-model file","date":"2018-07-31T02:12:47.269Z","updated":"2018-07-31T02:12:47.270Z","comments":true,"path":"2018/07/31/v-model file/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/v-model file/","excerpt":"","text":"input file v-modelv-model 예상됨: 컴포넌트 폼 인풋 엘리먼트 또는 출력 값에 따라 다릅니다. 제한사항: &lt;input&gt; &lt;select&gt; &lt;textarea&gt; components 수식어: .lazy - input대신 change 이벤트를 듣습니다. .number - 문자열을 숫자로 변경합니다. .trim - 입력에 대한 trim 을 합니다. file 기존 v-model 사용 불가 방법 ftl html123456789101112131415161718&lt;template&gt; &lt;label class=\"file-select\"&gt; &lt;div class=\"select-button\"&gt; &lt;span v-if=\"value\"&gt;Selected File name : &#123;&#123;value.name&#125;&#125; size: &#123;&#123;value.size&#125;&#125; type: &#123;&#123;value.type&#125;&#125; relativePath : &#123;&#123; value.webkitRelativePath &#125;&#125; &lt;/span&gt; &lt;span v-else&gt;Select File&lt;/span&gt; &lt;/div&gt; &lt;input type=\"file\" @change=\"fileUpload($event)\"&gt; &lt;/label&gt;&lt;/template&gt; ​ vue js vue.js123456789101112131415161718192021data: &#123; value: File &#125;, fileUpload(e) &#123; const config = &#123; headers: &#123; 'Content-Type': 'multipart/form-data' &#125; &#125;; this.value=e.target.files[0]; var data = new FormData(); data.append('uploadFile', this.value); data.append('projectCode', projectCode); alert(projectCode); axios.put( '/api/v1/files/' + projectCode,data,config) .then(res =&gt; &#123; /*this.projectResults = res.data;*/ &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); &#125; ​ @Controller 해당 클래스가 Controller임을 나타내기 위한 어노테이션 @RequestMapping 요청에 대해 어떤 Controller, 어떤 메소드가 처리할지를 맵핑하기 위한 어노테이션 @RequestParam Controller 메소드의 파라미터와 웹요청 파라미터와 맵핑하기 위한 어노테이션 @ModelAttribute Controller 메소드의 파라미터나 리턴값을 Model 객체와 바인딩하기 위한 어노테이션 @SessionAttributes Model 객체를 세션에 저장하고 사용하기 위한 어노테이션 @RequestPart Multipart 요청의 경우, 웹요청 파라미터와 맵핑가능한 어노테이션(egov 3.0, Spring 3.1.x부터 추가) @CommandMap Controller메소드의 파라미터를 Map형태로 받을 때 웹요청 파라미터와 맵핑하기 위한 어노테이션(egov 3.0부터 추가) @ControllerAdvice Controller를 보조하는 어노테이션으로 Controller에서 쓰이는 공통기능들을 모듈화하여 전역으로 쓰기 위한 어노테이션(egov 3.0, Spring 3.2.X부터 추가","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"file","slug":"file","permalink":"http://apexsoft.github.io/tags/file/"}]},{"title":"v-cloak","slug":"v-cloak","date":"2018-07-31T02:12:47.268Z","updated":"2018-07-31T02:12:47.269Z","comments":true,"path":"2018/07/31/v-cloak/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/v-cloak/","excerpt":"","text":"v-cloak실행될때, 머스태쉬 태그들이 짧은 순간 동안 깜박거리는 현상이 존재. 자바스크립트 코드가 실행되기 전이기 때문에. v-cloak 을 사용하면 html 코드를 숨길 수 있다. html123&lt;div id=\"app\" v-cloak&gt; ..&lt;/div&gt; css 123[v-cloak] &#123; display: none;&#125;","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"vue slider 컴포넌트","slug":"slider component","date":"2018-07-31T02:12:47.267Z","updated":"2018-07-31T02:12:47.267Z","comments":true,"path":"2018/07/31/slider component/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/slider component/","excerpt":"","text":"slidervue-slider-component https://github.com/NightCatSama/vue-slider-component 직접수행해본 예제 https://jsbin.com/patusomaqi/2/edit?html,js,output","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"query mehtod","slug":"query mehtod만들기","date":"2018-07-31T02:12:47.263Z","updated":"2018-07-31T02:12:47.263Z","comments":true,"path":"2018/07/31/query mehtod만들기/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/query mehtod만들기/","excerpt":"","text":"Repository 제공 기능 method 이름 기능 save() 레코드 저장 (insert, update) findOne() primary key로 레코드 한건 찾기 findAll() 전체 레코드 불러오기. 정렬(sort), 페이징(pageable) 가능 count() 레코드 갯수 delete() 레코드 삭제 query mehtod 이름 생성 전략 아래 이름으로 시작하는 메서드는 query method 임을 스프링에게 알린다. mthod 이름 설명 findBy로 시작 쿼리를 요청하는 메서임을 알림 countBy로 시작 쿼리 결과 레코드 수 요청하는 메서드 임을 알림 필드 쿼리 표현식** 위의 findBy… 에 이어 아래와 같이 해당 repository 도메인의 필드이름을 입력하면 검색 쿼리를 실행한 결과를 전달한다. SQL의 where 절을 메서드이름을 통해서 전달한다고 보면 된다. 메서드의 반환형이 도메인 객체이면 하나의 결과만 전달하고 반환형이 List 이면 쿼리에 해당하는 모든 객체를 전달한다. query method에 포함할 수 있는 키워드 메서드이름 키워드 샘플 설명 And findByEmailAndUserId(String email, String userId) 여러필드를 and 로 검색 Or findByEmailOrUserId(String email, String userId) 여러필드를 or 로 검색 Between findByCreatedAtBetween(Date fromDate, Date toDate) 필드의 두 값 사이에 있는 항목 검색 LessThan findByAgeGraterThanEqual(int age) 작은 항목 검색 GreaterThanEqual findByAgeGraterThanEqual(int age) 크거나 같은 항목 검색 Like findByNameLike(String name) like 검색 IsNull findByJobIsNull() null 인 항목 검색 In findByJob(String … jobs) 여러 값중에 하나인 항목 검색 OrderBy findByEmailOrderByNameAsc(String email) 검색 결과를 정렬하여 전달 생각할 수 있는 거의 모든 연산자가 가능하다. 예를들어 List findFirst10ByNameAndAgeGreaterThanEqualOrderByBirthday(String name, int age); 페이징spring data jpa의 web 프로젝트 지원 query method의 입력 변수로 Pageable을 추가하면 Page 타입을 반환형으로 사용할 수 있다. Pageable 객체를 통해 페이징과 정렬을 위한 파라미터를 전달한다. 아래와 같이 controller에서 부터 Pageable을 전달받는다. query parameter 명 설명 page 몇번째 페이지 인지를 전달 size 한 페이지에 몇개의 항목을 보여줄것인지 전달 sort 정렬정보를 전달. 정렬정보는 필드이름,정렬방향 의 포맷으로 전달한다. 여러 필드로 순차적으로 정렬도 가능하다.예: sort=createdAt,desc&amp;sort=userId,asc 아래는 위 controller를 통해 http 요청으로 페이징과 정렬된 데이터를 전달 받는 URI 샘플 GET /users?page=1&amp;size=10&amp;sort=createdAt,desc&amp;sort=userId,asc 위와 같이 웹 페이지 개발에 필수적인 정렬과 페이징정보를 접속 url에서 부터 Repository 객체가지 바로 전달이 가능하다. 123PageRequest pageRequest = new PageRequest(page, 10); Page&lt;Project&gt; result = projectRepository.findAll(pageRequest);","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"확장","slug":"pug","date":"2018-07-31T02:12:47.261Z","updated":"2018-11-26T02:53:50.504Z","comments":true,"path":"2018/07/31/pug/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/pug/","excerpt":"","text":"pug templete 확장을 가능하게 하는 언어 extend 컴포넌트 확장 예제 기본 구조 SurveyInputBase.pug .pub 파일 html에서 닫는 태그가 없다 들여쓰기한 이후에 공백까지 태그로 된다 태그 속성은 괄호( ) 사용 SurveyInputBase.pug12345form div(class=\"form-group\") label(for=\"title\" class=\"form-label\") Title textarea(v-model.lazy=\"element.title\" class=\"form-control\" name=\"title\") block custom SurveyInputBase.vue (기본)DialogFormBase.vue12345678&lt;template lang=\"pug\"&gt; include SurveyInputBase.pug&lt;/template&gt;&lt;script&gt; export default &#123; props: [ 'question' ] &#125;&lt;/script&gt; SurveyInputText.vue (확장)SurveyInputText.vue123456789101112&lt;template lang=\"pug\"&gt; extends SurveyInputBase.pug block input input(type=\"text\" :placeholder=\"placeholder\")&lt;/template&gt;&lt;script&gt; import SurveyInputBase from './SurveyInputBase.vue'; export default &#123; extends: SurveyInputBase, props: [ 'placeholder' ], &#125;&lt;/script&gt; Mixins vue 구성요소에 재사용 가능한 기능을 넣는 방법 재사용 가능한 기능은 기존 기능과 병합 캡슐화 및 공통된 기능을 분리시켜 코드 재사용성을 높혀준다. 오버라이딩 기능도 사용할 수 있어 커스텀 및 확장에 용이하다. 참고 동영상 공식문서 extends: 유사한 기능의 컴포넌트들을 추상화 하여 상위 컴포넌트를 만들고 차이가 있는 기능들을 하위 컴포넌트에 구현한다. mixins: 서로 다른 기능의 컴포넌트에 동일한 기능을 배포하는 방법으로 예를 들면 로깅 기능을 aspect 단위로 추가하는 것을 들 수 있다. 참고 url https://vuejsdevelopers.com/2017/06/11/vue-js-extending-components/","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"pug","slug":"pug","permalink":"http://apexsoft.github.io/tags/pug/"},{"name":"extends","slug":"extends","permalink":"http://apexsoft.github.io/tags/extends/"}]},{"title":"promise","slug":"promise","date":"2018-07-31T02:12:47.260Z","updated":"2018-07-31T02:12:47.261Z","comments":true,"path":"2018/07/31/promise/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/promise/","excerpt":"","text":"promise 비동기 동작의 흐름을 제어할 때 사용 JavaScript ES6에 추가 아직은 아니지만 나중에 완료될 것으로 기대 되는 연산을 의미 async(비동기)연산에서 사용 Promise object는 new를 통해 initiate될 수 있으며, 함수를 패스받을 수 있다. 이 함수에는 resolve, reject함수가 매개변수로 차례로 들어가있다. javascript1234567891011121314151617function task(resolve, reject) &#123; console.log('task start'); setTimeout(function() &#123; console.log('task end'); resolve('task success'); &#125;, 300);&#125;function resolveed(result) &#123; console.log('resolve : '+result);&#125;function rejected(err) &#123; console.log('rejected : ', err);&#125;new Promise(task).then(resolveed, rejected); promise 이후의 동작 : then 성공과 실패일 때 각각 콜백처리 한다 resolve promise가 성공적으로 종료될 때 promise의 뒤에 따라오는 then의 콜백에 arg로 사용될 value를 넘겨받을 수 있다. reject promise에서 에러가 발견된 경우, 혹은 조건에 맞지 않아 에러를 발생시켜야 하는 경우 호출 promise의 메서드인 catch안에 들어간다. 보통 resolve는 error의 이유가 들어간다 123456789101112let func = function(resolve)&#123; resolve();&#125;;let promise1 =new Promise(func);promise1.then(()=&gt;alert('resolve1'));let promise =new Promise((resolve,reject)=&gt;&#123; reject(); &#125;);promise.then(()=&gt;alert('resolve'));promise.catch(()=&gt;alert('reject')); https://jsbin.com/nusaxemero/2/edit?html,js,console,output","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://apexsoft.github.io/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://apexsoft.github.io/tags/javascript/"}]},{"title":"node.js? npm? cdn? 사용하기","slug":"nodjs","date":"2018-07-31T02:12:47.259Z","updated":"2018-07-31T02:12:47.259Z","comments":true,"path":"2018/07/31/nodjs/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/nodjs/","excerpt":"","text":"javascript 사용1. CDN https://unpkg.com/#/ OR https://www.npmjs.com/ dist 폴더 , 다른이름으로 링크주소 복사 &lt;script &gt; 주소 &lt;/script&gt; 2.npm git 다운 npm run bundle or yarn bundle dist 폴더 , 생성된 물리적 파일 원하는 프로젝트에 옮기기 webpack ? 모듈 번들러 의존성을 가진 모듈들을 다루고 , 그 모듈로부터 정적인 asset을 생성 작동 방법 하나의 파일을 진입점으로 지정 진입점 파일은 트리의 루트가 된다 require에 의해 다른 파일이 트리에 추가 된다 = require으로 명시된 의존성들을 해석하며 의존성 트리를 그린다 webpack명령을 실행하면 , 모든 파일과 모듈은 하나의 파일에 번들로 제공된다 모듈 번들링 모듈간의 의존성을 해석하고 , 그걸 바탕으로 정적 에셋을 만드는 과정 모듈 번들러 모듈 번들링을 하는 친구 ex ) webpack 거대한 파일들을 여러 파일로 나눠 쓸수있게 해준다. ​ webpack-dev-server 메모리에 bundle 파일을 올려 놓고 변경이 있을때 마다 , live reload를 시킨다 webPack.dev.config.js webpack-dev-server가 사용할 환경설정에 대해 정의 devServer host : localhost 모든 ip를 사용하는 경우 0.0.0.0사용 port : 8080 접속 포트 설정 proxy : {‘**’ :”http://localhost:8001&quot;} 프록시 설정 , Springboot 실행되는 url 12345axios .get(`http://localhost:8001/tester/api/proto/ans/ask/$&#123;this.askNo&#125;`) .then((res) =&gt; &#123; &#125; &#125;); ​ 12345axios.get(`/tester/api/proto/ans/ask/$&#123;this.askNo&#125;`).then((res) =&gt; &#123; &#125;&#125;); 실행 bash123456#package.json에 정의된 모듈 설치(node_modules에 다운로드)npm install#webpack -dev-server 구동npm run dev npm run명령 뒤의 스크립트 명(dev)는 pakage.json에 정의 되어있다 package.json npm 설정을 관리 이를 통해 모든 부품이 설치되어 돌아갈 수 있습니다. devDependencies lint 코딩 룰에 위배되는거 체크 해준다 pug babel Babel은 Transform Compiler이다. 보통 TypeScript, CoffeeScript 같은 Javascript 문법이 아닌 각각의 문법으로 작성된 코드를 Javascript 엔진에서 동작 가능한 코드로 변환하는 역할 ES6 -&gt; ES5 transpiler loader 일종의 함수 마지막 로더는 최종적으로 적절하게 변형된 모듈을 번들 자바스크립트 파일에 넣어주게 된다 ex) css 파일 require 하는 경우 css 파일을 그대로 자바스크립트에 넣을수 없으니 , 원래의 css파일과 같은 역활을 할 수 있는 자바스크립트 형태의 무언가를 만들어야 최종 번들에 해당 내용을 포함시킬수 있다. 이 과정을 일련의 로더 파이프라인이 수행 webpack.config.js webpack을 설정한다 12345678910111213var path = require('path')module.exports = &#123; entry: &#123; 'vuejs-test2': path.join(__dirname, '/src/vuejs-test2.js'), 'draggabletest': path.join(__dirname, '/src/draggabletest.js') &#125;, output: &#123; path: path.join(__dirname, '../src/main/resources/static/js/bundles'), publicPath: '/js/bundles', filename: '[name].js' &#125;&#125; enty - 번들의 엔트리 포인트 . webpack은 여러 번들을 생성하는 진입점을 허용하기 때문에 배열이다 output - webpack의 최종 결과물이 되는 형태를 명시 path - 어디에 번들 파일을 위치 시킬 것인지를 지정 ( 빌드 결과물 들어갈 webpack.config.js로 부터의 상태 경로 ) publicPath - 웹사이트에서 해당 에셋에 접근하기 위해 필요한 경로 filename 각 번들 파일의 이름을 지정 [name] : entry에서의 key 값 Loader - Loader는 사전에 처리할 작업을 나타내며 css, html, jpg, scss 등의 자산을 하나의 모듈로 취급하며 이러한 파일들을 종속성 그래프에 추가할 때 모듈로 변환한다. Plug-In - Plug-In은 일반적인 Compile 또는 모듈 처리에 필요한 작업 및 사용자 정의 기능을 수행하는데 사용한다. webpack 명령을 실행하면 , bundles라는 폴더에 draggabletest.js vuejs-test2파일을 생성한다 webpack은 require 하고있는 파일들 모두 묶어 하나의 번들을 내놓게 된다 node-moules npm이 pakage들을 설치하는 디렉토리 폴더 사용설치 node.js 설치 https://nodejs.org/en/download/current/ yarn 설치 npm install -g yarn -g는 글로벌 옵션 Plugins 설치 (선택) vue.js pug 실행 package.json에 정의된 모듈 설치 npm install 주입 후 빌드 refresh webpack -dev-server 구동 npm run dev springboot 서버 실행 시큐리티 설정에 걸리는 경우 , 해당 url .permitAll() 하기 ​ 옮기기 npm run bundle dist 밑에 생기는 파일 복사해서 붙여 넣는다 기타lint 코딩룰 체크 설치 yarn 설치 npm install -g yarn lint 설치 npm install -g eslint pakage.json &gt;&gt; devDependencies &gt;&gt; 추가 사용 rule 확인 + fix yarn lint --fix .eslintrc.js rule 정의","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://apexsoft.github.io/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://apexsoft.github.io/tags/npm/"}]},{"title":"mixin","slug":"mixin","date":"2018-07-31T02:12:47.257Z","updated":"2018-07-31T02:12:47.258Z","comments":true,"path":"2018/07/31/mixin/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/mixin/","excerpt":"","text":"MixIn vue 구성요소에 재사용 가능한 기능을 넣는 방법 재사용 가능한 기능은 기존 기능과 병합 캡슐화 및 공통된 기능을 분리시켜 코드 재사용성을 높혀준다. 오버라이딩 기능도 사용할 수 있어 커스텀 및 확장에 용이하다. ​ 얼핏 보면 extends와 유사하게 보일 수가 있다. extends: 유사한 기능의 컴포넌트들을 추상화 하여 상위 컴포넌트를 만들고 차이가 있는 기능들을 하위 컴포넌트에 구현한다. mixins: 서로 다른 기능의 컴포넌트에 동일한 기능을 배포하는 방법으로 예를 들면 로깅 기능을 aspect 단위로 추가하는 것을 들 수 있다. 선언 및 사용1.vue.js123456789101112var mixin1 = &#123;...&#125;var mixin2 =&#123; ...&#125;new Vue(&#123; el: '#app', mixins: [mixin1,mixin2]&#125;) 2. 전역 MixIn 생성되는 모든 vue 에 영향을 주기때문에 사용자 지정 옵션을 줘서 사용한다 사용자 지정 옵션 vue.js123456789101112131415Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.mixInOption1 if (myOption) &#123; console.log(\"전역mixIn실행:\"+myOption) &#125; &#125;&#125;)new Vue(&#123; el: '#app', mixInOption1: 'hello!'&#125;)//Console Logs&gt; 전역mixIn실행 hello! vue 인스턴스 , key :mixInOption1 value: &#39;hello!&#39; Global mixin , this.$options. key 조건 으로 특징 mixin객체 안에 created(), methods, data,mounted… 구성 옵션 포함 가능 vue.js12345678910111213var mixin = &#123; data: &#123; name: '이름' &#125;, created: function () &#123; console.log('mixin hook called') &#125;, methods: &#123; mixinFnc() &#123; console.log('html 직접접근 '+this.name); &#125; &#125;&#125; html에서 직접 접근 가능 vue.js1234567891011&lt;div id=\"app\"&gt; &lt;button @click.prevent=\"mixinFnc\"&gt;click&lt;/button&gt;&lt;/div&gt;var mixin = &#123; methods: &#123; mixinFnc() &#123; console.log('mixinFnc 함수'); &#125; &#125;&#125; vue 컴포넌트 안에서 mixin안 data 도 접근 가능 ex) this.name veu.js123456789101112131415var mixin = &#123; data: &#123; name: '이름' &#125;&#125;new Vue(&#123; el: '#app', mixins: [mixin,mixin2], created: function () &#123; console.log('component hook called:' +this.name) &#125;&#125;)//Console Logs&gt; component hook called: 이름 중첩 옵션이 포함되어 있으면 mixin 먼저 호출된 이후, vue 컴포넌트 호출 vue.js1234567891011121314151617const myMixin = &#123; created()&#123; console.log(\"mixin hook called) &#125;&#125;new Vue(&#123; el: '#root', mixins:[myMixin], created()&#123; console.log(\"component hook called\") &#125;&#125;)//Console Logs&gt; mixin hook called&gt; component hook called 하지만, methods, components, directives와 같은 객체값 요구하는 옵션에 충돌하는 키가 있을 경우 (같은 메소드명) 컴포넌트 옵션만 호출됨. vue.js1234567891011121314151617181920const myMixin = &#123;methods:&#123; name()&#123; console.log(\"myMixin\") &#125; &#125;&#125;new Vue(&#123; el:\"#root\", mixins:[myMixin], methods:&#123; name()&#123; console.log(\"Christian John\") &#125; &#125;&#125;)//Console Logs&gt; Christian John Global function 사용하고 싶은경우1. .js파일을 만든다 mixin12345678910111213var mixin = &#123; data: &#123; name: '이름' &#125;, created: function () &#123; console.log('mixin hook called') &#125;, methods: &#123; mixinFnc() &#123; console.log('html 직접접근 '+this.name); &#125; &#125;&#125; 사용을 원하는 곳에서 .js파일을 넣고 , mixIn 선언 한다 vue.js1234new Vue(&#123; el:\"#root\", mixins:[myMixin]&#125;) 2. 전역 MixIn","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"}]},{"title":"lombok","slug":"lombok","date":"2018-07-31T02:12:47.256Z","updated":"2018-07-31T02:12:47.257Z","comments":true,"path":"2018/07/31/lombok/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/lombok/","excerpt":"","text":"@Builder 필수 인자들을 생성자(또는 정적 팩터리 메서드)에 전달하여 빌더 객체를 만들고, 선택적 인자들을 추가한 뒤, 마지막에 build()를 호출하여 Immutable 객체를 만드는 방법. Class에 대한 복잡한 Builder API들을 자동으로 생성해 준다. Class 뿐만 아니라, 생성자, 메서드에도 사용할 수 있다. 추가적으로 @Singular Annotation도 제공한다. @Singular는 @ Builder Annotation을 사용한 Class/Method/Constructor에서 Collection 객체에만 사용할 수 있다. Collection 변수에 @Singular을 설정하면 setter 함수 대신 두 종류의 Adder 함수와 Clear함수를 생성해 준다. 빌더 패턴을 적용한 객체 생성 메소드/클래스를 만들어준다. builderClassName 파라미터로 nested 빌더 클래스의 이름을 (클래스명Builder가 기본), builderMethodName으로 빌더 클래스를 반환하는 static 메소드의 이름을 (builder()가 기본), buildMethodName으로 객체를 반환하는 빌드 메소드의 이름 (build()가 기본)을 설정할 수 있다. 필드에 **@Builder.Default** 어노테이션을 붙여 기본 값을 설정할 수 있고, @Singular 어노테이션을 붙여 빈 collection을 자동으로 만들 수 있다. @Singluar 어노테이션은 파라미터로 builder에서 값을 추가할 때 사용되는 메소드의 이름을 입력받는다. 또, @Singular 어노테이션으로 만들어진 collection은 수정할 수 없다. 데이터 일관성, 객체불변성 등을 만족시킨다. 또한 코드 가독성 역시 올라간다. ​ java12345678@Builder@ToStringpublic static class LombokClass &#123; private String name; private int value; @Builder.Default private int value2 = 999; // 기본 값 설정 @Singular(\"addVal\") private List&lt;Integer&gt; values;&#125; java12345678910111213val lombokClass = LombokClass.builder() .name(\"Hello\") .value(500) .addVal(100) .addVal(200) .addVal(300) .build();System.out.println(lombokClass); // LombokClass(name=Hello, value=500, value2=999, values=[100, 200, 300])val val0 = lombokClass.values.get(0);System.out.println(val0); // 100 자바 빈즈 패턴자바빈즈 패턴은 코드량이 늘어나는 단점이 존재한다. 하지만 그것보다 더욱 문제가 되는 것은 객체 일관성이 깨진다. 객체 일관성이 깨진다는 것이란, 한번 객체를 생성할때, 그 객체가 변할 여지가 존재한다는 뜻이다. 즉, set메서드는 언제 어디서든 사용 할 수 있다는 장점이 있지만, 객체의 불변성이 깨진다. 스레드 작업에 큰 단점이 될 수 있을 뿐더러, 컴파일러 오류는 아니지만, 우리가 원하지 않는 결과물이 만들어 질 수 있는것이다. 점층적 생성자패턴과 자바빈즈 패턴의 장점을 섞은것이 빌더패턴이다. 정보들은 자바 빈즈 패턴처럼 받되, 데이터 일관성을 위해 정보들을 다 받은후에 객체생성을 해준다. java1234PersonInfo personInfo = new PersonInfo( );personInfo.setName(\"Mommoo\"); // 이름을 넣는 메서드personInfo.setAge(12); // 나이를 넣는 메서드personInfo.setPhonNumber(119); // 전화번호를 넣는 메서드 사용 에러console12345678org.springframework.web.util.NestedServletException:Request processing failed; nested exception is org.springframework.orm.jpa.JpaSystemException:No default constructor for entity: : kr.co.apexsoft.GCSVC.domain.FileUpLoad;nested exception is org.hibernate.InstantiationException:No default constructor for entity: :kr.co.apexsoft.GCSVC.domain.FileUpLoad 해결java12@AllArgsConstructor@RequiredArgsConstructor XXXXArgsConstructor위의 어노테이션은 생성자를 생성해주는 어노테이션이다. 첫 번째는 디폴트 생성자를 생성해주는 @NoArgsConstructor 두 번째는 모든 필드의 생성자를 생성해주는 @AllArgsConstructor 마지막으로 필수 생성자를 생성해주는 @RequiredArgsConstructor 가 있다. 속성 staticName : 위에서 @Data 어노테이션의 staticConstructor 와 동일하다. static한 생성자를 만들어 준다. access : 접근제한을 할 수 있다. PUBLIC, MODULE, PROTECTED, PACKAGE, PRIVATE 등으로 설정가능 하다. onConstructor : 생성자에 어노테이션을 작성할 수 있다.공통적인 속성으로는 위와 같이 3가지가 존재한다. java12345@RequiredArgsConstructor(staticName = \"of\", onConstructor = @__(@Inject))public class ConstructorObject &#123; private final Long id; private final String name;&#125; 만약 위와 같은 어노테이션을 작성할 경우에는 다음과 같은 코드가 나올 것이라고 예상해본다. java12345678910111213class ConstructorObjectNot &#123; private final Long id; private final String name; @Inject private ConstructorObjectNot(Long id, String name) &#123; this.id = id; this.name = name; &#125; public static ConstructorObjectNot of(Long id, String name) &#123; return new ConstructorObjectNot(id, name); &#125;&#125; staticName가 존재해 access는 별루 의미가 없어 사용하지 않았다. @Datalombok을 사용한다면 제일 많이 사용하는 어노테이션이다. 이 어노테이션은 다재다능한 기능이다. 사용하는 사람은 알겠지만 getter, setter, toString, hasCode, equals, constructor 등 많은 부분을 자동으로 생성해준다.각각 부분적으로는 밑에서 설명하도록 하겠다.@Data 어노테이션에는 속성이 한개 있는데 staticConstructor 라는 속성이다. 말그대로 static한 생성자? 를 만들어 주는 것이다. java12345@Data(staticConstructor = \"of\")public class DataObject &#123; private final Long id; private String name;&#125; 위와 같이 선언한다면 다음과 같이 사용가능하다. 1DataObject dataObject = DataObject.of(1L); id 경우에는 final이라 필수 생성자에 포함되어 있다. 만일 위와 같이 사용한다면 new로 생성할 수 없다. 1DataObject dataObject2 = new DataObject(); // compile error 위와 같이 new 를 이용해 생성할 시에는 컴파일 에러가 발생한다. 위의 여러 메서드를 제외하고 한개의 메서드가 더 생성이 되는데 그 메서드는 canEqual이라는 메서드이다. 해당 메서드의 역할은 instanceof로 타입정도만 체크 한다. 하지만 메서드의 접근제한자는 protected 이다. 필자도 사용할 일이 없었다. @Getter와 @Setter어노테이션 이름 그대로 getter와 setter를 생성해준다. 클래스 레벨에도 사용가능하며 필드 레벨에도 사용가능하다.공통 속성으로는 value, onMethod 속성이 존재한다. value의 경우에는 접근 제한을 할 수 있으며 onMethod 메서드의 어노테이션을 작성할 수 있다. java12345public class GetSetObject &#123; @Getter(value = AccessLevel.PACKAGE, onMethod = @__(&#123;@NonNull, @Id&#125;)) private Long id;&#125; 만약 위와 같은 코드를 작성하였을 경우에는 다음과 같은 코드가 작성 될 것이다. java123456789class GetSetObjectOnMethod &#123; private Long id; @Id @NonNull Long getId() &#123; return id; &#125;&#125; 물론 @Setter 어노테이션에도 onMethod를 사용할 수 있다. java1@Setter(onMethod = @__(&#123;@NotNull&#125;)) 그리고 @Getter, @Setter 각각이 다른 속성들을 한개씩 가지고 있는데. @Getter인 경우에는 lazy 속성이고 @Setter의 경우에는 onParam 이라는 속성이다.@Getter 의 lazy 속성은 속성명 그대로 필드의 값은 지연시킨다는 것이다. java123456@Getter(value = AccessLevel.PUBLIC, lazy = true)private final String name = expensive();private String expensive() &#123; return \"wonwoo\";&#125; lazy가 true일때는 무조건 final 필드어야만 한다. lazy 속성이 false 일 경우에는 객체를 생성할 때 expensive() 메서드를 호출하지만 속성이 true일 경우에는 getName() 메서드를 호출할 때 expensive() 메서드를 호출 한다. 다음은 @Setter의 onParam 속성이다. 이 속성은 파라미터의 어노테이션을 작성할 수 있는 속성이다. java12@Setter(onParam = @__(@NotNull))private Long id; 만약 다음과 같은 코드가 있을 경우에는 아래와 같은 코드가 작성될 것이라고 판단된다. java1234567class GetSetObjectOnParam &#123; private Long id; public void setId(@NotNull Long id) &#123; this.id = id; &#125;&#125; 아주 간단한 코드이다. (물론 만든 사람은 아니겠지만..) IDEA에서는 onParam과 onMethod에 @Column 어노테이션의 속성을 넣으면 잘 동작하지 않는다. onParam 은 파라미터에 적용되니 @Column 자체가 들어 갈 수 없으니 그렇다 쳐도 onMethod는 왜안되는지.. 플러그인 문제인듯 싶다. @EqualsAndHashCode 와 @ToString@EqualsAndHashCode 어노테이션은 이름 그대로 hashcode와 equals를 생성해주는 어노테이션이고, @ToString도 마찬가지로 toString() 메서드를 생성해주는 어노테이션이다.공통 속성으로는 4가지 있는데 exclude, of, callSuper, doNotUseGetters가 존재 한다. exclude는 제외시킬 변수명을 작성하면 되고 of는 포함시킬 변수명을 작성하면 된다. callSuper 속성은 상위 클래스의 호출 여부를 묻는 속성이다. 마지막으로 doNotUseGetters의 속성은 getter 사용여부 인듯 하나 제대로 동작하지는 모르겠다. java123456@EqualsAndHashCode(of = \"id\")@ToString(exclude = \"name\")public class HashCodeAndEqualsObject &#123; private Long id; private String name;&#125; 만일 위와 같이 작성하였다면 hasCode, equals, toString 모두 id만 존재하게 된다.각각의 속성으로는 @EqualsAndHashCode 는 onParam, @ToString 는 includeFieldNames 속성이 존재한다. onParam 은 equals에 작성되며 위의 onParam 속성과 동일하므로 생략한다. includeFieldNames는 toString의 필드 명을 출력할지 하지 않을지의 여부이다. 만일 위의 코드로 includeFieldNames을 false로 한다면 다음과 같이 출력 된다. 1HashCodeAndEqualsObject(null) 참고로 canEqual 메서드도 @EqualsAndHashCode 메서드에 포함되어 있다. @val 와 @var스칼라, 코틀린 이외에 다른 언어들의 키워드와 동일하게 타입추론을 한다. java12345678910public class ValAndVarTests &#123; @Test public void valVarTest() &#123; val arrVal = Arrays.asList(1, 2, 3, 4, 5); arrVal = new ArrayList&lt;&gt;(); // compile error var arrVar = Arrays.asList(1, 2, 3, 4, 5); arrVar = new ArrayList&lt;&gt;(); &#125;&#125; val 경우에는 final 키워드가 생성된다. 그래서 다시 어사인을 할 경우에 컴파일 에러가 발생한다. 마찬가지로 var는 final이 존재 하지 않으므로 다시 어사인이 가능하다. 위의 코드를 다시 만들어 보면 다음과 같을 것으로 예상된다. java12345final List&lt;Integer&gt; arrVal1 = Arrays.asList(1, 2, 3, 4, 5);arrVal1 = new ArrayList&lt;&gt;();List&lt;Integer&gt; arrVar1 = Arrays.asList(1, 2, 3, 4, 5);arrVar1 = new ArrayList&lt;&gt;(); 위와 동일한 바이트코드가 나올 것으로 예상해본다. @UtilityClass유틸리티 클래스에 적용하면 되는 어노테이션이다. 만약 이 어노테이션을 작성하면 기본생성자가 private 생성되며 만약 리플렉션 혹은 내부에서 생성자를 호출할 경우에는 UnsupportedOperationException이 발생한다. java123456@UtilityClasspublic class UtilityClassObject &#123; public static String name() &#123; return \"wonwoo;\"; &#125;&#125; 만약 위의 코드를 다시 작성해보면 다음과 같다. 12345678class UtilityClassObjectNot &#123; private UtilityClassObjectNot() &#123; throw new UnsupportedOperationException(\"This is a utility class and cannot be instantiated\"); &#125; public static String name() &#123; return \"wonwoo;\"; &#125;&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"}]},{"title":"Unreal.js","slug":"Unreal.js로 위젯 그리기","date":"2018-07-31T02:12:47.251Z","updated":"2018-11-26T02:53:50.498Z","comments":true,"path":"2018/07/31/Unreal.js로 위젯 그리기/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/Unreal.js로 위젯 그리기/","excerpt":"","text":"Unreal.js로 위젯 그리기위젯을 그려보자. 그 전에 기본적인 파일을 먼저 셋팅해야한다. visual studio code에서 typings 폴더의 파일들을 전부 연다.(에러 해결 후에도 열어두자.) 아마 에러가 몇개 있다고 할 것이다. 컨텍스트에러이므로 Ctrl+j로 에러로그를 열어 하나씩 눌러서 처리하도록 한다. [ ,:’’, ] 부분을 지우면 될 것이다. ####준비 React.js를 사용해보았다면 알겠지만, 필자는 사용해본 적이 없었다. 그래서 내가 이해한 기준으로 작성하겠다. React.js 모든 파일들은 사슬처럼 연결되어 돌아간다. Actor에서 호출할 기본이 되는 파일을 app.js라고 하면 app.js에서는 트리거 역할만 해주며 익셉션처리 또한 이 곳에서 일어난다. web프로젝트로 치면 컨트롤러라고 생각하면 된다. app.js에서 정상상태에서 실행할 파일과 익셉션이 발생했을 때 실행할 파일을 정의해둔다. 12345678910111213141516171819// app.js(function (global) &#123; &quot;use strict&quot; try &#123; let main = require(&apos;start&apos;) module.exports = () =&gt; &#123; let cleanup = null process.nextTick(() =&gt; &#123; cleanup = main() &#125;); return () =&gt; cleanup() &#125; &#125; catch (e) &#123; require(&apos;bootstrap&apos;)(&apos;app&apos;) &#125;&#125;)(this) 위에서 ‘start’는 app.js가 아닌 다른 파일이다. 캐치절에 들어있는 ‘app’은 app.js 본인을 지칭하는 것이 맞다. 익셉션이 발생할 경우 ‘bootstrap’과 본인 자신을 다시 실행하겠다는 것이다. 그러면 ‘start’와 ‘bootstrap’에는 무엇이 들어있는지 살펴볼 필요가 있다. 123456789101112131415// bootstrap.js(function (global) &#123; &quot;use strict&quot; module.exports = function (filename) &#123; // Context.WriteDTS(Context.Paths[0] + &apos;typings/ue.d.ts&apos;) // Context.WriteAliases(Context.Paths[0] + &apos;aliases.js&apos;) Context.RunFile(&apos;aliases.js&apos;) Context.RunFile(&apos;polyfill/unrealengine.js&apos;) Context.RunFile(&apos;polyfill/timers.js&apos;) require(&apos;devrequire&apos;)(filename) &#125;&#125;)(this) 이것은 unreal.js의 공식 git페이지에서 찾을 수 있는데 설정파일이라고 여기자. 없으면 만들어야 한다. 호출구조를 유지하면 파일명은 바꾸어도 상관없다. 컨트롤러(app.js)에서 익셉션이 발생하면 설정파일을 다시 실행하고 본인 자신을 실행하는 것이다. 익셉션이 발생하지 않았다면 ‘start’파일이 실행될 것이다. start파일을 열어보자. 12345678910111213141516171819202122232425262728293031323334353637// start.js(function () &#123; &quot;use strict&quot;; module.exports = function () &#123; let PC = GWorld.GetPlayerController(0) PC.bShowMouseCursor = true var mainWidget = GWorld.Create(JavascriptWidget, PC) var page = new VerticalBox page.Visibility = &apos;Visible&apos; mainWidget.SetRootWidget(page) mainWidget.AddToViewport() var game = null function start_Game() &#123; if (game != null) &#123; game() &#125; try &#123; game = require(&apos;./application&apos;)(mainWidget, page) &#125; catch (e) &#123; console.log(&apos;Exception&apos;, String(e)) &#125; &#125; start_Game() return function () &#123; game() mainWidget.RemoveFromViewport() &#125; &#125;&#125;)() 블루프린트 혹은 C++로 작업을 해왔다면 Widget을 만드는 방법은 익히 알고 있을 것이다. CreateWidget이 Create가 된것 말고는 다른게 없다. 여기서 중요한 것은 SetRootWidget을 꼭 해줘야 한다. 게임을 만들기 위해서 application.js가 필요하다. 해보면서 느낀 점은 module.exports와 require만 유심히 보면 된다는 것이다. 123456789101112131415161718// application.js(function () &#123; &quot;use strict&quot; module.exports = function (container) &#123; run(container) return function () &#123; game.destroy() &#125; &#125; function run(vbox) &#123; var design = require(&apos;./design&apos;) var instantiate = require(&apos;instantiator&apos;) var widget = instantiate(design) vbox.AddChild(widget) &#125;&#125;)() 그리기이제 design이 필요한 것을 알 것이다. 거의 다 왔다. 이 design파일에 위젯에 관한 코드들이 들어간다. 간단하게 두개의 박스로 된 위젯을 만들었다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344// design.jsfunction titleComment(val) &#123; return &#123; slot: &#123; Padding: &#123; Left: 8, Right: 8, Top: 8, Bottom: 8 &#125; &#125;, type: Border, attrs: &#123; BrushColor: &#123; R: 0.5, G: 0.5, B: 0.2, A: 0.2 &#125;, Padding: &#123; Left: 8, Right: 8, Top: 8, Bottom: 8 &#125; &#125;, children: [ &#123; type: TextBlock, slot: &#123; Size: &#123; SizeRule: &apos;Fill&apos; &#125; &#125;, attrs: &#123; Text: val || &apos;&apos;, Justification: &apos;Right&apos; &#125; &#125; ] &#125;&#125;module.exports = &#123; type: HorizontalBox, slot: &#123; Size: &#123; SizeRule: &apos;Fill&apos; &#125; &#125;, attrs: &#123; Padding: &#123; Left: 15, Right: 15, Top: 15, Bottom: 15 &#125; &#125;, children: [ &#123; slot: &#123; Padding: &#123; Left: 15, Right: 15, Top: 15, Bottom: 15 &#125;, Justification: &apos;Right&apos; &#125;, type: VerticalBox, children: [ titleComment(&apos;Just title&apos;), titleComment(&apos;Just comment&apos;) ] &#125; ]&#125;","categories":[],"tags":[{"name":"Unreal.js","slug":"Unreal-js","permalink":"http://apexsoft.github.io/tags/Unreal-js/"},{"name":"widget","slug":"widget","permalink":"http://apexsoft.github.io/tags/widget/"},{"name":"Unreal Engine 4","slug":"Unreal-Engine-4","permalink":"http://apexsoft.github.io/tags/Unreal-Engine-4/"},{"name":"UMG","slug":"UMG","permalink":"http://apexsoft.github.io/tags/UMG/"}]},{"title":"Unreal.js","slug":"Unreal.js 개발을 위한 초보 가이드","date":"2018-07-31T02:12:47.247Z","updated":"2018-07-31T02:12:47.247Z","comments":true,"path":"2018/07/31/Unreal.js 개발을 위한 초보 가이드/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/Unreal.js 개발을 위한 초보 가이드/","excerpt":"","text":"Unreal.js 개발을 위한 초보 가이드Unreal.js는 어떻게 탄생하게 되었는가 하는건 사실 중요한 것은 아니다. 하지만 Unreal.js가 어떤 기술에 기반을 두고 있는지는 알아둘 필요가 있다. Unreal.js는 React-UMG에서 출발했다. 때문에 React.js와 밀접한 관련이 있으며 npm 혹은 yarn도 함께 알아둘 필요가 있다. 여기서는 node.js를 설치하여 기본으로 npm을 사용하도록 한다. OS는 Windows 10 pro 기준이다. 언리얼엔진을 어느 정도 다루는 사람이 볼 것이라고 여기고 글을 작성한다. ####준비 몇 가지의 설치만 마치면 가벼운 마음으로 시작할 수가 있다.(1번을 먼저 설치하길 권장) Unreal Engine 4 Visual Studio Code node.js 최소 이 정도의 프로그램을 설치했다면 준비는 끝났다.(비-장) 사실 설치가 제일 오래걸리며 지루한 시간이다. 언리얼엔진은 에픽게임즈런처를 통해 설치하므로 엔진설치가 완료되면 런처를 열어 마켓플레이스에 가서 Unreal.js를 검색하고 설치한 언리얼 버전에 맞게 추가한다. 플러그인의 추가도 시간이 약간 소요된다. ####npm 그 동안 잠깐 npm을 만져보자. 바탕화면에 폴더를 하나 만든다. 폴더를 클릭하여 폴더를 열고 Shift키를 누른 상태에서 우클릭을 한다. 그러면 중간 아래쯤에 “여기에 PowerShell 창 열기”라는 옵션이 보일 것이다.(그냥 우클릭하면 안나온다.) 열기를 해주면 퍼렁퍼렁한 창이 나타난다. 그리고 나서 아까 설치했던 Visual Studio Code 라는 프로그램을 실행한다. 자바스크립트를 위한 간편한 에디터이다.(다른 언어도 추가 가능하지만 주 용도는 자바스크립트이다.) 여기에서 상단의 옵션에 있는 파일 - 폴더 열기를 클릭하여 아까 만들었던 폴더를 선택해준다. 그 다음 새파일을 클릭하여 index.js 파일을 만들어준다.(파일 명은 마음대로~) index.js에는 간단한 테스트 내용을 기입하고 Ctrl+S(저장)를 눌러준다. 1console.log(&apos;great start&apos;) 퍼렁퍼렁한 창에 돌아가서 node index.js를 입력하고 엔터를 친다. great start가 출력되면 성공이다. ####Unreal.js 이제 드디어 Unreal.js다. Unreal.js의 Git에 가면 더 많은 정보가 있으니 다운받아서 탐구해봐도 좋다. 여기서 다룰 내용은 git페이지보다는 간단하며 초보적이다. 언리얼 프로젝트를 하나 생성한다. 생성하면 언리얼 에디터가 실행되고 에디터의 상단 아이콘메뉴바에서 세팅을 클릭하면 플러그인 메뉴가 있다. 플러그인의 Installed - Programming을 보면 Unreal.js가 있다. Enabled에 체크를 하고 리스타트를 클릭해준다. 재시작되는 동안 프로젝트를 생성한 폴더를 연다. 폴더를 열면 Content가 있고 그 안에 Scripts 라는 폴더가 있다. 여기에 js파일들을 추가하게 되는 것이다. 아까 작성했던 index.js파일을 이 곳에 넣어준다. 언리얼 에디터가 재시작되면 빈 액터를 하나 생성해서 맵에 추가한다. 액터에 javascript라는 컴포넌트를 추가하고 javascript의 Script Source File이라는 입력란에 index.js를 입력한다. 아까 만든 파일의 이름을 입력하는 것이다. 메뉴바의 창 - 개발자툴 - Javascript console 을 클릭해 콘솔을 연다. 플레이를 누르면 아까 입력했던 great start가 자바스크립트콘솔에 출력되는 것을 볼 수 있다. 1출력로그에선 Javascript: great start 이런 식으로 나온다. 12345function main() &#123; console.log(&apos;great start&apos;)&#125;main() 이렇게 js파일의 내용을 바꾸면 당연 같은 결과가 출력된다.","categories":[],"tags":[{"name":"Unreal.js","slug":"Unreal-js","permalink":"http://apexsoft.github.io/tags/Unreal-js/"},{"name":"Unreal Engine 4","slug":"Unreal-Engine-4","permalink":"http://apexsoft.github.io/tags/Unreal-Engine-4/"},{"name":"node.js","slug":"node-js","permalink":"http://apexsoft.github.io/tags/node-js/"}]},{"title":"spring security","slug":"Spring Security","date":"2018-07-31T02:12:47.246Z","updated":"2018-07-31T02:12:47.246Z","comments":true,"path":"2018/07/31/Spring Security/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/Spring Security/","excerpt":"","text":"1. build.gradle1compile('org.springframework.boot:spring-boot-starter-security') 2. DB, Domain에 USER와 ROLE 필요 User java12345678910111213141516171819202122232425262728293031@Entity@Table(name = \"USER\")@Getter @Setter@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")public class User extends AbstractBaseEntity implements Serializable &#123; @Id @GeneratedValue @Column(name = \"user_id\") private Long id; @NotNull @Column(name = \"user_name\", unique = true) @Size(min = 8) private String userName; @NotNull @Column(name = \"password\") @Size(min = 8) private String password; @Column(name = \"email\") private String email; @ManyToMany @JoinTable(name = \"user_role\", joinColumns = @JoinColumn(name = \"user_id\"), inverseJoinColumns = @JoinColumn(name = \"role_id\")) private Set&lt;Role&gt; roles;&#125; Role java1234567891011121314151617181920212223@Entity@Table(name = \"role\")@Getter @Setter@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")public class Role extends AbstractBaseEntity implements Serializable &#123; @Id @GeneratedValue private Long id; @NonNull private String name; public Role() &#123; &#125; public Role(String name) &#123; this.name = name; &#125; @ManyToMany(mappedBy = \"roles\") private Set&lt;User&gt; users;&#125; 3. UserServiceDetailImpl 생성UserDetailService를 구현해야만 Spring Security가 정상적으로 조회 가능 InMemoryAuthentication설정이 없다면 기본적으로 UserDetailsService구현 객체를 찾아 로그인 요청시 이용한다. InMemoryAuthentication설정이 있으면, UserDetailsService구현 객체가 있어도 해당 흐름을 타지 않는다. java123456789101112131415161718192021222324@Service@RequiredArgsConstructor(onConstructor = @__(@Autowired))public class UserServiceDetailImpl implements UserDetailsService &#123; @NonNull private final UserRepository userRepository; @Override @Transactional(readOnly = true) public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = this.userRepository .findByUserName(username) .orElseThrow(() -&gt; new UsernameNotFoundException(\"사용자 이름을 찾을 수 없습니다.\")); Set&lt;GrantedAuthority&gt; grantedAuthorities = new HashSet&lt;&gt;(); for (Role role: user.getRoles()) &#123; grantedAuthorities.add(new SimpleGrantedAuthority(role.getName())); &#125; return new org.springframework.security.core.userdetails.User(user.getUserName(), user.getPassword(), grantedAuthorities); &#125;&#125; loadUserByUsername메소드를 반드시 구현해야한다. 스프링시큐리티에서 User 정보를 읽을 때 사용된다. User를 읽어왔으면 권한을 부여해준다. 4. 비밀번호 암호화비밀번호 뿐만 아니라 개인 식별정보는 필히 암호화를 거쳐 저장하여야 한다.암호화는 BCrypt 방식을 이용하며 Spring에서 기본적으로 제공되는 클래스는 BCryptPasswordEncoder 이다.passwordEncoder 라는 이름의 빈으로 등록하면 자동으로 적용된다. java1234@Beanpublic BCryptPasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder();&#125; 회원가입 시 패스워드를 DB에 저장할때는 PasswordEncoder 를 통해 암호화하는 로직을 필히 명시해줘야 한다. java12345678910111213141516@Servicepublic class UserServiceImpl implements UserService &#123; @NonNull private final BCryptPasswordEncoder bCryptPasswordEncoder; @Override public User saveUserUser(User user) &#123; user.setPassword(bCryptPasswordEncoder.encode(user.getPassword())); if (Objects.isNull(user.getRoles()) || user.getRoles().isEmpty()) &#123; Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); roles.add(roleRepository.findByName(\"ROLE_USER\") .orElseThrow(() -&gt; new IllegalStateException(\"ROLE is not set\"))); user.setRoles(roles); &#125; return this.userRepository.save(user); &#125;&#125; 5. 로그인1) WebSecurityConfig.java &gt; 로그인 관련 부분java123456789101112.formLogin() .loginPage(\"/user/view/membership/sign-in\") .loginProcessingUrl(\"/user/auth/login\") .usernameParameter(\"userName\") .passwordParameter(\"password\") .successHandler(loginSuccessHandler()) .failureHandler(loginFailureHandler()) .permitAll().and().logout() .logoutRequestMatcher(new AntPathRequestMatcher(\"/user/auth/logout\")) .logoutSuccessHandler(logoutSuccessHandler()) .loginPage(&quot;/user/view/membership/sign-in&quot;) : 로그인 페이지 지정 .loginProcessingUrl(&quot;/user/auth/login&quot;) 로그인을 수행하는 url 지정 해당 url controller를 별도로 지정하지 않음 UserDetailService 구현부분을 찾아서 로그인을 수행함 .usernameParameter(&quot;userName&quot;) : User 도메인 내 아이디 변수를 그대로 작성 .passwordParameter(&quot;password&quot;) : User 도메인 내 비밀번호 변수를 그대로 작성 .successHandler(loginSuccessHandler()) : 로그인 성공핸들러, 대부분 url을 리다이렉트 함 .failureHandler(loginFailureHandler()) : 로그인 실패 핸들러, 대부분 url을 리다이렉트 함 .logoutRequestMatcher(new AntPathRequestMatcher(&quot;/user/auth/logout&quot;)) : method를 지정할 수 있기 때문에 csrf를 적용하고, get을 이용하는 경우에 사용 .logoutSuccessHandler(logoutSuccessHandler()) : 로그아웃 핸들러, 대부분 url을 리다이렉트 함 RestLoginSuccessHandler java12345678910public class RestLoginSuccessHandler extends SimpleUrlAuthenticationSuccessHandler &#123; Logger logger = LoggerFactory.getLogger(RestLoginSuccessHandler.class); @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; logger.info(\"로그인 성공\"); response.sendRedirect(\"/\"); &#125;&#125; RestLoginFailureHandler java1234567891011121314public class RestLoginFailureHandler implements AuthenticationFailureHandler &#123; Logger logger = LoggerFactory.getLogger(RestLoginFailureHandler.class); @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; int cuase=0; if(exception.getClass().equals(BadCredentialsException.class))&#123; cuase=1; &#125; logger.info(\"로그인 실패\"); response.sendRedirect(\"/?cause=\"+cuase); &#125;&#125; RestLogoutSuccessHandler java123456789101112public class RestLogoutSuccessHandler extends SimpleUrlLogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; String targetUrl = determineTargetUrl(request, response); if (response.isCommitted()) &#123; logger.debug(\"Response has already been committed. Unable to redirect to \" + targetUrl); &#125; logger.info(\"로그아웃 성공\"); response.sendRedirect(\"/\"); &#125;&#125; 2) 로그인 화면 sign-in.ftl html123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;div class=\"text-center\"&gt; &lt;h1&gt;로그인&lt;/h1&gt; &lt;form class=\"pure-form pure-form-aligned\" id=\"form-login\"&gt; &lt;fieldset&gt; &lt;div class=\"pure-control-group\"&gt; &lt;label for=\"userName\"&gt;UserName&lt;/label&gt; &lt;input name=\"userName\" v-model=\"userName\" id=\"userName\" class=\"pure-input-1-3\" value=\"\" placeholder=\"UserName\" type=\"text\"&gt; &lt;/div&gt; &lt;div class=\"pure-control-group\"&gt; &lt;label for=\"password1\"&gt;Password&lt;/label&gt; &lt;input name=\"password\" v-model=\"password1\" id=\"password1\" class=\"pure-input-1-3\" value=\"\" placeholder=\"Password\" type=\"password\"&gt; &lt;/div&gt; &lt;div class=\"pure-controls\"&gt; &lt;button class=\"pure-button pure-button-primary pure-u-1-3\" @click.prevent=\"onSignIn()\"&gt;로그인 &lt;/button&gt; &lt;/div&gt; &lt;input type=\"hidden\" name=\"$&#123;_csrf.parameterName&#125;\" value=\"$&#123;_csrf.token&#125;\"/&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; sign-in.js vue.js123456789101112131415161718new Vue(&#123; el: '#app', i18n: apex_lang, data: &#123; userName: '', password1: '', &#125;, methods: &#123; onSignIn() &#123; console.log('onSignIn'); let form = document.getElementById(\"form-login\"); form.method = 'post'; form.action = '/user/auth/login'; form.submit(); &#125; &#125;&#125;); .loginProcessingUrl(&quot;/user/auth/login&quot;) 시큐리티 설정시, 지정했던 url과 동일한 url을 사용 6. 계정 만료 및 잠금에 의한 로그인 실패처리loadUserByUsername 메소드의 반환값은 UserDetails 타입이다. org.springframework.security.core.userdetails.User java1234567private String password;private final String username;private final Set&lt;GrantedAuthority&gt; authorities;private final boolean accountNonExpired;private final boolean accountNonLocked;private final boolean credentialsNonExpired;private final boolean enabled;","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://apexsoft.github.io/tags/springboot/"},{"name":"security","slug":"security","permalink":"http://apexsoft.github.io/tags/security/"}]},{"title":"REDIS","slug":"Redis","date":"2018-07-31T02:12:47.244Z","updated":"2018-07-31T02:12:47.245Z","comments":true,"path":"2018/07/31/Redis/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/Redis/","excerpt":"","text":"REDIS (REmote DIctionary Server)key/Value Store in memory key value database key/value 저장소 특정 키 값에 값을 저장하는 구조 메모리에 데이터를 저장 빠른 read /write 속도 전체적인 저장 가능한 데이터의 용량은 물리적인 용량을 넘을수 없음 RDB나 NoSQL이 기본적으로 file system에 데이터 저장 ​ 유용 사례 최신 랭킹이 필요한 경우 많은 데이터 필요 x , 빠른 처리만 필요 최신 데이터 간의 비교, 차이계산 경우 최근에 이직 신청을 한 다음 직원은? ​ 저장 구조 in-mamory + hard disk 빠른데 + 복구도 가능 Pub/Sub Model 분산 처리 Replication Topology(Master-Slave &lt;- Query Off Loading, Sharding) read/write 성능 향상 ​ 저장 형태 다양한 data set 제공 다양한 집합set 연산 가능 -&gt; 데이터 저장 키 값에 다양한 데이터 타입을 매핑 시킬수 있음 다양한 테이터 타입을 지원 복잡한 구조를 저장 가능​ 관리 정책Persistence(지속성) disk에 저장 가능, shutdown 후에도 데이터 보존 가능 서버가 shutdown된 후 restart되더라도, disk에 저장해놓은 데이타를 다시 읽어서 메모리에 Loading 데이터 저장 방식 RDB[snapshotting] 순간적으로 메모리에 있는 내용을 DISK에 전체를 옮겨 담는 방식 AOF[Append On File] 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태이다 Expiation 데이터 유효기간 설정 가능 (데이터 생명주기를 정해서 일정 시간이 지나면 자동으로 삭제 되게 한다) 내부 정책 Active 데이터 접근할 때 유효기간 체크 passive 주기적으로 키를 100개 랜덤 뽑아 체크 랜덤이라 체크 안된 garbage 잔존가능 expired time이 지난 후 클라이언트에 의해서 접근 되지 않은 데이타는 Active 방식으로 인해서 지워지지 않고 Passive 방식으로 지워져야 하는데, 이 경우 Passive 방식의 경우 전체 데이타를 scan하는 것이 아니기 때문에 ​","categories":[],"tags":[{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"JPA 개념","slug":"JPA 큼직한 개념","date":"2018-07-31T02:12:47.243Z","updated":"2018-07-31T02:12:47.244Z","comments":true,"path":"2018/07/31/JPA 큼직한 개념/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/JPA 큼직한 개념/","excerpt":"","text":"HibernateEJB 엔티티빈 기술을 대체 오픈소스 ORM 프레임워크 JPA (Java Persistence API)EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술표준 (JPA를 하이버네이트로 구현) 자바애플리케이션과 JDBC 사이에서 동작 테이블을 객체 지향적으로 만들어서 사용 (상속이 가능함) 제공하는 기능 (대분류) 엔티티와 테이블을 매핑하는 설계 부분 매핑한 엔티티를 실제 사용하는 부분 장점 생산성 향상 : SQL 작성하고, JDBC api 사용하는 반복적인 일들을 대신 처리해줌. ​ 나아가서 DDL 문을 자동으로 생성해주는 기능도 있음. 유지보수 궁금증Q. 매우 복잡한 SQL은 어떻게 하나요? A.통계와 같은 복잡한 쿼리는 SQL 작성이 더 쉬울수도. 마이바티스나 다른 SQL 매퍼 형태의 프레임워크를 혼용할 수도 있음. Q. 하이버네이트 사용? A. 국내에서 유독 마이바티스를 많이 사용. 전 세계적으로 조사하면 하이버네이트 프레임워크 사용 비중이 더 높음. JPQL엔티티 객체를 조회하는 객체지향 쿼리 네이티브 SQLJPQL을 사용해도 특정 데이터베이스에 의존하는 기능 (예: 오라클/MySQL만의 기능) 을 지원 스프링 데이터 JPA스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트. Repository를 개발할 때 인터페이스만 작성하면 실행 시점에서 스프링 데이터가 JPA가 구현 객체를 동적으로 생성해서 주입해줌. (데이터 접근 객체 구현 시, 구현 클래스 없이 인터페이스만 작성) 책에서 JpaRepository&lt;(객체), (데이터타입)&gt;을 상속 받아서 사용하라고 함. 쇼핑몰 프로젝트에서 모든 Repository는 CrudRepository&lt;(객체), (데이터타입)&gt;을 상속 받음 CrudRepository&lt;(객체), (데이터타입)&gt; : 스프링 데이터 프로젝트가 공통으로 사용하는 인터페이스 JpaRepository&lt;(객체), (데이터타입)&gt; : 스프링 데이터 프로젝트 인터페이스에 JPA 특화된 기능들을 제공 위 인터페이스들을 상속 받아 Repository를 구현하면 엔티티를 제어하는 주요 메소드들을 구현 클래스 작성 없이 사용 가능. 특정 조건에 만족하는 쿼리 수행하는 방법 쿼리를 유추할 수 있는 메소드 이름을 통해 쿼리를 정의. 메소드 이름 규칙 : findBy + (조건 필드이름) + (And) / (Or) java123public interface UserRepository extends Repository&lt;User, Long&gt; &#123; List&lt;User&gt; findByEmailAddressAndLastname(String emailAddress, String lastname);&#125; 쿼리 메소드 기능스프링 데이터 JPA가 제공하는 기능 대표적인 기능은 메소드 이름만으로 쿼리를 생성하는 기능. Repository 인터페이스에서 메소드만 선언하면 해당 메소드 이름(정해진 규칙에 따라 메소드 이름을 지어야 함)으로 적절한 JPQL 쿼리를 생성하여 실행. 쇼핑몰 프로젝트 내 해당 부분 java12345@Repositorypublic interface CartItemRepository extends CrudRepository&lt;CartItem, CartItemId&gt; &#123; List&lt;CartItem&gt; findCartItemsByCart(Cart cart);&#125; 그 외 다양한 기능들 포함함. 엔티티의 생명주기 비 영속 : 엔티티를 new 한 시점 영속 : 엔티티를 new 한 후 persist(삽입), find(조회), query 메소드를 사용하여 저장, 조회한 경우 삭제 : 영속 객체를 remove 메소드로 삭제한 경우 준 영속 : 트랜잭션이 commit되었거나 clear, flush 메소드가 실행된 경우. 이걸 다시 영속 객체 상태로 만들기 위한 merge 메소드가 존재함. 영속성 컨텍스트Entity Manager가 엔티티들을 관리할 때 이곳에 보관하고 관리함. 관리되는 모든 엔티티 인스턴스의 집합. EntityManager엔티티의 생명주기, 영속성 컨텍스트, 트랜잭션을 관리함 EntityManagerFactoryEntityManager를 관리","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"JPA 엔티티 구성","slug":"JPA 엔티티 구성","date":"2018-07-31T02:12:47.242Z","updated":"2018-07-31T02:12:47.243Z","comments":true,"path":"2018/07/31/JPA 엔티티 구성/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/JPA 엔티티 구성/","excerpt":"","text":"JPA 엔티티 구성쇼핑몰 소스/중요도 위주로 작성함 레퍼런스@Entity테이블과 매핑할 클래스는 필수로 붙혀야 함 @Table엔티티와 매핑할 테이블을 지정 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용. name : 매핑할 테이블 이름 @Id기본키 직접 할당 @GeneratedValue@Column객체 필드를 테이블 컬럼에 매핑 name : 필드와 매핑할 테이블의 컬럼 이름. 기본값이 필드 이름 java12@Column(name = \"cart_id\")private Long id; columnDefinition : 데이터베이스 컬럼 정보를 직접 설정. nullable : null 값 허용 여부 false일 경우, not null 제약조건이 됨. 기본값이 true @JoinColumn관계를 나타낼 때 사용. 외래 키를 매핑할 때 사용. name : 매핑할 외래 키 이름 @JsonIdentityInfo? @RequiredArgsConstructor생성자를 자동으로 만들어주고, 옵션에 따라 null 체크도 해줌 엔티티 관계 설정 (관계를 가진 엔티티끼리 조인할 때 사용)@ManyToOne다대일 관계 설정에서 사용 fetch : 글로벌 페치 전략을 설정 FetchType.EAGER : 관계된 엔티티의 정보를 미리 읽어오는 것 FetchType.LAZY : 관계된 엔티티의 정보를 실제 요청하는 순간 가져오는 것 java1234567public class CartItem extends BaseEntity implements Serializable &#123; .. @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"cart_id\") private Cart cart; ..&#125; @OneToMany일대다 관계 설정에서 사용 mappedBy : 양방향 관계 설정시 관계의 주체가 되는 쪽에서 정의 fetch : 관계 엔티티의 데이터 읽기 전략을 결정. FetchType.EAGER : 관계된 엔티티의 정보를 미리 읽어오는 것 FetchType.LAZY : 관계된 엔티티의 정보를 실제 요청하는 순간 가져오는 것 java1234567public class Cart extends BaseEntity implements Serializable &#123; .. @OneToMany(mappedBy = \"cart\", fetch = FetchType.EAGER) @OrderBy(\"created_at asc\") private List&lt;CartItem&gt; cartItems; ..&#125; @ManyToOne과 @OneToMany 두가지가 크게 다르지 않음. 어느쪽을 기준으로 작성하느냐에 따라 다름 JPA는 다양한 쿼리 방법을 지원 JPQL JPA Criteria QueryDSL 네이티브 SQL JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께 사용 JPQL로 쿼리 사용SQL과 유사한 문법을 가지는 쿼리. 엔티티 객체를 대상으로 쿼리 두 개의 엔티티를 조인해야 하는 경우, 이런 방법을 쓰는 것 같음. java12345EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"(db정보가 들어갈 듯?)\");EntityManager em = emf.createEntityManager();String jpql = \"select m from Member as m where m.username = 'kim'\";List&lt;Member&gt; resultList = em.createQuery(jpql, Member.class).getResultList(); 실제 실행된 쿼리 sql123456789select member.id as id, member.age as age member.team_id as team, member.name as namefrom Member memberwhere member.name = 'kim'","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]},{"title":"HeidiSQL에서 csv파일을 import하기","slug":"HeidiSQL에서 csv 파일 import하기","date":"2018-07-31T02:12:47.241Z","updated":"2018-11-26T02:53:50.492Z","comments":true,"path":"2018/07/31/HeidiSQL에서 csv 파일 import하기/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/HeidiSQL에서 csv 파일 import하기/","excerpt":"","text":"엑셀파일을 csv utf-8 로 저장 HeidiSQL &gt; 도구 &gt; CSV 파일 가져오기 선택 설정 필드 종결자 : , 줄 종결자 : \\r 엑셀에서 다른이름으로 저장한 csv파일은 필드종결자와 줄 종결자가 기본으로 위와같이 설정되므로, 필드 종결자, 줄 종결자를 위와 같게 수정한다.","categories":[],"tags":[{"name":"HeidiSQL","slug":"HeidiSQL","permalink":"http://apexsoft.github.io/tags/HeidiSQL/"}]},{"title":"블로그 만들기","slug":"Github page와 Hexo 이용, 기술 블로그 만들기","date":"2018-07-31T02:12:47.239Z","updated":"2018-07-31T02:12:47.240Z","comments":true,"path":"2018/07/31/Github page와 Hexo 이용, 기술 블로그 만들기/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/Github page와 Hexo 이용, 기술 블로그 만들기/","excerpt":"","text":"Github page와 Hexo 이용, 기술 블로그 만들기Git Page1. Github Repository 생성 https://github.com/ New Repository, Repository 이름은 USERNAME.github.io USERNAME 은 Github의 가입시에 사용자의 username을 입력한다 Public / Private 중 Public 선택 Create Repository 버튼을 통해 Repository 생성 확인 - https://USERNAME.github.io Hexo Hexo는 Jekyll와 함께 대표적으로 정적 페이지를 쉽게 만들 수 있도록 도와주는 서비스이다.Hexo의 경우에는 npm을 통해 쉽게 설치가 가능하고 한 줄의 Command Line을 통해 Github에 바로 배포다양한 플러그인과 테마를 지원하고 있다 1. 다운로드 Node.js Git 2. 설치 Hexo node.js1$ npm install -g hexo -cli git node.js1$ npm install hexo-deployer-git --save 3. 블로그 생성bash 123$ hexo init [폴더명]$ cd [폴더명]$ npm install 4. 설정파일 ( _config.yml ) 수정 root 디렉토리에 _config.yml 파일로, 블로그에 대한 설정 한다 문서 - https://hexo.io/docs/ 기본 설정 site 정보 _config.yml1234title: apexsoft 기술블로그 subtitle: 우리모두 masterdescription:author: Hyosook Kim ​ URL 정보 _config.yml1234url: http://apexsoft.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults: ​ Github 정보 _config.yml1234deploy: type: git repo : https://github.com/ApexSoft/apexsoft.github.com.git branch : master 테마 적용 테마 선택 - https://hexo.io/themes/ git clone bash12# hexo [폴더/themes]에 다운$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman _config.yml` theme 수정 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: hueman #폴더명과 매칭되어야한다 검색 기능 (Insight earch)를 이용하기 위해서는 hexo-generator-json-content를 설치 bash1npm install -S hexo-generator-json-content 테마 폴더 안에 있는 _config.yml.example의 이름을_config.yml로 수정 clean bash1$ hexo clean ​ http://futurecreator.github.io/2016/06/14/hexo-apply-hueman-theme/ 5. 포스트 작성 새 포스트 만들기 bash1$ hexo new post [post_name] or 123ㄴ source ㄴ _posts - ##여기에 .md파일 넣기 포스트 제목 및 수정 1234567---title: \"블로그 만들기 \" #post 제목date: 2017-07-07 00:23:23 #post 생성 날짜tags: [\"hexo\", \"clean-blog\", \"theme\"] #tagscover: /assets/contact-bg.jpg #post 커버 이미지subtitle: \"첫 블로그입니다.\" #post 부제--- ​ 6. 로컬에서 testbash1$ hexo server http://localhost:4000 7. Github Page Repository에 배포 정적 리소스 생성 bash1$ hexo generate 배포 bash1$ hexo deploy 생성 + 배포 한번에 bash1$ hexo deploy --generate 확인 http://apexsoft.github.io/ https://github.com/ApexSoft/apexsoft.github.com.git -master branch ​ 8. 소스관리 master : 블로그 (html) 파일 , hexo를 통해서 deploy 된 소스 soucre : hexo 원본 파일들. 9. 사용 git clone &gt; source branch &gt; https://github.com/ApexSoft/apexsoft.github.com.git .md 파일 올리기 git push &gt; source branch &gt; https://github.com/ApexSoft/apexsoft.github.com.git deploy 10. 기타 테마가 적용 안되는 경우 bash1$ hexo clean 테마 안에 있는 git 삭제 bash1$ rm -rf .git 배포가 되지 않는 경우 해볼 것들 git을 못 찾는다면 hexo-deployer-git 설치 bash1$ npm install hexo-deployer-git --save github 관련 에러 경우 http://maxisam.github.io/2016/09/02/Hexo-got-error-on-deploying-to-github/ 블로그 참고 1) Git Credential Manager for Windows 설치 https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases 2) git bash에서 명령어 실행 bash1$ git config --global credential.helper wincred 3) 자격증명 삭제 제어판 &gt; 사용자계정 &gt; 자격증명 관리자 &gt; windows 자격 증명 &gt; 일반 자격 증명 에서 github.com 자격증명을 제거 deploy 혹은 push를 할때, 다시 ID&amp;PW를 입력해야 한다.","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://apexsoft.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://apexsoft.github.io/tags/github/"}]},{"title":"Drag and drop","slug":"Drag and drop 컴포넌트","date":"2018-07-31T02:12:47.238Z","updated":"2018-07-31T02:12:47.239Z","comments":true,"path":"2018/07/31/Drag and drop 컴포넌트/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/Drag and drop 컴포넌트/","excerpt":"","text":"Drag and dropSortablehttps://github.com/RubaXa/Sortable Sortable을 vue component로 만든 Draggablehttps://github.com/SortableJS/Vue.DraggableDraggable 직접 구현한 예제 https://codepen.io/anon/pen/dzvzGy?editors=1010 html1234567891011121314&lt;head&gt; &lt;!-- CDNJS :: Sortable (https://cdnjs.com/) --&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/Sortable/1.6.0/Sortable.min.js\"&gt;&lt;/script&gt; &lt;!-- CDNJS :: Vue.Draggable (https://cdnjs.com/) --&gt; &lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/Vue.Draggable/2.14.1/vuedraggable.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;draggable v-model=\"list2\" class=\"dragArea\" :options=\"secondOption\"&gt; &lt;div v-for=\"(element, index) in list2\" :key=\"index\"&gt;&#123;&#123;element.name&#125;&#125; &lt;button @click=\"remove(index)\"&gt;remove&lt;/button&gt; &lt;/div&gt; &lt;/draggable&gt;&lt;/body&gt; vue.js123456789101112131415...data: &#123; firstOption: &#123; group: &#123; name: 'people', pull: 'clone', put: false &#125;, sort: false &#125;, secondOption: &#123; group: 'people' &#125;&#125;... option 속성 속성명 자세한 속성 내용 pull false 선택하여 이동하는 드래그앤드롭 안됨 true 선택한 객체를 드래그앤드롭으로 이동 clone 선택한 객체가 복사되어 드래그앤드롭 가능 put false 드래그로 들어온 객체를 현재 목록에 드롭시키지 못함 true 드래그로 들어온 객체를 현재 목록에 드롭시킬 수 있음 array [foo, boo] sort true 현재 선택한 객체를 현재 리스트 안에서 드래그앤드롭으로 정렬할 수 있음 false 현재 선택한 객체를 현재 리스트 안에서 드래그앤드롭으로 정렬할 수 없음","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"}]},{"title":"컴포넌트와 플러그인","slug":"Component&plugin","date":"2018-07-31T02:12:47.236Z","updated":"2018-07-31T02:12:47.237Z","comments":true,"path":"2018/07/31/Component&plugin/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/Component&plugin/","excerpt":"","text":"Component 기본 html 엘리먼트를 확장하여 재사용 가능한 코드 단위로 묶음 컴포넌트를 지역/전역적으로 사용할 수 있는 소스코드가 들어있음 일반적인 외부 컴포넌트들이 사용가능한 소스코드를 제공하는 것으로 보임 외부 컴포넌트의 경우, webpack을 사용해 bundle하여 js파일만 제공하는 컴포넌트가 많음 외부 컴포넌트 사용방법 npm install 및 cdn import (npm install인 경우) javascript1import apexCalendar from 'vue-apex-calendar' 지역 javascript123new Vue(&#123; components: &#123;'apex-calendar': apexCalendar&#125;&#125;) 전역 javascript1Vue.component('apex-calendar', apexCalendar) Plugin 일반적으로 여러 컴포넌트들을 묶어서 기능을 만든 경우, 하나의 플러그인 형태로 배포 배포하는 쪽 (install할 때) 에서 지역/전역 선택하여 배포 전역 배포 및 사용 install javascript123456function install(Vue)&#123; Vue.component(\"vuetable\", Vuetable); Vue.component(\"vuetable-pagination\", VueTablePagination); Vue.component(\"vuetable-pagination-dropdown\", VueTablePaginationDropDown); Vue.component(\"vuetable-pagination-info\", VueTablePaginationInfo);&#125; 사용 javascript1Vue.use(SurveyEditor); html1&lt;draggable-canvas slot=\"viewport\"&gt;&lt;/draggable-canvas&gt; Vue.use() 하면, 범위 안에서 컴포넌트를 전역으로 사용할 수 있다. 지역 배포 및 사용 install (survey 플러그인에서 발췌) javascript12345678910111213141516import SurveyEditor from './components/SurveyEditor';import DraggableCanvas from './components/questionEditor/DraggableCanvas';import Toolbox from './components/Toolbox';import EditDialog from './components/dialog/EditDialog';function install(Vue, options) &#123;&#125;export &#123; SurveyEditor, DraggableCanvas, Toolbox, EditDialog, install,&#125;;export default SurveyEditor; https://kr.vuejs.org/v2/guide/plugins.html 참고 사용 사용을 원하는 컴포넌트를, 지역으로 선언하여 사용한다. javascript12345678910import SurveyEditor from 'survey-editor';Vue.use(SurveyEditor);new Vue(&#123; el: '#app', components: &#123; canvas: SurveyEditor.DraggableCanvas, &#125;&#125;) import : 소스코드를 읽어옴 use() : survey 플러그인 내부 install 호출 html1&lt;canvas slot=\"viewport\"&gt;&lt;/canvas&gt; 결론일반적으로 단일 컴포넌트인 경우, 컴포넌트로 사용하고, 여러컴포넌트들을 모아서 기능을 만든 경우는 플러그인 형태로 배포하여 사용한다.","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://apexsoft.github.io/tags/vue-js/"},{"name":"component","slug":"component","permalink":"http://apexsoft.github.io/tags/component/"},{"name":"plugin","slug":"plugin","permalink":"http://apexsoft.github.io/tags/plugin/"}]},{"title":"AR & VR","slug":"AR & VR","date":"2018-07-31T02:12:47.233Z","updated":"2018-07-31T02:12:47.233Z","comments":true,"path":"2018/07/31/AR & VR/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/AR & VR/","excerpt":"","text":"AR &amp; VR ##증강현실( AR) 1증강현실(增強現實, 영어: augmented reality, AR)은 가상현실(VR)의 한 분야로 실제 환경에 가상 사물이나 정보를 합성하여 원래의 환경에 존재하는 사물처럼 보이도록 하는 컴퓨터 그래픽 기법이다. 디지털 미디어에서 빈번하게 사용된다.[1] [2] 세계 최초의 AR폰 &apos;팹2 프로&apos;는 구글의 AR 플랫폼이 적용된 스마트폰이다. 1. 개요기존의 가상 현실은 가상의 공간과 사물만을 대상으로 하고 있었다. 증강현실은 현실 세계의 기반위에 가상의 사물을 합성하여 현실 세계만으로는 얻기 어려운,또는 마켓팅의 목적으로 전달 하는 부가적인 정보들을 보강해 제공할 수 있다. 완전한 가상세계를 전제로 하는 가상현실과는 달리 현실세계의 환경위에 가상의 대상을 결합시켜 현실의 효과를 더욱 증가시키는 것이다. 물리적 공간에 컴퓨팅 파워를 가진, 정보화된 인공물(information artefacts)이 가득 채워지게 되면 물리적 공간의 성격 자체가 변화하게 된다. 이러한 특징 때문에 단순히 게임과 같은 분야에만 한정된 적용이 가능한 기존 가상 현실과 달리 다양한 현실 환경에 응용이 가능하다. 특히, 유비쿼터스 환경에 적합한 차세대 디스플레이 기술로 각광받고 있다. 유비쿼터스 컴퓨팅 환경에서는 증강현실을 통해 일상적인 사물(object)과 장소(place)가 정보처리와 정보교환을 수행하게 된다. 유비쿼터스 컴퓨팅 환경에서 컴퓨팅 파워가 적용되는 ‘대상(objects)’ 또는 ‘사물(things)’에는 기존 생활설비, 나아가 일상적인 제품과 사물까지 포함된다. 이때 유비쿼터스 IT가 적용되는 대상이나 사물은 특정한 위치(또는 장소)에 고정되어 있는 것이든 지속적으로 움직이는 것이든 관계없다.하지만 아직까지는 기술의 한계로 움직이는 대상으로 하는 것은 한정적이다. 2. 정의증강현실은 사용자가 눈으로 보는 현실세계에 가상 물체를 겹쳐 보여주는 기술이다. 현실세계에 실시간으로 부가정보를 갖는 가상세계를 합쳐 하나의 영상으로 보여주므로 혼합현실(mixed reality, MR)이라고도 한다. 현실환경과 가상환경을 융합하는 복합형 가상현실 시스템(hybrid VR system)으로 1990년대 후반부터 미국·일본을 중심으로 연구·개발이 진행되고 있다. 현실세계를 가상세계로 보완해주는 개념인 증강현실은 컴퓨터 그래픽으로 만들어진 가상환경을 사용하지만 주역은 현실환경이다. 컴퓨터 그래픽은 현실환경에 필요한 정보를 추가 제공하는 역할을 한다. 사용자가 보고 있는 실사 영상에 3차원 가상영상을 겹침(overlap)으로써 현실환경과 가상화면과의 구분이 모호해지도록 한다는 뜻이다. 가상현실기술은 가상환경에 사용자를 몰입하게 하여 실제환경을 볼 수 없다. 하지만 실제환경과 가상의 객체가 혼합된 증강현실기술은 사용자가 실제환경을 볼 수 있게 하여 보다 나은 현실감과 부가 정보를 제공한다. 예를 들어 스마트폰 카메라로 주변을 비추면 인근에 있는 상점의 위치, 전화번호 등의 정보가 입체영상으로 표기된다. 원격의료진단·방송·건축설계·제조공정관리 등에 활용된다. 최근 스마트폰이 널리 보급되면서 본격적인 상업화 단계에 들어섰으며, 게임 및 모바일 솔루션 업계·교육 분야 등에서도 다양한 제품을 개발하고 있다. 증강현실을 실외에서 실현하는 것이 착용식 컴퓨터(wearable computer)이다. 특히 머리에 쓰는 형태의 컴퓨터 화면장치는 사용자가 보는 실제환경에 컴퓨터 그래픽·문자 등을 겹쳐 실시간으로 보여줌으로써 증강현실을 가능하게 한다. 따라서 증강현실에 대한 연구는 착용컴퓨터 개발이 주를 이룬다. 개발된 증강현실시스템으로 비디오방식과 광학방식 등의 HMD(head mounted display)가 있다. 이반 서덜랜드가 see-through HMD를 발전시킨 것을 시초로 하여 연구되기 시작한 증강현실은 가상 현실의 한 분야로서 가상 현실과는 또 다른 의미를 가진다. 가상현실 기술은 일반적으로 사용자가 가상의 환경에 몰입하게 하므로 사용자는 실제 환경을 볼 수 없는 반면, 증강현실 기술에서는 사용자가 실제 환경을 볼 수 있으며, 실제 환경과 가상의 객체가 혼합된 형태를 띤다. 다시 말하면, 가상 현실은 현실 세계를 대체하여 사용자에게 보여 주지만 증강현실은 현실 세계에 가상의 물체를 중첩함으로써 현실 세계를 보충하여 사용자에게 보여 준다는 차별성을 가지며, 가상 현실에 비해 사용자에게 보다 나은 현실감을 제공한다는 특징이 있다. 무엇보다 중요한 것은 증강현실이 현실에는 부재하는 속성을 가상 현실을 통해서 현실 사물에 내재시킴으로써 증강된 현실을 보여 준다는 것이다. 로널드 아즈마(Ronald Azuma)의 증강현실에 대한 정의가 그 특징을 가장 잘 설명해 주고 있다. 거기에서 그는 증강현실의 목적에 대한 몇 가지 요소를 거론하는데 그것을 통해서 전체적인 증강현실의 의미를 파악할 수 있다. 아즈마의 정의에 따르면, 증강현실 시스템이란, 현실(Real-world elements)의 이미지와 가상의 이미지를 결합한 것. 실시간으로 인터랙션(interaction)이 가능한 것. 3차원의 공간 안에 놓인 것. 으로 여겨진다. 이 정의들은 이제 종종 리서치 보고서 등에서 사용되고 있다 (Azuma, 1997). 3. 증강현실(AR)과 가상현실(VR)의 구분 가상현실 - 현실에서 존재하지 않는 환경에 대한 정보를 디스플레이 및 렌더링 장비를 통해 사용자로 하여금 볼 수 있게 한다. 그리고 이미 제작된 2차원, 3차원 기반을 사용하므로 사용자가 현실감각을 느낄 수는 있지만 현실과 다른 공간 안에 몰입하게 된다. 증강현실 - 가상현실과는 달리 사용자가 현재 보고 있는 환경에 가상 정보를 부가해준다는 형태이다. 즉 가상현실이 현실과 접목되면서 변형된 형태 중 하나이다. 때문에 사용자가 실제 환경을 볼 수 있으므로 가상의 정보 객체(예: 기후정보, 버스노선도, 맛집 길 안내)가 현실에 있는 간판에 표시되기도 한다. 디스플레이를 통해 모든 정보를 보여준다면, 이는 가상현실이며, 음식점 간판에 외부 투영장치를 통해 현재 착석 가능한 자리 정보를 제공한다면 이는 증강현실이라 말할 수 있다. 4. 증강현실 개념이 자리잡게 된 배경증강현실의 역사를 기술하기 위해서는, 인간의 자연 세계에 대한 의미 부여의 역사를 같이 기술해야 한다. 15,000 BC : Lascaux 동굴 벽화는 어두운 동굴 속에서도 현실 세계의 의미를 덧붙이려는 “가상”의 이미지들을 보여 준다. 1849 : Richard Wagner 는 어두운 공연장 안에서의 이미지와 소리를 이용해 관객들에게 몰입의 경험을 소개했다. 1938 : Konrad Zuse는 Z1&amp;action=edit&amp;redlink=1)라고 불리는 첫 번째 디지털 컴퓨터를 개발했다. 1948 : 노버트 위너는 사이버네틱스라는 과학분야를 만들었다. 그 분야의 목적은 인간과 기계 간의 메시지 전달이다. 1962 : 영화 촬영기사였던 morton Heilig는 Sensorama라 불리는 오토바이 시뮬레이터를 개발했는데, 그것은 영상과, 소리, 진동 그리고 냄새까지 이용했다. 1966 : 이반 서덜랜드 는 가상 세계로 안내하는 창(Window)이 될 것이라고 제안하면서, HMD를 개발했다. 1975 : Myron Krueger는 처음으로 사용자로 하여금 가상의 물건들과 인터랙션을 가능하게 했던 Videoplace를 만들었다. 1989 : Jaron Lanier는 가상 현실이라는 신조어를 만들었고, 첫 번째로 가상 세계를 이용한 수익 창출 모델을 고안했다. 1990: Tom Caudell은 보잉사가 작업자들에게 항공기의 전선을 조립하는 것을 돕기 위한 과정에서 증강현실이란 용어를 만들었다. 참고 : 위키백과 증강현실(AR), 미국 제조업의 새로운 기술로 자리 잡다□ 증강현실 시장현황 ㅇ 시장동향 ​ - 전자·통신분야 시장조사기관 Digi-Capital의 자료에 따르면, 전 세계 가상·증강현실 시장규모는 2016년부터 2017년까지 200억 달러로 성장한 뒤 2020년까지 급성장해 1200억 달러 규모에 달할 것으로 예측함. ​ - 전문조사기관 Digi-Capital은 2020년까지 증강현실(AR) 시장규모를 약 900억 달러로 예측했으며, 가상현실 시장규모 또한 300억 달러에 다다를 것이라 전망함. ​ - 2020년까지 가상현실은 게임과 3D영화와 같은 부분에서 강세를 이어나갈 것이라 전망됨. ​ - 증강현실(AR)은 현재의 휴대전화나 태블릿 시장과 비슷하게 하드웨어의 매출규모가 상당한 부분을 차지할 것이라 예측됐고, 하드웨어에 필요한 소프트웨어, 데이터와 같은 부분들 또한 성장할 것이라 판단함. ​ - 이 조사기관은 2018년에서 2019년으로 넘어가는 시점에서 증강현실(AR) 기술의 매출이 가상현실(VR) 기술 관련 매출을 뛰어넘는 포인트가 되는 해가 될 것이라고 예측함. 가상 및 증강현실 기술 시장 전망 자료원: Digi-Capital ㅇ 증강현실 기술이 주목을 받은 것은 지난 2016년 7월 GPS기반 증강현실(AR) 모바일 게임 ‘포켓몬 고’가 등장해 증강현실 기술에 세간의 관심이 집중되면서부터임. ㅇ 그 이후 게임, 패션 등 다양한 분야에서 증강현실 기술이 활용되고 있음. 최근 가장 유망한 산업으로 제조업 분야에서의 증강현실 기술 활용 접목이 기대되고 있음. ㅇ 시장조사기관 IDC의 발표에 따르면, 증강현실 시장은 2016년 기준 2억 달러 규모에서 2021년에는 490억 달러 규모로 성장할 것으로 예상됨. ​ - 이러한 가운데 증강현실 기술의 경우 특히 제조업 분야에서의 그 중요성이 매우 커질 것으로 예상되고 있음. □ 제조업 기업과 증강현실의 만남 ㅇ 록히드 마틴(Lockheed Martin)의 마이크로소프트 기술 활용 ​ - 미국 최대 방위산업체 록히드 마틴(Lockheed Martin)의 증강현실을 활용 사례를 볼 수 있음. ​ - 현재 록히드 마틴에서는 2018년 회사의 주요 프로젝트로 진행 중인 화성탐사선을 비롯한 우주선의 디자인 및 제작 과정에 마이크로소프트의 홀로렌즈를 활용하고 있는 것으로 알려짐. ​ - 록히드 마틴의 내부 관계자는 증강현실 기술이 인공위성이나 우주선을 제작하는 데 참고해야 하는 방대한 정보를 하나로 모으는 일에 큰 도움이 된다고 밝힘. ​ - 그는 기술자가 우주선이나 우주선 및 기타 모든 제품을 제작할 때 참조해야하는 모든 정보를 하나로 모으는 기능과 그 정보들을 손쉽게 기술자들에게 전달해주는 능력은 이 제품이 가진 엄청난 장점이라고 전함. 록히드 마틴 기술자들이 증강현실을 체험하는 모습 자료원: PC World ㅇ 보잉(Boeing) ​ - 세계 최대 항공기 제조업체 보잉 역시 마이크로소프트의 증강현실 기술을 이용해 비행기 내 전기부품을 연결하는 작업을 진행하고 있음. ​ - 보잉은 이 기술을 비행기 부품 연결 작업뿐 아니라 산불대비 훈련으로도 쓰고 있음. 이 기술을 활용해 산불에 대한 정보 및 각종 항공정보를 실시간으로 접수받아 가장 효율적인 전략을 생산할 수 있게 됨. ​ - 보잉의 한 엔지니어는 가상현실 3D기술을 통해 실시간 회의를 할 수 있으며, 더 자세한 정보도 얻을 수 있어 만일의 사태에 대한 확실한 대비가 가능하게 됐다며, 현재 증강현실 기술은 회사에서 없어서는 안 되는 기술이라고 전함. ㅇ BMW와 구글의 가상현실 기술 ​ - 제조업과 증강현실 기술의 접목은 폴크스바겐이나 BMW와 같은 자동차 제조업체에서도 이루어지고 있음. ​ - BMW는 독일을 대표하는 자동차 회사이며 Mercedes Benz와 더불어 독일의 2대 고급차 제조사로 손꼽힘. BMW는 자사의 자동차 판매를 촉진시키기 위한 전략으로 구글의 증강현실 기술 ‘탱고(Tango: 스마트폰에 탑재된 센서와 카메라를 사용해 디지털 이미지를 실제 공간에 입히는 기술)’를 활용할 것으로 보임. 이를 통해 소비자들은 BMW 자동차 판매장을 방문할 필요 없이 증강현실 기술을 통해 원하는 곳에서 스마트폰으로 BMW의 자동차 내부를 구경할 수 있게 됐음. ​ - 특히 BMW는 제조 과정뿐만 아니라 마케팅 활동에도 증강현실 기술을 적극 활용하고 있으며, 실제로 최근 구글의 증강현실 기술 탱고를 이용해 가상의 자동차 전시장을 만들 계획이라고 발표함. ​ - 구글의 증강현실 기술 책임자에 의하면 탱고를 통해 소비자들은 자동차를 구매하기 전, 자동차의 실제 사이즈와 색을 소비자들이 가상현실로 경험할 수 있을 것이라고 함. ​ - BMW와 구글의 기술 ‘탱고’ 서비스는 핸드폰으로 애플리케이션을 다운받으면 직접 액세스가 가능하며, 사용자는 이후에 가상현실 기술을 통해 자동차의 색상과 사이즈를 확인할 수 있을 것으로 예상됨. ​ - BMW는 현재 ‘i Visualizer’ 애플리케이션을 먼저 공개할 계획이며, 소비자들은 앱을 통해 BMW 차량 i3와 i5 모델들을 대상으로 자동차에 대한 사전확인이 가능함. □ 시사점 ㅇ 제조업 증강현실 기술의 활용으로 다양한 이득 쟁취 ​ - BMW의 경우 자동차 제조사의 마케팅적인 요소로서 최근 가장 뜨거운 기술인 가상 및 증강현실 서비스 기술 ‘탱고’를 제공해 자동차 관련 판매를 증진시키는 데 초점을 맞추고 있음. ​ - 이러한 신기술 적용은 후발 제조업체로부터 서비스 우위를 견고히 하며, 지속적으로 소비자와 소통할 수 있는 채널을 유지하게 함. ㅇ 미국 제조업체들, 가상현실뿐 아니라 다양한 혁신기술 서비스 업체들과의 협력 활발해질 것 ​ - 미국의 대표 자동차 제조사 GM은 차량공유 서비스 업체 리프트와 협업해 2018년까지 자율주행차 테스트를 본격적으로 실시할 예정이라고 발표함. ​ - GM은 자사의 전기차 모델 볼트(Volt)를 자율주행차량으로 집중 발전시킬 것이라고 했고, 개발한 차량을 리프트에 공급해 차량 공유 서비스 모델에도 적극적으로 활용될 예정이라고 밝힘. ​ - 리프트와 GM은 협업을 통해 GM자동차의 공급망을 넓히려는 계획을 가지고 있다고 밝혔으며, 자동차를 보유하지 않은 운전자들도 GM자동차를 일정 기간 동안 렌트해 리프트 플랫폼을 통해 유사 콜택시와 비슷한 영업을 할 수 있게 될 것으로 전망됨. ​ - GM(제조사)은 자율주행 자동차 서비스 상용화를 리프트와 협력해 기술 촉진을 발휘, 경쟁업체들과의 경쟁에서 우위를 지켜냄. ​ - 그렇게 생산된 자율주행자동차는 서비스 회사에 다시 공급돼 서비스 플랫폼에 활용됨과 동시에 제조사의 매출에 도움을 줌. ​ - 결과적으로 제조사는 서비스사와 전략적 제휴를 맺어 기술발전 및 매출을 촉진시킬 수 있으며, 또 다른 이익창출 채널을 만듦으로써 제조사에서 생산하고 서비스사의 플랫폼을 통해 이익창출이 가능해짐. ㅇ 한국 기업들, 단순 제조로는 앞으로 국제사회 승산 없을 것으로 예측됨. ​ - 현재 미국의 트렌드는 제조업계의 회사들이 점차 증강현실과 같은 신기술 혹은 새로운 서비스 업체들과의 협업을 통해 매출을 증가시키는 것임. 이는 해당 회사들이 현 시대 혹은 멀지않은 미래에는 단순제조 후 단순판매에는 한계점이 있다고 분석하는 것임. ​ - 이러한 트렌드를 반영해 한국 제조업체들도 단순 제조보다는 기술적인 접목이 가능한 제조를 할 필요가 있음. 예를 들어, 자동차 바퀴를 제조할 경우에도 GPS 기술을 접목해 제조하는 등 제조품목에도 한 두 가지의 기술을 더 접목할 수 있어야 함. 자료원: Digi-Capital, Computer World, LA Times, PwC, 그 외 KOTRA 로스앤젤레스 무역관 자료 종합 참고 : 해외시장뉴스 가상현실(VR)1가상현실(假想現實, 영어: virtual reality, VR)은 컴퓨터 등을 사용한 인공적인 기술로 만들어낸 실제와 유사하지만 실제가 아닌 어떤 특정한 환경이나 상황 혹은 그 기술 자체를 의미한다.[1] [2] [3] 이때, 만들어진 가상의(상상의) 환경이나 상황 등은 사용자의 오감을 자극하며 실제와 유사한 공간적, 시간적 체험을 하게 함으로써 현실과 상상의 경계를 자유롭게 드나들게 한다. 또한 사용자는 가상현실에 단순히 몰입할 뿐만 아니라 실재하는 디바이스를 이용해 조작이나 명령을 가하는 등 가상현실 속에 구현된 것들과 상호작용이 가능하다. 가상현실은 사용자와 상호작용이 가능하고 사용자의 경험을 창출한다는 점에서 일방적으로 구현된 시뮬레이션과는 구분된다. 쉽게 떠올릴 수 있는 가상현실 시스템의 예로는 비행훈련시뮬레이션과 3D로 표현되었으며 사용자의 의지가 반영될 수 있는 세컨드라이프와 같은 게임이 있다. AR / VR 시장은 이미 수십억 달러 규모의 시장으로 자리 잡고 있으며 수년 내에 1,200 억 달러 시장을 훨씬 넘어서 계속 성장할 것으로 예상됩니다. 1. 분류 제시방식에 따른 분류 가상현실은 컴퓨터 등이 만들어 낸 가상의 세계를 사용자에게 제시하는 것과 현실의 세계를 사용자에게 제시하는 것으로 구분될 수 있다. 쉽게 말해 전자는 컴퓨터 등에 의해 만들어진 가상의 공간이나 환경 속에 사용자가 몰입되는 경우로, 3D 게임과 같은 경우가 떠올리기 쉬운 예이다. 이러한 가상현실 속에서는 현실에서는 존재하지 않는 상상의 것들도 있을 수 있고 사용자가 그것을 만지거나 조작을 가하는 등의 상호작용이 가능하다. 후자는 현실 세계의 정보가 가상현실 시스템 기기를 통해 사용자에게 전달되는 경우를 말한다. 특히 사용자가 사용자에게 제시되는 대상과 원거리에 있는 경우, 가상현실을 이용한 공간 공유가 필요해 지는데 이 경우를 원격현전(텔레익지스턴스; tele-existence)라 부른다. 원격현전을 가능하게 하는 기술로 원거리 로보틱스(tele-robotics)가 있다. 카메라가 장착된 로봇을 조종하여 인간이 실제로 가기 힘들거나 물리적으로 떨어져 있는 장소를 탐사, 관찰하는 경우가 해당된다. 또, 사용자가 직접 지각 할 수 있는 현실의 대상물에 대해서 컴퓨터가 더 많은 정보를 부가, 제시하는 경우인 증강 현실(Augmented Reality; AR)이나 복합 현실(Mixed Reality; MR)도 후자의 경우이다. 증강 현실의 예로 쉽게 떠올릴 수 있는 것은 스마트폰에 장착된 카메라로 사용자의 주변에 있는 건물들을 비추어 볼 때 그 건물에 대한 정보가 스마트폰 화면에 떠오르고 그것을 사용자가 확인할 수 있는 경우이다. 증강 현실은 교육, 경제, 문화 등 다양한 영역에서 응용될 수 있고 응용되고 있다. 시스템 환경에 따른 분류 가상현실 시스템은 3차원 시뮬레이션을 통해 실제 같은 효과를 부여하는 시스템으로서 시스템이 사용되는 환경에따라 몰입형 가상현실(immersive VR), 원거리 로보틱스(tele-robotics), 데스크톱 가상현실(desktop VR), 삼인칭 가상현실(third person VR)로 나뉠 수 있다. 몰입형 가상현실: HMD(Head Mounted Display), 데이터 장갑(data glove), 데이터 옷(data suit) 등의 특수 장비를 통해 인간으로 하여금 실제로 보고 만지는 것 같은 감각적 효과를 느끼게 해 생생한 환경에 몰입하도록 하는 시스템을 말한다. 원거리 로보틱스: 몰입시스템+로봇의 형태이다. 로봇을 이용하여 먼 거리에 있는 공간에 사용자가 현전하는 효과를 주는 시스템을 말한다. 데스크톱 가상현실: 일반 컴퓨터 모니터에 간단한 입체안경, 조이스틱 등만 첨가하여 책상 위에서 쉽게 만날 수 있는 가상현실 시스템을 말한다. 삼인칭 가상현실: 비디오카메라로 촬영된 자신의 모습을 컴퓨터가 만들어내는 가상공간에 나타나게 하여 자신이 가상공간에 직접 존재하는 것처럼 느끼게 하는 시스템을 말한다. 주로 오락용으로 많이 쓰이며 대표적인 예로 Xbox 키넥트(KINECT)가 있다. 가상현실의 뜻은 다양한 사람들이 다양하게 정의하고 있다. 하지만 공통적인 요소를 정리해본다면 ‘컴퓨터 기술을 통해 인간의 오감을 자극하여 현실과 유사한 또다른 현실을 창조하는 활동’이라 할 수 있을 것이다. 즉 일정한 틀을 갖고 있는 것이 아니며 모든 상상 가능한 환경자체가 가상현실의 범위 안에 들어갈 것이다. 초기에는 Synthetic Environments, Cyberspace, Artificial Reality, Simulation Technology 등 다양하게 명명되었지만 최근에는 주로 가상현실(Virtual Reality; VR)로 불리고 있다. 2. 기초 기술과 응용가상현실의 개념은 최근 들어 정립된 것이지만 가상현실 시스템의 근간을 이루는 기술은 그보다 더 이전부터 존재하는 것들이었다. 컴퓨터 과학, 컴퓨터 그래픽스, 통신, 계측과 제어, 예술, 인지과학, HCI, 로보틱스 등이 그에 해당된다. 또 가상현실은 vr기술을 만들어 상용분야에서 응용되고 있다.상용실에 관한 IEEE의 국제회의에서는 다음과 같은 세부 분야가 있다고 하였다. 정보의 취득과 제시의 시스템 분산 처리 시스템·인공지능 시스템 인물이나 물체의 위치 추적 사람의 감각 상호작용과 공동 작업 시뮬레이터 증강현실, 복합현실 내비게이션 3. 가상현실에 대한 철학적 논의가상현실에 대한 철학적 논의가 본격화되기 이전부터 가상현실은 SF영화나 문학작품, 기술 분야에서 다양한 이름으로 명명되며 사람들에게 인식되었다. 닐 스티븐슨의 사이버 펑크 소설 스노우 크래쉬(1991)에서 명명된 ‘메타버스(Metaverse)’와 윌리엄 깁슨의 소설 뉴로맨서(1984)에서 ‘사이버스페이스(cyberspace)’가 그 예이다. 그러나 컴퓨터 기술의 지속적 발달로 인해 가상현실 시스템이 실제로 인간의 삶속에서 영향력을 발휘하고, 현대인의 삶의 무대가 가상의 공간으로까지 확장됨에 따라 가상현실에 대한 적극적인 철학적 논의와 고찰의 필요성이 대두되었다. 가상현실에 대한 철학적 논의는 ‘가상현실’에서 가상, 즉 ‘버추얼(virtual)’의 개념자체에 대한 것도 있고, 인간감각의 한계 및 가상현실 기술의 특성과 관련하여 존재론적인 고찰, 실재성과 공간성 개념에 대한 논의들도 활발히 제기되고 있다. 가상현실에 대한 철학적으로 고찰한 서적으로 마이클 하임(Michael Heim)의 가상현실의 철학적 의미(1993)가 있다. 또, 가상현실에 대한 직접적 논의를 다루고 있지는 않지만 ‘가상성’과 관련하여 장 보드리야르(Jean baudrillard)의 시뮬라시옹이 유명하다. 가상현실에 대한 철학적 사유를 자극하는 영화로는 매트릭스, 토탈리콜, 공각기동대 등이 있다. 구글, 독립형 데이드림 VR 헤드셋 및 VPS 기술로 가상현실 수준 높인다구글이 새로운 독립형 가상현실 헤드셋과 VPS라고 부르는 실내 GPS의 일종을 활용한 실내 탐색 방식을 통해 증강현실과 가상현실의 가장 큰 과제 중 하나를 풀었다고 밝혔다. 구글은 올해 말 구글 데이드림(Daydream) 기술을 활용한 독립형 VR 디바이스를 출시하기 위해, HTC 및 레노버와 협력하고 있다고 전했다. 구글은 새로운 독립 데이드림 헤드셋을 위해 퀄컴과 협력하고 있으며, 내부에 퀄컴 칩을 사용할 예정이다. 한편, 구글은 소비자들이 에이수스의 젠폰 AR(Zenfone AR)과 구글의 프로젝트 탱고 기술을 활용한 2세대 휴대폰을 올여름에 만나볼 수 있다고 밝혔다. 대부분의 제조사들은 가상현실과 증강현실을 역량의 범위로 보고 있으며, 두 기술을 위한 디바이스는 별도로 존재하겠지만, 기술의 경계가 앞으로 더 흐려질 것으로 보인다. 하지만 이를 위해 해결해야 할 과제 중 하나는 물리적으로 PC에 연결된 헤드셋으로 시야가 가려진 가상현실 사용자들에게 움직임의 자유를 주는 것이다. 구글의 가상현실 담당 부사장인 클레이 베이버는 새로운 독립형 VR 디바이스들은 현세대의 경험을 획기적으로 향상시킬 것이라고 말했다. 그는 “VR에 필요한 모든 것을 헤드셋 자체에 담는다는 아이디어다. 케이블, 휴대폰, PC, 아무것도 필요없다”고 말했다. 베이버에 따르면, 독립형 VR 디바이스는 가상현실 활동에 최적화된 디바이스와 구성품을 갖추고 있다. 또한, 베이버가 “정밀한 추적(precise tracking)”이라고 표현한 것을 사용한다. 실 세계에서 헤드셋의 위치를 감지하기 위해 외부 센서에 의존하는 것이 아니라, 마이크로소프트의 홀로렌즈처럼 ‘내부에서 외부로’ 추적하는 형태로 보인다. 이 독립형 VR 헤드셋이 홀로렌즈처럼 모든 것을 디바이스 안에서 처리하는지는 확실치 않다. 하지만 인텔과 AMD 모두 PC가 렌더링 엔진으로 남아있고, 고속대량의 단거리 무선 연결을 통해 데이터를 주고받는 미래에 대해서 이야기했다. 구글의 전략은 PC를 제외하는 것이지만, 구글 클라우드가 이러한 용도로 사용될지는 확실치 않다. 구글은 이에 대해서 전혀 밝힌 것이 없다. 증강현실독립형 VR 디바이스가 어느 정도의 움직임의 자유를 제공한다면, 증강현실을 완전한 이동형 기술이다. 구글은 증강현실 헤드셋인 구글 글래스를 만들었고, 휴대폰의 증강현실을 위해 개발을 포기했다. 구글은 증강현실의 차세대 ‘게임 체인저’를 VPS(Visual Positioning Service)로 생각하고 있다. VPS는 GPS와 유사한 매핑 기술이다. GPS는 외부에서 휴대폰의 위치를 추적하기 위해 위성을 사용한다. 하지만 쇼핑몰 등 실내에서는 휴대폰의 위치를 찾기 어렵고, 현재 블루투스 비콘 등 다른 기술을 활용해야 디바이스의 위치를 추적할 수 있다. VPS는 복도의 끝, 조명, 선반 위의 물건 등 일련의 시점(visual points)을 활용해서 사용자의 위치를 파악한다. 매장이나 박물관에 사용자가 들어갔을 때, 감자칩을 판매하는 곳이나 미술 전시관, 혹은 비상구의 위치를 알고 싶다고 가정해보자. 휴대폰의 카메라를 장소를 ‘보는’ 용도로 활용해서 VPS가 목적지까지 사용자를 안내한다. 마지막으로, 구글은 학교용 지리 앱인 익스피디션(Expeditions)의 새로운 AR 기능을 소개했다. 익스피디션은 이미 가상현실로 유명 유적지를 볼 수 있도록 하는데, 여기에 증강현실까지 추가됐다. 해당 기능은 올해 말에 배포될 예정이다. 참고 : IT World","categories":[],"tags":[{"name":"증강현실","slug":"증강현실","permalink":"http://apexsoft.github.io/tags/증강현실/"},{"name":"AR","slug":"AR","permalink":"http://apexsoft.github.io/tags/AR/"},{"name":"VR","slug":"VR","permalink":"http://apexsoft.github.io/tags/VR/"},{"name":"가상현실","slug":"가상현실","permalink":"http://apexsoft.github.io/tags/가상현실/"}]},{"title":"Transaction","slug":"@Transactional","date":"2018-07-31T02:12:47.231Z","updated":"2018-07-31T02:12:47.231Z","comments":true,"path":"2018/07/31/@Transactional/","link":"","permalink":"http://apexsoft.github.io/2018/07/31/@Transactional/","excerpt":"","text":"@Transactional 정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크가 끊기거나 서버에 장애가 생겨서 작업을 완료할 수 없다면, 그 때까지 변경된 사용자의 레벨은 그대로 둘까요? 아니면 모두 초기상태로 되돌려 놓아야 할까요? 이 문제에 대한 답은,‘작업 중간에 문제가 발생해서 작업이 중단된다면,그 때까지 진행된 변경 작업도 모두 취소시켜야 한다.’이다. 트랜잭션(Transaction) 더 이상 나눌 수 없는 단위 작업을 말한다.(= 원자성) 따라서 중간에 예외가 발생해서 작업을 완료할 수 없다면, 아예 작업이 시작되지 않은 것처럼 초기 상태로 되돌려놓아야 한다. 이것이 바로 트랜잭션이다 DB의 트랜잭션 DB 는 그 자체로 완벽한 트랜잭션을 지원한다. 하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있다. ❑ 트랜잭션 롤백(Transaction rollback) 여러 개의 SQL이 하나의 트랜잭션이 된 경우에, 중간 작업에서 문제가 생겼을 때 그 전까지 완료한 작업들까지도 모두 취소시키는 것. ❑ 트랜잭션 커밋(Transaction commit) 여러 개의 SQL이 하나의 트랜잭션이 된 경우에, 모든 SQL 수행 작업이 다 성공적으로 마무리됐다고 DB에 알려줘서 작업을 확정시키는 것. ❑ 트랜잭션의 경계설정(Transaction demarcation) 트랜잭션의 시작 지점과 종료 지점을 정해주는 것. 종료 시점은 commit 또는 roll back을 하는 시점이 된다. 트랜잭션의 경계는 하나의 connection이 만들어지고 닫히는 범위 안에 존재한다. ❑ 로컬 트랜잭션(Local transaction) 하나의 DB 커넥션 안에서 만들어지는 트랜잭션. 적용 범위 인터페이스를 구현한 클래스로 선언된 빈은 인터페이스 메소드에 한해서 트랜잭션이 적용됨 인터페이스에 붙은 @Transactional 선언은 인터페이스 내의 모든 메소드에 적용됨 동시에 메소드 레벨에도 @Transactional을 지정할 수 있다. 메소드 선언 &gt; 인터페이스 선언 클래스의 @Transactional &gt; 인터페이스의 @Transactional ​ 적용 우선 순위 @Transactional을 적용하는 우선순위는클래스의 메소드 &gt; 클래스&gt; 인터페이스의 메소드 &gt; 인터페이스 메소드에 @Transactional이 있으면 클래스 레벨의 @Transactional 선언보다 우선해서 적용된다. 클래스에 @Transactional 을 부여했을 때 트랜잭션이 적용되는 메소드는 프록시 방식과 인터페이스의 여부에 따라서 조금 달라진다. 클래스의 @Transactional 은 인터페이스의 @Transactional 선언보다 우선한다. @Transactional(readOnly = true) 트랜잭션이 읽기 전용이다. 내부에서 write가 일어나면 exception이 발생한다. (내부적으로는 DB를 바라볼 때 Slave DB를 바라본다.) @Transactional(readOnly = false) 트랜잭션이 읽기/쓰기가 모두 가능하다. 내부적으로는 DB를 바라볼 때 Master DB를 바라본다. ​ 따라서 코딩할 때, 전체 클래스를 readOnly = true 로 잡아두고 write가 필요한 매서드 안에서만 readOnly = false 를 줘야한다.","categories":[],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://apexsoft.github.io/tags/JPA/"},{"name":"java","slug":"java","permalink":"http://apexsoft.github.io/tags/java/"},{"name":"DB","slug":"DB","permalink":"http://apexsoft.github.io/tags/DB/"}]}]}